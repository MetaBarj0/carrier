#!/bin/sh

# /!\ DO NOT EDIT THIS FILE
# It is part of the automated build system. Images can be customized following
# instructions in READMEs files. Moreover, you can get inspired by template
# files located in the share/image directory

set -ex

# encure that the argument passed to the script is good enough to build an image
checkArgument() {
  local argument_error_message="$(
  cat << EOI
Error: Bad argument specified.
Expected is either :
- an absolute path to a manifest file of a docker image project located in the
  docker/share/images directory
- a relative path from your current directory to a manifest file of a docker
  image project located in the docker/share/images directory
- the name of the directory of the docker image project you want to build,
  located in the docker/share/images directory

Taking theses remarks into account should help you to resolve your
problem...exiting...
EOI
  )"
  
  # This script needs one argument: either
  #  - an absolute path to a manifest file
  #  - a relative path to a manifest file
  #  - a valid docker image name which can be found in the share/image directory
  if [ ! $# -eq 1 ]; then
    error "$argument_error_message"
    exit 1
  fi
  
  # try to resolve the manifest file path by:
  #  - appending it to the current user directory, useful if relative path is
  #    provided
  #  - testing directly the file path, useful if absolute path is provided
  local manifest_arg="$1"
  if [ ! -f ${USER_DIRECTORY}/"$manifest_arg" ] \
     && [ ! -f "$manifest_arg" ]; then
    # not a file path, testing the image name
    manifest_arg=${DOCKER_IMAGES_DIRECTORY}/"$1"/manifest
    if [ ! -f ${manifest_arg} ]; then
      error "$argument_error_message"
      exit 1
    fi
  fi

  # OK, valid argument, exposing the manifest file absolute path
  MANIFEST_FILE_PATH=${manifest_arg}
}

# look for the existence of foundation images on the docker host. If this check
# fails, no build is possible.
checkFoundationImages() {
  # first, verify if bootstrap has built all necessary foundation images, that
  # is metabarj0/manifest, metabarj0/gcc, metabarj0/make and
  # metabarj0/docker-cli
  local required_images="$(
  cat << EOI
metabarj0/manifest
metabarj0/gcc
metabarj0/make
metabarj0/docker-cli
EOI
  )"
  
  for i in $required_images; do
    id=$(docker image ls -q $i)
    if [ -z $id ]; then
      error "$(cat << EOI
Error: the mandatory image "$i" has not been found on your docker host.  Make
sure you have properly bootstrapped your docker host before attempting any image
build...exiting...
EOI
)"
      exit 1
    fi
  done
}

# setup important docker directories in global variables that will be used
# later.
setupDockerDirectories() {
  # current directory
  USER_DIRECTORY=$(pwd -P)

  # resolving important docker directories
  DOCKER_BIN_DIRECTORY=$(dirname $0)
  cd ${DOCKER_BIN_DIRECTORY}/..

  DOCKER_ROOT_DIRECTORY=$(pwd -P)
  DOCKER_BIN_DIRECTORY=${DOCKER_ROOT_DIRECTORY}/bin
  DOCKER_LIB_DIRECTORY=${DOCKER_ROOT_DIRECTORY}/lib
  DOCKER_TMP_DIRECTORY=${DOCKER_ROOT_DIRECTORY}/tmp
  DOCKER_SHARE_DIRECTORY=${DOCKER_ROOT_DIRECTORY}/share
  DOCKER_IMAGES_DIRECTORY=${DOCKER_SHARE_DIRECTORY}/images

  # back to current directory
  cd $USER_DIRECTORY
}

# check for the existence of zll dependencies of the image requested to be built
# and attempt to build them if they are not present on the docker host.
buildDependencies() {
  # browse all dependencies
  for dep in $REQUIRES; do
    # first, check on the host if the image exists; if so, continue without
    # building it
    local repository=$(docker image ls -q "$dep")
    if [ ! -z "$repository" ]; then
      continue
    fi

    # no existing image found on the host, building it, the current directory
    # being the image staging directory, there must be a docker directory to
    # look into from the global docker tmp directory
    local dependency_manifest=$(
      find ${FETCHED_MANIFEST} \
        -name manifest \
        -exec \
          grep -EH 'PROVIDES='$dep'$' {} \; \
          | sed -E 's/^([^:]+):.+/\1/'
    )

    # transform dependency_manifest to be just the image name
    local dependency_manifest_dir=$(dirname $dependency_manifest)
    dependency_manifest=$(basename $dependency_manifest_dir)

    # about to trigger a recursive build in a subshell
    local this_script_name=$(basename $0)
    local this_script_path=${DOCKER_BIN_DIRECTORY}/$this_script_name
    ( exec $this_script_path "$dependency_manifest" )
  done

}

# fill the staging area with file necessary to build the project.
fillStagingArea() {
  local image_directory=$(dirname $MANIFEST_FILE_PATH)

  # create the intermediate images directory in the staging area if it does not
  # already exist
  local staging_directory=${DOCKER_TMP_DIRECTORY}/images

  # sanitize the satging area if this is this execution is the first (no
  # recursion)
  if [ -z "$FETCHED_MANIFEST" ]; then
    rm -rf $staging_directory
  fi

  mkdir -p $staging_directory

  # copy the project in the staging area
  cp -a $image_directory $staging_directory

  # copy necessary lib files in the project directory in the staging area
  local image_name=$(basename $image_directory)
  IMAGE_STAGING_DIRECTORY=${staging_directory}/$image_name

  cd $DOCKER_LIB_DIRECTORY

  cp \
    .dockerignore \
    build-image.sh \
    build.sh \
    Dockerfile.build-image \
    exportPackageTo \
    functions.sh \
    importPackageFrom \
    $IMAGE_STAGING_DIRECTORY

  cd $USER_DIRECTORY
}

# attempt to build the image
buildProject() {
  # source the content of the manifest file, that will initialize some useful 
  # variables
  . $MANIFEST_FILE_PATH

  # build all dependencies of this project first if there are
  if [ ! -z "$REQUIRES" ]; then
    fetchManifestImageContent $IMAGE_STAGING_DIRECTORY
    buildDependencies "$@"
  fi
  
  # rely on some variables extracted from the manifest file that was parsed
  (
    exec \
      ${IMAGE_STAGING_DIRECTORY}/build.sh \
      $PROVIDES \
      $IMAGE_STAGING_DIRECTORY \
      "$EXTRA_DOCKERFILE_COMMANDS"
  )
}

# when the build is complete, cleanup the staging area
cleanupStagingArea() {
  rm -rf $IMAGE_STAGING_DIRECTORY

  if [ -z "$(ls ${DOCKER_TMP_DIRECTORY}/images)" ]; then
    rm -r ${DOCKER_TMP_DIRECTORY}/images
  fi
}

# the execution begins right here
checkFoundationImages
setupDockerDirectories

. ${DOCKER_LIB_DIRECTORY}/functions.sh

checkArgument "$1"
fillStagingArea
buildProject "$@"
cleanupStagingArea
