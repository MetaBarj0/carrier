#!/bin/sh

#### standalone mode, external utility functions not loaded yet ################
set -e

# disable this f*cking globbing
set -f

### set up paths after calling this script
initializePaths() {
  # get the full path of the called script
  cd $(dirname "$0")
  CALLED_SCRIPT="$(pwd -P)"/"$(basename "$0")"
  cd - 1>/dev/null 2>&1

  # if it is a symlink, resolve it, keeping the link path
  if [ -L "$CALLED_SCRIPT" ]; then
    INSTALLED_LINK_PATH="$CALLED_SCRIPT"
    CARRIER_SCRIPT_PATH="$(readlink -f "$CALLED_SCRIPT")"
  else
    CARRIER_SCRIPT_PATH="$CALLED_SCRIPT"
  fi

  # if the carrier script has been renammed, not supported => error
  if [ ! "$(basename "$CARRIER_SCRIPT_PATH")" = 'carrier' ]; then
    echo '`carrier` script has been renammed, not supported...exiting' 1>&2
    return 1
  fi

  # this directory exists and its path is absolute, verifying its name though
  CARRIER_BIN_DIR="$(dirname "$CARRIER_SCRIPT_PATH")"

  if [ ! "$(basename "$CARRIER_BIN_DIR")" = 'bin' ]; then
    cat << EOI 1>&2
The \`carrier\` script must reside in the \`bin/\` directory.
Not supported...exiting...
EOI
  return 1
  fi

  # set up each carrier directories and verify them
  local relative_carrier_root_dir="$CARRIER_BIN_DIR"/..
  local relative_carrier_lib_dir="$relative_carrier_root_dir"/lib
  local relative_carrier_share_dir="$relative_carrier_root_dir"/share
  local relative_carrier_share_bootstrap_dir=\
"$relative_carrier_share_dir"/bootstrap
  local relative_carrier_share_images_dir="$relative_carrier_share_dir"/images
  local relative_carrier_share_appliances_dir=\
"$relative_carrier_share_dir"/appliances
  local relative_carrier_src_dir="$relative_carrier_root_dir"/src

  if [ ! -d "$relative_carrier_lib_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_lib_dir does not exist. Your \`carrier\` package seems
broken or corrupted. Not supported...exiting...
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_dir does not exist. Your \`carrier\` package
seems broken or corrupted. Not supported...exiting...
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_bootstrap_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_bootstrap_dir does not exist. Your \`carrier\`
package seems broken or corrupted. Not supported...exiting...
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_images_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_images_dir does not exist. Your \`carrier\`
package seems broken or corrupted. Not supported...exiting...
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_appliances_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_appliances_dir does not exist. Your \`carrier\`
package seems broken or corrupted. Not supported...exiting...
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_src_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_src_dir does not exist. Your \`carrier\` package seems
broken or corrupted. Not supported...exiting...
EOI
  return 1
  fi

  cd $relative_carrier_root_dir
  CARRIER_ROOT_DIR="$(pwd -P)"
  CARRIER_LIB_DIR="$CARRIER_ROOT_DIR"/lib
  CARRIER_SHARE_DIR="$CARRIER_ROOT_DIR"/share
  CARRIER_SHARE_BOOTSTRAP_DIR="$CARRIER_SHARE_DIR"/bootstrap
  CARRIER_SHARE_IMAGES_DIR="$CARRIER_SHARE_DIR"/images
  CARRIER_SHARE_APPLIANCES_DIR="$CARRIER_SHARE_DIR"/appliances
  CARRIER_SRC_DIR="$CARRIER_ROOT_DIR"/src
  CARRIER_TMP_DIR="$CARRIER_ROOT_DIR"/tmp
  USER_DIRECTORY="$(cd -)"

  return 0
}

### load utilities located in $CARRIER_LIB_DIR/functions.sh
loadUtilities() {
  local functions_sh_path="$CARRIER_LIB_DIR"/functions.sh

  if [ ! -f "$functions_sh_path" ]; then
    cat << EOI 1>&2
Fatal: $CARRIER_LIB_DIR/functions.sh does not exist. Your \`carrier\` package
seems broken or corrupted. not supported...existing...
EOI
    return 1
  fi

  # source stuff!
  . "$functions_sh_path"

  return 0
}

initializePaths
loadUtilities

# log function wired, fail on error is not necessary anymore
set +e
#### end of standalone mode, external utility functions loaded #################

### utility function returning true if log level is trace
isTraceLogLevel() {
  [ "$GLOBAL_OPTION_LOG_LEVEL" = 'trace' ]

  return $?
}

### utility function returning true if log level is debug
isDebugLogLevel() {
  isTraceLogLevel \
  || [ "$GLOBAL_OPTION_LOG_LEVEL" = 'debug' ]

  return $?
}

### utility function returning true if log level is info or greater
isInfoLogLevel() {
  isDebugLogLevel \
  || [ "$GLOBAL_OPTION_LOG_LEVEL" = 'info' ]

  return $?
}

### utility function returning true if log level is warning or greater
isWarningLogLevel() {
  isInfoLogLevel \
  || [ "$GLOBAL_OPTION_LOG_LEVEL" = 'warning' ]

  return $?
}

### utility function returning true if log level is error or greater
isErrorLogLevel() {
  isWarningLogLevel \
  || [ "$GLOBAL_OPTION_LOG_LEVEL" = 'error' ]

  return $?
}

### utility function returning true if log level is fatal or greater
isFatalLogLevel() {
  isErrorLogLevel \
  || [ "$GLOBAL_OPTION_LOG_LEVEL" = 'fatal' ]

  return $?
}

### logging function, designed to debug
### first and unique argument is the message
debug() {
  isDebugLogLevel && log '[debug] '"$1" "$GLOBAL_OPTION_LOG_OUTPUT"
  return 0
}

### logging function, designed to info
### first and unique argument is the message
info() {
  isInfoLogLevel && log '[info] '"$1" "$GLOBAL_OPTION_LOG_OUTPUT"
  return 0
}

### logging function, designed to warning
### first and unique argument is the message
warning() {
  isWarningLogLevel && log '[warning] '"$1" "$GLOBAL_OPTION_LOG_OUTPUT"
  return 0
}

### logging function, designed to error
### first and unique argument is the message
error() {
  isErrorLogLevel && log '[error] '"$1" "$GLOBAL_OPTION_LOG_OUTPUT"
  return 0
}

### logging function, designed to fatal
### first and unique argument is the message
fatal() {
  isFatalLogLevel && log '[fatal] '"$1" "$GLOBAL_OPTION_LOG_OUTPUT"
  return 0
}

### basic usage function, shows syntax, how to use, purpose and so on...
usage() {
  cat << EOI
Usage:
  carrier [global options] \\
          [[domain] [domain options] command [command options]] | \\
          command [command options]

Use:

  carrier help --full to get a full usage description
EOI

  return 0
}

### internal that remove unnecessary information from global options referential
### specified in argument
removeIrrelevantDetailsFromReferentialOption() {
  local referential="$1"

  echo "$referential"\
  | sed -E '/^--$/d' \
  | sed -E '/contextSet.+/d'

  local returnCode=$?

  [ $returnCode -eq 0 ] \
  && debug 'removeIrrelevantDetailsFromReferentialOption() sucess' \
  || debug 'removeIrrelevantDetailsFromReferentialOption() failed'

  [ "$returnCode" -ne 0 ] \
  && fatal 'could not purify the options referential to get detailed help'

  return $returnCode
}

### Get a full help on usage
usageFull() {
  cat << EOI
$(usage)

Global options:
$(removeIrrelevantDetailsFromReferentialOption "$GLOBAL_OPTIONS_REFERENTIAL")

Global commands:
$(removeIrrelevantDetailsFromReferentialOption "$GLOBAL_COMMANDS_REFERENTIAL")

Help command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL")

Info command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL")

Install command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_INSTALL_OPTIONS_REFERENTIAL")

Pack command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_PACK_OPTIONS_REFERENTIAL")

Unpack command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_UNPACK_OPTIONS_REFERENTIAL")

Vagrant command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_VAGRANT_OPTIONS_REFERENTIAL")

Domains:
$(removeIrrelevantDetailsFromReferentialOption "$DOMAINS_REFERENTIAL")

Bootstrap domain commands:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_BOOTSTRAP_COMMANDS_REFERENTIAL")

Bootstrap run command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTIONS_REFERENTIAL")

Bootstrap check command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS_REFERENTIAL")

Image domain commands:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMANDS_REFERENTIAL")

Image build command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_BUILD_OPTIONS_REFERENTIAL")

Image list command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_LIST_OPTIONS_REFERENTIAL")

Image check command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_CHECK_OPTIONS_REFERENTIAL")

Image info command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_INFO_OPTIONS_REFERENTIAL")

Image upgrade command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL")

Appliance domain commands:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMANDS_REFERENTIAL")

Appliance build command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTIONS_REFERENTIAL")

Appliance list command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_LIST_OPTIONS_REFERENTIAL")

Appliance check command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTIONS_REFERENTIAL")

Appliance info command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_INFO_OPTIONS_REFERENTIAL")

Appliance start command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_START_OPTIONS_REFERENTIAL")

Appliance stop command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_STOP_OPTIONS_REFERENTIAL")

Appliance volumes command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTIONS_REFERENTIAL")

Appliance upgrade command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL")
EOI

  return 0
}

### built the argument referential, sort of description and constraints about
### each valid argument.
### each line of a variable definition define a pattern one arg can match at a
### time :
###
### line 0: optional comment lines starting with #
### line 1: pattern for argument
### line 2: pattern for argument value or --
### line 3: function name initializing execution context
buildArgumentsReferential() {
  info 'setting up the arguments referential'

  GLOBAL_OPTIONS_REFERENTIAL="$(cat << EOI
# desired log level. Defaulted to 'error'.
# i.e. carrier info --log-level=error
#      carrier info -l debug
(-l|--log-level)=?
fatal|error|warning|info|debug|trace
contextSetLogLevel

# desired output for logs. Defaulted to '&2' that is stderr
# i.e. carrier info --log-output=error.log
#      carrier info -o '&2'
(-o|--log-output)=?
.+
contextSetLogOutput
EOI
  )"

  GLOBAL_COMMANDS_REFERENTIAL="$(cat << EOI
# domainless commands. only valid when not any domain is specified.
#
# help: provides help about carrier usage
#       i.e. carrier help
#
# info: Provides general information about carrier
#       i.e. carrier info
#
# install: Install carrier to the specified location. Installation is a simple
#          process consisting in creating a symbolic link to the specified
#          location. If carrier is already installed somewhere or a symlink exist
#          with the specified name, the process fails by default.
#          Note: If a file (not a symlink) exists at the specified location the
#          process will always fails even if forced.
#          If a symlink exists and points on something existing other than a
#          carrier installation, the process will always fails to preserve
#          system integrity.
#
# pack: Packs carrier into a single executable file, easying its transportation
#       and allowing it to be used on network-isolated systems (using specific
#       command options). By default, all the directory architecture of carrier
#       is packed, including necessary resources to bootstrap your system. Thus,
#       an internet connection is required to pack carrier.
#       Moreover, user file ~/.carrier will also be included. The resulting file
#       will be a shell script containing shell code and base64 encoded tar
#       archive. As a result, modern tar and base64 implementations are
#       necessary to use the pack command efficiently
#       i.e. carrier pack
#
# unpack: unpack a packed version of carrier, creating the original directory
#         structure of carrier. If you downloaded image sources in the packed
#         carrier, you can choose to keep them (this is not the default behavior
#         though). The .carrier file is extracted to the user directory.
#
# vagrant: manipulate the vagrant environment of carrier. Each command and
#          option you specify are directly forwarded to the vagrant program. If
#          vagrant is not found, the process fails.
help|info|install|pack|unpack|vagrant
--
contextSetGlobalCommand
EOI
  )"

  GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL="$(cat << EOI
# options for the domainless help command. Turn on exhaustive help
# i.e. carrier help -H
#      carrier help --full
-H|--full
--
contextSetHelpMode
EOI
  )"

  GLOBAL_COMMAND_INFO_OPTIONS_REFERENTIAL="$(cat << EOI
# specify the output format:
# - shell: give a a list of pairs of the form VAR=VAL
# - json: create a json object containing requested properties
(-f|--format)=?
shell|json
contextSetInfoFormat
EOI
  )"

  GLOBAL_COMMAND_INSTALL_OPTIONS_REFERENTIAL="$(cat << EOI
# Force the installation of carrier to the path specified even if a previous
# installation has been detected. If a reinstallation occurs, remove the
# previous one. Even if this flag is set, installation may fail if destination
# already exists and does not correspond to a previous carrier installation
-f|--force
--
contextSetInstallForce

# If reinstallation occurs, keep the existing one.
# i.e carrier install --force --keep-previous-installation
-k|--keep-previous-installation
--
contextSetInstallKeep
EOI
  )"

  GLOBAL_COMMAND_PACK_OPTIONS_REFERENTIAL="$(cat << EOI
# While packing, fetch all supported image sources from the internet and embbed
# them in the package. Beware as the package could grow arbitrarily large. Using
# this option is interesting if you want to use carrier on a network isolated
# system. This is not the default behavior of packing.
# i.e carrier pack --fetch-all-images-sources
-s|--fetch-all-images-sources
--
contextSetPackFetchAll

# Instead of packing carrier, only fetch sources of images. This option can be
# specified with -s and -i. This is not the default behavior of packing.
-o|--only-fetch-sources
--
contextSetPackFetchOnly

# While packing, fetch sources of specified images only. Sources of unspecified
# images will not be fetched, leading to a less heavy package but forcing one to
# grab source from the internet if an attempt to build an image that does not
# have its source stored locally is made. This is not the default behavior of
# packing.
# i.e carrier pack -i metabarj0/wget,metabarj0/llvm
(-i|--fetch-images-sources)=?
[^,]+(,[^,]+)*
contextSetPackSpecificImageFetch
EOI
  )"

  GLOBAL_COMMAND_UNPACK_OPTIONS_REFERENTIAL="$(cat << EOI
# While unpaking, do not delete fetch sources. This is not the default behavior
-k|--keep-sources-if-any
--
contextSetUnpackKeepSources
EOI
  )"

  GLOBAL_COMMAND_VAGRANT_OPTIONS_REFERENTIAL="$(cat << EOI
# Specify where to find the vagrant program. Defaulted to vagrant, therefore,
# vagrant is supposed to be found in the PATH environment variable.
(-p|--vagrant-path)=?
.+
contextSetVagrantPath

# commands/arguments/options to forward to the vagrant program. Must be enclosed
# by quotes to be parsed as a single argument in the carrier point of view.
'.+'
--
contextSetVagrantArguments
EOI
  )"

  DOMAINS_REFERENTIAL="$(cat << EOI
# specific domain of application for carrier. A domain is the highest level
# context carrier acts on.
#
# bootstrap: the bootstrap context can be used with bootstrap specific commands
#            and options. Allows one to deal with all the bootstrapping stuff.
#
# image: the image context is related to docker image manipulation and provides
#        image specific commands and options.
#
# appliance: the appliance domain deals with appliance manipulation and provides
#            appliance specific commands and options.
bootstrap|image|appliance
--
contextSetDomain
EOI
  )"

  DOMAIN_BOOTSTRAP_COMMANDS_REFERENTIAL="$(cat << EOI
# available commands in the bootstrap domain
# - check verify the current environment is correctly bootstrap
# - run bootstrap the system
check|run
--
contextSetBootstrapCommand
EOI
  )"

  DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS_REFERENTIAL="$(cat << EOI
# no options yet
EOI
  )"

  DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTIONS_REFERENTIAL="$(cat << EOI
# specifying this option for a bootstrap run command allows to keep existing
# images produced by a previous bootstrap run. Images will be tagged with the
# current data and time using the '+%Y%m%d%H%M%S' format usable with the date
# command.
-t|--retag-existing-images
--
contextSetBootstrapRunRetag
EOI
  )"

  DOMAIN_IMAGE_COMMANDS_REFERENTIAL="$(cat << EOI
# available commands for the image domain.
# - build can build one or more images
# - list can list images on the system, reporting information about the
#   availability of images
# - check verifies one or more images are healthy and up to date
# - info report about internal informations about an image
# - upgrade can upgrade one or more image regarding their dependencies status
build|list|check|info|upgrade|factorize
--
contextSetImageCommand
EOI
  )"

  DOMAIN_IMAGE_COMMAND_BUILD_OPTIONS_REFERENTIAL="$(cat << EOI
# specifying this option while building an image prevent the system to tag a
# previous version existing on the docker host. As a result, if a previous
# version of the image being built were present; it is deleted instead of being
# retagged. This is not the default behavior.
-r|--remove-existing-images
--
contextSetImageBuildRemoveExisting

# sequence (or unique) image to be built. The sequence can be made of :
# - image name (the directory name containing image files)
# - relative path of the image manifest file
# - absolute path of the image manifest file
# - a mix of all three
[^,]+(,[^,]+)?
--
contextSetImageBuildImageSequence
EOI
  )"

  DOMAIN_IMAGE_COMMAND_LIST_OPTIONS_REFERENTIAL="$(cat << EOI
# list all images, built, not built, local and remote
-a|--all
--
contextSetImageListAll

# list only built images
-b|--only-built
--
contextSetImageListOnlyBuilt

# list only not built images
-n|--only-not-built
--
contextSetImageListOnlyNotBuilt

# list only local images that are not present on remote repository (new images
# being created for instance)
-l|--only-local
--
contextSetImageListOnlyLocal

# list only supported images that are present on the remote repository.
-r|--only-remote
--
contextSetImageListOnlyRemote

# specify the output format:
# - one-line outputs the result in one line, each image name being separated by
#   a space character and formated as following:
#   image1:flags,image2:flags,...
#   flags being:
#   - b for built
#   - n for not built
#   - l for local
#   - r for remote
# Note that local and remote are not exclusive though it is unlikely to have an
# image flagged as remote that is not present on your local system (unless you
# deliberatly removed it)
# - pretty outputs a very nice table (default)
# - docker relies on the docker client to output the result. You can specify
# docker specific format information appending
# \`:'docker format args for docker images'\`
# The docker format works only for built images
(-f|--format)=?
one-line|pretty|docker(:'.*')?
contextSetImageListFormat
EOI
  )"

  DOMAIN_IMAGE_COMMAND_CHECK_OPTIONS_REFERENTIAL="$(cat << EOI
# checks all built image by checking their dependencies integrity. If an image
# name is output, it means that something is wrong with the dependency chain.
# Image name is output if:
# - a dependency is newer than the image, meaning the image may need to be
#   rebuilt
# - a dependency is missing meaning the image may not be up to date
# - the /image.dist file of the image is missing or corrupted, meaning something
#   went wrong when image has been built.
# checking all images is the default behavior
-a|--all-installed
--
contextSetImageCheckAllBuilt

# ignore the build date of dependecies when checking images
-d|--ignore-date
--
contextSetImageCheckIgnoreDate

# ignore if dependency is missing on the docker host when checking images
-m|--ignore-missing
--
contextSetImageCheckIgnoreMissing

# ignore detected defect in image checking (not recommended)
-i|--ignore-image-dist-defects
--
contextSetImageCheckIgnoreDependencyDefects

# format the output if something is found:
# - list gives a list of the form:
#   image:issue1,issue2...
# - pretty ouput a nice table (default)
(-f|--format)=?
list|pretty
contextSetImageCheckFormat

# explicit image list to cheack instead of all
(-l|--image-list)=?
[^,]+(,[^,]+)*
contextSetImageCheckImageSequence
EOI
  )"

  DOMAIN_IMAGE_COMMAND_INFO_OPTIONS_REFERENTIAL="$(cat << EOI
# report all properties of requested image (default behavior)
-a|--report-all
--
contextSetImageInfoAllProps

# only report the image.dist content
-i|--report-image-content
--
contextSetImageInfoOnlyContent

# only report the docker image name provided
-p|--report-provides
--
contextSetImageInfoOnlyProvides

# only report dependency image names
-r|--report-requires
--
contextSetImageInfoOnlyRequires

# report the name of the base image
-b|--report-base-image
--
contextSetImageInfoOnlyBaseImage

# report the name of the image used to fetch sources
-d|--report-sources-fetch-image
--
contextSetImageInfoOnlyFetchImage

# report the command used to fetch sources
-s|--report-sources-fetch-command
--
contextSetImageInfoOnlyFetchCommand

# report the name of the sources tarball
-c|--report-sources-tarball-name
--
contextSetImageInfoOnlyTarballName

# report extra dockerfile commands appended to the generated Dockerfile for the
# image building process
-x|--report-build-extra-dockerfile-commands
--
contextSetImageInfoOnlyBuildExtraDockerfileCommands

# report extra dockerfile commands used to build the final image
-z|--report-final-extra-dockerfile-commands
--
contextSetImageInfoOnlyFinalExtraDockerfileCommands

# specify the output format:
# - shell: give a a list of pairs of the form VAR=VAL
# - json: create a json object containing requested properties
(-f|--format)=?
shell|json
contextSetImageInfoFormat

# the image to observe
.+
--
contextSetImageInfoImage
EOI
  )"

  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL="$(cat << EOI
# attempt an upgrade of all built images by checking their dependencies
# integrity and status. If one or more dependencies have a problem or is newer
# than the observed image, both actions are taken:
# - dependencies is corrupted: report the issue and does nothing else
# - a dependency is newer than the image : the observed image is rebuilt
# - a dependency is missing : report and does nothing else
# this is the default behavior
-a|--all-installed
--
contextSetImageUpgradeAll

# ignore the date of dependencies of the observed image. Note that ignore date
# in using the upgrade command will always inhibit the image rebuild.
-d|--ignore-date
--
contextSetImageUpgradeIgnoreDate

# does not report missing dependency
-m|--ignore-missing
--
contextSetImageUpgradeIgnoreMissing

# does not report a defect problem in a dependency image
-i|--ignore-image-dist-defects
--
contextSetImageUpgradeIgnoreDependencyDefects

# specify an image list instead of attempting to upgrade them all. list has the
# form :
# image1,image2...
(-l|--image-list)=?
[^,]+(,[^,]+)*
contextSetImageUpgradeImageSequence
EOI
  )"

  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTIONS_REFERENTIAL="$(cat << EOI
# options available when factorizing two or more images to extract a base that
# contains all common files. Factorizing images consists in taking 2 or more
# images, extract all files that are common in all these images, create a brand
# new image with these common files, and create new images with their
# respective files without common extracted ones.

# the name to give to the extracted base image. Note that the provided name
# must be conform to the docker standart in term of naming.
(-n|--base-image-name)=?
.+
contextSetImageFactorizeBaseImageName

# this is the prefix used to name the extracted base image. As a result, a
# prefixed base image will look like : prefix/base_image_name when listing
# docker images
# if not specified, defaulted to 'base'
(-b|--base-image-prefix)=?
.*
contextSetImageFactorizeBaseImagePrefix

# prefix used on factorized images. A prefixed factorized image will look like
# prefix/factorize_image when listing docker images. If the prefix is not
# specified, the prefixed base image name is used.
(-f|--factorized-image-prefix)=?
.+
contextSetImageFactorizeFactorizedImagePrefix

# the image list to factorize. At least 2 images have to be specified but
# specifying more than 2 is perfectly valid. However, keep in mind that
# specified images having lots of files in common tend to be more factorizable.
(-l|--image-list)=?
[^,]+(,[^,]+)+
contextSetImageFactorizeImageSequence

# indicates if original images must be removed after a successful
# factorization. defaulted to 'no'
(-r|--remove-original-images)=?
--
contextSetImageFactorizeRemoveOriginalImages
EOI
  )"

  DOMAIN_APPLIANCE_COMMANDS_REFERENTIAL="$(cat << EOI
# available commands for the appliance domain.
# - build can build one or more appliances.
# - list can list appliances on the system, reporting information about the
#   availability of appliances
# - check verifies one or more appliances are healthy and up to date
# - info report about internal informations about an appliance
# - upgrade can upgrade one or more appliances regarding their service image and
#   dependencies status
# - start can start an appliance or several
# - stop can stop one or more appliances
# - volumes can help the user to manage columes used by an appliance
build|list|check|info|upgrade|start|stop|volumes
--
contextSetApplianceCommand
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTIONS_REFERENTIAL="$(cat << EOI
# When building an appliance, remove all appliance service images that already
# exist on the docker host. This is not the default behavior as by default, if
# images exist, nothing is built
-r|--remove-existing-images
--
contextSetApplianceBuildRemoveExisting

# When building an appliance, tag all existing service image using the
# '+%Y%m%d%H%M%S' format usable with the date command. This is not the default
# behavior as by default, if images exist, nothing is built
-t|--tag-existing-images
--
contextSetApplianceBuildTagExisting

# the appliance list to build. Has the form:
# appliance1,appliance2...
[^,]+(,[^,]+)?
--
contextSetApplianceBuildApplianceSequence
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_LIST_OPTIONS_REFERENTIAL="$(cat << EOI
# list all appliances, built, not built, local and remote
-a|--all
--
contextSetApplianceListAll

# list only built appliances
-b|--only-built
--
contextSetApplianceListOnlyBuilt

# list only not built appliances
-n|--only-not-built
--
contextSetApplianceListOnlyNotBuilt

# list only local appliances that are not present on remote repository (new
# appliances being created for instance)
-l|--only-local
--
contextSetApplianceListOnlyLocal

# list only supported appliances that are present on the remote repository.
-r|--only-remote
--
contextSetApplianceListOnlyRemote

# specify the output format:
# - one-line outputs the result in one line, each appliance name being separated
#   by a space character and formated as following:
#   appliance1:flags,appliance2:flags,...
#   flags being:
#   - b for built
#   - n for not built
#   - l for local
#   - r for remote
# Note that local and remote are not exclusive though it is unlikely to have an
# appliance flagged as remote that is not present on your local system (unless you
# deliberatly removed it)
# - pretty outputs a very nice table (default)
(-f|--format)=?
one-line|pretty
contextSetApplianceListFormat
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTIONS_REFERENTIAL="$(cat << EOI
# verify all built appliances by checking each of its service image. (default
# behavior)
-a|--all-installed
--
contextSetApplianceCheckAll

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are more up to date than the
# service image, it is ignored and the service image will be considered ok
-d|--ignore-date
--
contextSetApplianceCheckIgnoreDate

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are missing on the docker host
# it is ignored and the service image will be considered ok
-m|--ignore-missing
--
contextSetApplianceCheckIgnoreMissing

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies have something wrong in their
# image.dist file, it is ignored and the service image will be considered ok
# (this is not recommended)
-i|--ignore-image-dist-defects
--
contextSetApplianceCheckIgnoreDependencyDefects

# explicit list of appliance to check. The list has the form:
# appliance1,appliance2...
(-l|--appliance-list)=?
[^,]+(,[^,]+)*
contextSetApplianceCheckApplianceList
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_INFO_OPTIONS_REFERENTIAL="$(cat << EOI
# report all information properties of the appliance (default behavior)
-a|--report-all
--
contextSetApplianceInfoAllProps

# report only the base image used for the observed service image
-b|--report-base-image
--
contextSetApplianceInfoOnlyBase

# execute a docker-compose config on the appliance docker-compose.yml file
-c|--report-config
--
contextSetApplianceInfoOnlyConfig

# reports only dependent images required for the service being observed
-r|--report-requires
--
contextSetApplianceInfoOnlyRequires

# report only extra Dockerfile commands used in the observed service image
-x|--report-extra-dockerfile-commands
--
contextSetApplianceInfoOnlyExtraDockerfileCommands

# inspect all services of the appliance (default behavior)
-s|--all-services
--
contextSetApplianceInfoAllServices

# specify a list of service to observe. List has the form:
# service1,service2...
(-s|--service)=?
[^,]+(,[^,])*
contextSetApplianceInfoServiceSequence

# output format of the report
# shell is a list of pairs of the form key=value (default)
# json output the result in a json object
(-f|--format)=?
shell|json
contextSetApplianceInfoFormat

# the appliance to get info from
.+
--
contextSetApplianceInfoAppliance
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_START_OPTIONS_REFERENTIAL="$(cat << EOI
# if appliances requested to start does not exist, attempt to build it
# beforehand using default options. Default behavior
-b|--build
--
contextSetApplianceStartBuild

# do not attempt to build appliance service image if they are missing. If one
# or more service images are missing this command will fail(not default behavior)
-n|--dont-build
--
contextSetApplianceStartDontBuild

# list of appliance to start. List has the form:
# appliance1,appliance2...
[^,]+(,[^,]+)*
--
contextSetApplianceStartApplianceSequence
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_STOP_OPTIONS_REFERENTIAL="$(cat << EOI
# when stopping an appliance, also remove created containers. Containers are
# considered ephemeral by design so it is the default behavior
-d|--rm
--
contextSetApplianceStopRemoveContainers

# do not delete appliance container when stopping. This is not the default
# behavior
-k|--keep-containers
--
contextSetApplianceStopKeepContainers

# list of appliance to stop. List has the form:
# appliance1,appliance2...
[^,]+(,[^,]+)*
--
contextSetApplianceStopApplianceSequence
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTIONS_REFERENTIAL="$(cat << EOI
# list the appliance volumes
-l|--list
--
contextSetApplianceVolumesList

# remove all the appliance volumes
-r|--rm
--
contextSetApplianceVolumesRemove

# dump specified volumes
-d|--dump
--
contextSetApplianceVolumesDump

# specify the dump file path (defaulted to current directory)
(-p|--dump-file-path)=?
.+
contextSetApplianceVolumesDumpPath

# specific list of volume. used with --rm and --dump options
(-v|--volume-list)=?
[^,]+(,[^,]+)*
contextSetApplianceVolumesList

# targeted appliance
(-a|--appliance)=?
.+
contextSetApplianceVolumesAppliance
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL="$(cat << EOI
# scan all built appliances
-a|--all-installed
--
contextSetApplianceUpgradeAll

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are more up to date than the
# service image, it is ignored and the service image will be considered up to
# date
-d|--ignore-date
--
contextSetApplianceUpgradeIgnoreDate

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are missing on the docker host
# it is ignored and the service image will be considered up to date
-m|--ignore-missing
--
contextSetApplianceUpgradeIgnoreMissing

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies have something wrong in their
# image.dist file, it is ignored and the service image will be considered up to
# date (this is not recommended)
-i|--ignore-image-dist-defects
--
contextSetApplianceUpgradeIgnoreDependencyDefects

# explicit list of appliance to check. The list has the form:
# appliance1,appliance2...
(-l|--appliance-list)=?
[^,]+(,[^,]+)*
contextSetApplianceUpgradeApplianceSequence
EOI
  )"

  return 0
}

### initialize the execution context of carrier, dictating what to do with
### provided arguments
initializeExecutionContext() {
  info 'Initializing the execution context with default values'

  # user can set up this variable value before executing this script. It allows
  # to take benefit of the log level before having to parse arguments passed to
  # the script, allowing to log level higher than error before the execution
  # begins
  # carrier --log-level=error ...
  [ -z "$GLOBAL_OPTION_LOG_LEVEL" ] \
  && GLOBAL_OPTION_LOG_LEVEL=error

  GLOBAL_OPTION_LOG_OUTPUT='&2'

  # carrier help, carrier appliance run ...
  COMMAND=

  # carrier help -H
  GLOBAL_COMMAND_HELP_OPTION_MODE=

  # carrier info --format=shell
  GLOBAL_COMMAND_INFO_OPTION_FORMAT='shell'

  # carrier install --force -k
  GLOBAL_COMMAND_INSTALL_OPTION_FORCE='no'
  GLOBAL_COMMAND_INSTALL_OPTION_KEEP='no'

  # carrier pack -s
  GLOBAL_COMMAND_PACK_OPTION_FETCH_ALL_SOURCES='no'
  GLOBAL_COMMAND_PACK_OPTION_ONLY_FETCH_SOURCES='no'
  GLOBAL_COMMAND_PACK_OPTION_FETCH_SPECIFIC_IMAGE_SOURCES=

  # carrier unpack -k
  GLOBAL_COMMAND_UNPACK_OPTION_KEEP_SOURCES='no'

  # carrier vagrant -p '/usr/local/bin/vagrant' up
  GLOBAL_COMMAND_VAGRANT_OPTION_PATH='vagrant'
  GLOBAL_COMMAND_VAGRANT_OPTION_ARGUMENTS=

  # bootstrap or image or appliance
  DOMAIN=

  # not used yet
  DOMAIN_OPTIONS=

  # not used yet
  DOMAIN_BOOTSTRAP_OPTIONS=
  DOMAIN_IMAGE_OPTIONS=
  DOMAIN_APPLIANCE_OPTIONS=

  # carrier bootstrap check
  DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS=

  # carrier bootstrap run --retag-existing-images
  DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTION_RETAG_EXISTING='no'

  # carrier image build -r metabarj0/wget
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_REMOVE_EXISTING='no'
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE=

  # carrier image list -b --format json
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ALL='yes'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_BUILT='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_NOT_BUILT='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_LOCAL='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_REMOTE='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_FORMAT='pretty'

  # carrier image check --all --ignore-missing
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_ALL_IMAGES='yes'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DATE='no'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_MISSING='no'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_FORMAT='pretty'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IMAGE_SEQUENCE=

  # carrier image info --report-base-image -f shell
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ALL='yes'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_CONTENT='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_PROVIDES='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_REQUIRES='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_BASE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_IMAGE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_COMMAND='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_TARBALL_NAME='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_BUILD_DOCKERFILE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_FINAL_DOCKERFILE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_FORMAT='shell'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_IMAGE=

  # carrier image upgrade metabarj0/git,metabarj0/gdb
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_ALL='yes'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DATE='no'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING='no'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IMAGE_SEQUENCE=

  # carrier image factorize \
  #   -n dev_toolchains \
  #   -l metabarj0/llvm,metabarj0/gcc
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME=
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_PREFIX='base'
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_FACTORIZED_IMAGE_PREFIX=
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE=
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_REMOVE_ORIGINAL_IMAGES='no'

  # carrier appliance build devenv_cpp -r
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_REMOVE_EXISTING='no'
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_TAG_EXISTING='no'
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE=

  # carrier appliance list --only-remote -f one-line
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_BUILT='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_NOT_BUILT='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_LOCAL='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_REMOTE='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_FORMAT='pretty'

  # carrier appliance check devenv_cpp
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DATE='no'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_MISSING='no'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_APPLIANCE_LIST='no'

  # carrier appliance info --report-config
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_REPORT_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_BASE='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_CONFIG='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_REQUIRES='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_EXTRA_DOCKERFILE='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_ALL_SERVICES='yes'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_SERVICE_LIST=
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_FORMAT='shell'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_APPLIANCE=

  # carrier appliance start devenv_cpp -n
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_BUILD='yes'
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE=

  # carrier appliance stop  --keep-containers devenv_cpp
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_REMOVE_CONTAINERS='yes'
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE=

  # carrier appliance volumes devenv_cpp
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_LIST='yes'
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_REMOVE='no'
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_DUMP='no'
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_DUMP_PATH='./'
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_VOLUME_SEQUENCE=
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_APPLIANCE=

  # carrier appliance upgrade devev_cpp
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DATE='no'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING='no'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_APPLIANCE_SEQUENCE=

  return 0
}

### internal function displyaing the content of the execution context
debugOutputExecutionContext() {
  cat << EOI
  GLOBAL_OPTION_LOG_LEVEL=\
$GLOBAL_OPTION_LOG_LEVEL
  GLOBAL_OPTION_LOG_OUTPUT=\
$GLOBAL_OPTION_LOG_OUTPUT
  COMMAND=\
$COMMAND
  GLOBAL_COMMAND_HELP_OPTION_MODE=\
$GLOBAL_COMMAND_HELP_OPTION_MODE
  GLOBAL_COMMAND_INFO_OPTION_FORMAT=\
$GLOBAL_COMMAND_INFO_OPTION_FORMAT
  GLOBAL_COMMAND_INSTALL_OPTION_FORCE=\
$GLOBAL_COMMAND_INSTALL_OPTION_FORCE
  GLOBAL_COMMAND_INSTALL_OPTION_KEEP=\
$GLOBAL_COMMAND_INSTALL_OPTION_KEEP
  GLOBAL_COMMAND_PACK_OPTION_FETCH_ALL_SOURCES=\
$GLOBAL_COMMAND_PACK_OPTION_FETCH_ALL_SOURCES
  GLOBAL_COMMAND_PACK_OPTION_ONLY_FETCH_SOURCES=\
$GLOBAL_COMMAND_PACK_OPTION_ONLY_FETCH_SOURCES
  GLOBAL_COMMAND_PACK_OPTION_FETCH_SPECIFIC_IMAGE_SOURCES=\
$GLOBAL_COMMAND_PACK_OPTION_FETCH_SPECIFIC_IMAGE_SOURCES
  GLOBAL_COMMAND_UNPACK_OPTION_KEEP_SOURCES=\
$GLOBAL_COMMAND_UNPACK_OPTION_KEEP_SOURCES
  GLOBAL_COMMAND_VAGRANT_OPTION_PATH=\
$GLOBAL_COMMAND_VAGRANT_OPTION_PATH
  GLOBAL_COMMAND_VAGRANT_OPTION_ARGUMENTS=\
$GLOBAL_COMMAND_VAGRANT_OPTION_ARGUMENTS
  DOMAIN=\
$DOMAIN
  DOMAIN_OPTIONS=\
$DOMAIN_OPTIONS
  DOMAIN_BOOTSTRAP_OPTIONS=\
$DOMAIN_BOOTSTRAP_OPTIONS
  DOMAIN_IMAGE_OPTIONS=\
$DOMAIN_IMAGE_OPTIONS
  DOMAIN_APPLIANCE_OPTIONS=\
$DOMAIN_APPLIANCE_OPTIONS
  DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS=\
$DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS
  DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTION_RETAG_EXISTING=\
$DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTION_RETAG_EXISTING
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_REMOVE_EXISTING=\
$DOMAIN_IMAGE_COMMAND_BUILD_OPTION_REMOVE_EXISTING
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ALL=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ALL
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_BUILT=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_BUILT
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_NOT_BUILT=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_NOT_BUILT
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_LOCAL=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_LOCAL
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_REMOTE=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_REMOTE
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_FORMAT=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_FORMAT
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_ALL_IMAGES=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_ALL_IMAGES
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DATE=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DATE
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_MISSING=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_MISSING
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_FORMAT=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_FORMAT
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IMAGE_SEQUENCE
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ALL=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ALL
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_CONTENT=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_CONTENT
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_PROVIDES=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_PROVIDES
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_REQUIRES=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_REQUIRES
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_BASE=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_BASE
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_IMAGE=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_IMAGE
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_COMMAND=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_COMMAND
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_TARBALL_NAME=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_TARBALL_NAME
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_BUILD_DOCKERFILE=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_BUILD_DOCKERFILE
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_FINAL_DOCKERFILE=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_FINAL_DOCKERFILE
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_FORMAT=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_FORMAT
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_IMAGE=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_IMAGE
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_ALL=\
$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_ALL
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DATE=\
$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DATE
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING=\
$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS=\
$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IMAGE_SEQUENCE
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_PREFIX=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_PREFIX
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_FACTORIZED_IMAGE_PREFIX=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_FACTORIZED_IMAGE_PREFIX
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_REMOVE_ORIGINAL_IMAGES=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_REMOVE_ORIGINAL_IMAGES
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_REMOVE_EXISTING=\
$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_REMOVE_EXISTING
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_TAG_EXISTING=\
$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_TAG_EXISTING
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ALL=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ALL
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_BUILT=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_BUILT
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_NOT_BUILT=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_NOT_BUILT
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_LOCAL=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_LOCAL
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_REMOTE=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_REMOTE
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_FORMAT=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_FORMAT
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_ALL=\
$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_ALL
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DATE=\
$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DATE
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_MISSING=\
$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_MISSING
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS=\
$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_APPLIANCE_LIST=\
$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_APPLIANCE_LIST
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_REPORT_ALL=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_REPORT_ALL
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_BASE=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_BASE
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_CONFIG=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_CONFIG
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_REQUIRES=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_REQUIRES
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_EXTRA_DOCKERFILE=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_EXTRA_DOCKERFILE
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_ALL_SERVICES=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_ALL_SERVICES
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_SERVICE_LIST=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_SERVICE_LIST
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_FORMAT=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_FORMAT
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_APPLIANCE=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_APPLIANCE
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_BUILD=\
$DOMAIN_APPLIANCE_COMMAND_START_OPTION_BUILD
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_REMOVE_CONTAINERS=\
$DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_REMOVE_CONTAINERS
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_LIST=\
$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_LIST
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_REMOVE=\
$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_REMOVE
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_DUMP=\
$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_DUMP
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_DUMP_PATH=\
$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_DUMP_PATH
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_VOLUME_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_VOLUME_SEQUENCE
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_APPLIANCE=\
$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_APPLIANCE
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_ALL=\
$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_ALL
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DATE=\
$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DATE
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING=\
$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS=\
$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_APPLIANCE_SEQUENCE
EOI

  return 0
}

### utility function mutating the execution context provided with a referential
### and a pair of key value
tryMutateReferential() {
  info 'attempting to mutate the execution context'

  local referential="$1"
  local key="$2";
  local value="$3";

  # each 'entry' in a referential is made of 3 lines
  local key_pattern= ; local value_pattern= ; local mutator=

  # iterating through the referential
  for line in $referential; do
    # iterate to initialize locals, then do the processing
    [ -z "$key_pattern" ] && key_pattern="$line" && continue
    [ -z "$value_pattern" ] && value_pattern="$line" && continue
    mutator="$line"

    debug "$(cat << EOI
key_pattern=$key_pattern
value_pattern=$value_pattern
mutator=$mutator
EOI
    )"

    # test the provided key
    echo "$key" | grep -Ex -- "$key_pattern" 1> /dev/null

    if [ $? -ne 0 ]; then
      # the key do not match, test another entry in the referential
      # resetting patterns and mutator for another turn
      key_pattern= ; value_pattern= ; mutator=

      warning "$(cat << EOI
provided key: $key does not match the explored referential key
pattern: $key_pattern
EOI
      )"

      continue
    fi

    # testing value if necessary, a '--' pattern indicating that the key has not
    # value associated in the referential
    if [ ! "$value_pattern" = '--' ]; then
      echo "$value" | grep -Ex -- "$value_pattern" 1> /dev/null

      if [ ! $? -eq 0 ]; then
        # the value do not match, test another entry in the referential
        # resetting patterns and mutator for another turn
        key_pattern= ; value_pattern= ; mutator=

        warning "$(cat << EOI
provided value: $value does not match the exploredi referential value
pattern: $value_pattern
EOI
        )"

        continue
      fi
    fi

    # value matched the pattern, call the mutator with both key and value,
    # though value may be empty
    # echo m="$mutator" k="$key" v="$value"
    "$mutator" "$key" "$value"
    local returnCode=$?

    [ "$returnCode" -ne 0 ] \
      && warning "$(cat << EOI
The mutator: $mutator failed to execute correctly with key: $key and
value: $value
EOI
          )"

    return $returnCode
  done

  # failed to modify the execution context for this referential. unless it is
  # the most specialized referential (command options) it is not fatal as more
  # specialized referential will be explored for mutation
  warning 'Could not modify the referential: '"$referential"
  return 1
}

### specialized mutator designed to mutate global options settings. Provided with
### 2 arguments with at least one that must be non empty.
tryMutateGlobalOptions() {
  info 'attempting to mutate global options'

  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referential, removing all comments
  local referential="$(deleteCommentLines "$GLOBAL_OPTIONS_REFERENTIAL")"

  tryMutateReferential "$referential" "$key" "$value"

  local returnCode=$?

  warning "$(cat << EOI
could not mutate global options with key: $key and value: $value
EOI
)"

  return $returnCode
}

### specialized mutator designed to mutate the domain. Provided with
### 2 arguments with at least one that must be non empty.
tryMutateDomain() {
  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referential, removing all comments
  local referential="$(deleteCommentLines "$DOMAINS_REFERENTIAL")"

  tryMutateReferential "$referential" "$key" "$value"

  local returnCode=$?

  warning "$(cat << EOI
could not mutate the domain with key: $key and value: $value
EOI
  )"

  return $returnCode
}

### specialized mutator designed to mutate domain options settings. Provided
### with 2 arguments with at least one that must be non empty.
tryMutateDomainOptions() {
  # there is not any domain option that are supported so far
  return 1
}

### specialized mutator designed to mutate global commands settings. Provided
### with 2 arguments with at least one that must be non empty.
tryMutateGlobalCommand() {
  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referential, removing all comments
  local referential="$(deleteCommentLines "$GLOBAL_COMMANDS_REFERENTIAL")"

  tryMutateReferential "$referential" "$key" "$value"

  local returnCode=$?

  warning "$(cat << EOI
could not mutate the command with key: $key and value: $value
EOI
)"

  return $returnCode
}

### attempt to mutate a domain command. Test all domains command in chain. if
### all fail, it means the key and value are not domain commands
tryMutateDomainCommand() {
  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referentials, removing all comments
  local bootstrap_referential="$(
    deleteCommentLines "$DOMAIN_BOOTSTRAP_COMMANDS_REFERENTIAL"
  )"

  local image_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMANDS_REFERENTIAL"
  )"

  local appliance_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMANDS_REFERENTIAL"
  )"

  tryMutateReferential "$bootstrap_referential" "$key" "$value" \
  || tryMutateReferential "$image_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_referential" "$key" "$value"

  local returnCode=$?

  warning "$(cat << EOI
could not mutate the domain command with key: $key and value: $value
EOI
)"

  return $returnCode
}

### attempt to modify the execution context related to options of global
### commands.
tryMutateGlobalCommandOptions() {
  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referentials, removing all comments
  local help_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL"
  )"

  local info_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_INFO_OPTIONS_REFERENTIAL"
  )"

  local install_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_INSTALL_OPTIONS_REFERENTIAL"
  )"

  local pack_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_PACK_OPTIONS_REFERENTIAL"
  )"

  local unpack_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_UNPACK_OPTIONS_REFERENTIAL"
  )"

  local vagrant_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_VAGRANT_OPTIONS_REFERENTIAL"
  )"

  # chaining mutation attempt, if all fail, argument were not about global
  # command options
  tryMutateReferential "$help_referential" "$key" "$value" \
  || tryMutateReferential "$info_referential" "$key" "$value" \
  || tryMutateReferential "$install_referential" "$key" "$value" \
  || tryMutateReferential "$pack_referential" "$key" "$value" \
  || tryMutateReferential "$unpack_referential" "$key" "$value" \
  || tryMutateReferential "$vagrant_referential" "$key" "$value"

  local returnCode=$?

  warning "$(cat << EOI
could not mutate the global command with key: $key and value: $value
EOI
)"

  return $returnCode
}

tryMutateDomainCommandOptions() {
  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referentials, removing all comments
  local bootstrap_check_referential="$(
    deleteCommentLines "$DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS_REFERENTIAL"
  )"

  local bootstrap_run_referential="$(
    deleteCommentLines "$DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTIONS_REFERENTIAL"
  )"

  local image_build_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_BUILD_OPTIONS_REFERENTIAL"
  )"

  local image_list_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_LIST_OPTIONS_REFERENTIAL"
  )"

  local image_check_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_CHECK_OPTIONS_REFERENTIAL"
  )"

  local image_info_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_INFO_OPTIONS_REFERENTIAL"
  )"

  local image_upgrade_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL"
  )"

  local image_factorize_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTIONS_REFERENTIAL"
  )"

  local appliance_build_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTIONS_REFERENTIAL"
  )"

  local appliance_list_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_LIST_OPTIONS_REFERENTIAL"
  )"

  local appliance_check_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTIONS_REFERENTIAL"
  )"

  local appliance_info_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_INFO_OPTIONS_REFERENTIAL"
  )"

  local appliance_upgrade_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL"
  )"

  local appliance_start_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_START_OPTIONS_REFERENTIAL"
  )"

  local appliance_stop_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_STOP_OPTIONS_REFERENTIAL"
  )"

  local appliance_volumes_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTIONS_REFERENTIAL"
  )"

  tryMutateReferential "$bootstrap_check_referential" "$key" "$value" \
  || tryMutateReferential "$bootstrap_run_referential" "$key" "$value" \
  || tryMutateReferential "$image_build_referential" "$key" "$value" \
  || tryMutateReferential "$image_list_referential" "$key" "$value" \
  || tryMutateReferential "$image_check_referential" "$key" "$value" \
  || tryMutateReferential "$image_info_referential" "$key" "$value" \
  || tryMutateReferential "$image_upgrade_referential" "$key" "$value" \
  || tryMutateReferential "$image_factorize_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_build_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_list_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_check_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_info_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_upgrade_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_start_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_stop_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_volumes_referential" "$key" "$value"

  local returnCode=$?

  warning "$(cat << EOI
could not mutate the domain command options with key: $key and
value: $value
EOI
)"

  return $returnCode
}

### mutates the execution context with a key and a value as arguments
tryMutateExecutionContext() {
  local key="$1"
  local value="$2"

  debug "key=$key
value=$value"

  # contextual mutation of the execution environment
  # - modification of global option is context free
  # - modification of the domain is ok only if not already set
  # - modification of domain option ok if domain is set
  # - modification of the command ok if not already set and depends if domain is
  #   set or not => global command or domain command
  # - command options modification can only take place after a command is set
  # as a result, a pair <key value> is used to mutate in order :
  # - global options                                   | more     ^ less
  # - domain                                           | specific | specific
  # - domain options                                   |          |
  # - global command or domain command                 |          |
  # - global command options or domain command options V          |
  #
  # Moreover, mutating global command and domain command are mutually exclusive
  # based on the domain set
  # same thing about global command option and domain command option, makes
  # sense.
  # general logic is following. The deeper you go the more specific you get:
  #
  # try mutate global option
  # `-> success => return 0
  # `-> failure ->
  #     try mutate domain
  #     `-> success => return 0
  #     `-> failure ->
  #         `-> try mutate domain option
  #             `-> success => return 0
  #             `-> failure ->
  #                 try mutate global command
  #                 `-> success => return 0
  #                 `-> failure ->
  #                     `-> try mutate domain command
  #                         `-> success => return 0
  #                         `-> failure ->
  #                             `-> try mutate global command options
  #                                 `-> success => return 0
  #                                 `-> failure ->
  #                                     try mutate domain command options
  #                                     `-> success => return 0
  #                                     `-> failure => return 1

  # chaining mutators by specificity order
  tryMutateGlobalOptions "$key" "$value" \
  || tryMutateDomain "$key" "$value" \
  || tryMutateDomainOptions "$key" "$value" \
  || tryMutateGlobalCommand "$key" "$value" \
  || tryMutateDomainCommand "$key" "$value" \
  || tryMutateGlobalCommandOptions "$key" "$value" \
  || tryMutateDomainCommandOptions "$key" "$value"

  local returnCode=$?

  warning "$(cat << EOI
could not mutate the execution context with key: $key and value: $value
EOI
)"

  return $returnCode
}

### internal function attempting to mutate the execution context with a provided
### argument of the form key=value
tryMutateExecutionContextWithKeyEqualsValueArg() {
  if ! isPair "$1"; then
    warning 'A pair is needed here. '"$1"' is not a pair'
    return 1
  fi

  local key="$(keyOf "$1")"
  local value="$(valueOf "$1")"

  debug "key=$key
value=$value"

  tryMutateExecutionContext "$key" "$value"

  local returnCode=$?

  warning "$(cat << EOI
could not mutate the domain command with key: $key and value: $value
EOI
)"

  return $returnCode
}

### build the final execution context regarding provided arguments
buildExecutionContextFromArguments() {
  # the arguments provided could take 2 different forms :
  # - simple switch
  # - key-value pair
  # The simple switch may have the dashed or double dashed form
  # The key-value pair may have the space or the '=' as separator. A space
  # character could be specified more than once. This is not the case for the
  # '=' character separator.

  # description of the algorithm:
  # As arguments may take several forms that are parsed differently, the
  # behavior of the algorithm depends of the form of the argument.
  # The most deterministic form is the key=value form.
  # Thus, the algorithm will attempt to mutate the execution context trying to
  # extract key and value from the next argument.
  # If the key/value extraction fails, the algorithm will try to mutate the
  # execution context with the next argument as if it had the dashed or double
  # dashed form. If it fails, the algorithm will attempt to extract the next
  # argument and consider it as the value of the previous one (that is the key
  # therefore)

  local extractedKeyFromArg=

  local arg=
  for arg in $@; do
    debug 'current parsed argument : '"$arg"

    if [ -z "$extractedKeyFromArg" ]; then
      if tryMutateExecutionContextWithKeyEqualsValueArg "$arg"; then
        info 'key=value args successfully altered the execution context'
        continue
      fi

      if tryMutateExecutionContext "$arg"; then
        info 'single arg successfully altered the execution context'
        continue
      fi

      info 'mutation failed with arg: '"$arg"' continuing...'
      extractedKeyFromArg="$arg"
      
      continue
    else
      if tryMutateExecutionContext "$extractedKeyFromArg" "$arg"; then
        info 'key value args successfully altered the execution context'
        extractedKeyFromArg=
        continue
      else
        error "$(cat << EOI
Failed to modify the execution context with key: $extractedKeyFromArg and
value: $arg
EOI
        )"
        return 1
      fi
    fi
  done

  return 0
}

### helper function executing the help command with its options if required
executeHelpCommand() {
  if [ "$COMMAND" = 'help' ]; then
    info 'help command has been requested'

    local mode="$GLOBAL_COMMAND_HELP_OPTION_MODE"
    [ "$mode" = '-H' ] || [ "$mode" = '--full' ]
    local fullMode=$?

    if [ "$fullMode" -eq 0 ]; then
      info 'full mode help requested'
      usageFull 
    else
      info 'brief mode help requested'
      usage
    fi
  else
    warning 'help was not the requested command'
    return 1
  fi

  return 0
}

### helper function executing the info command with its options if required
executeInfoCommand() {
  :

  warning 'Not implemented yet'
  return 1
}

### helper function executing the install command with its options if required
executeInstallCommand() {
  :

  warning 'Not implemented yet'
  return 1
}

### helper function executing the pack command with its options if required
executePackCommand() {
  :

  warning 'Not implemented yet'
  return 1
}

### helper function executing the unpack command with its options if required
executeUnpackCommand() {
  :

  warning 'Not implemented yet'
  return 1
}

### helper function executing the vagrant command with its options if required
executeVagrantCommand() {
  :

  warning 'Not implemented yet'
  return 1
}

### execute the check command of the bootstrap domain
executeBootstrapCheckCommand() {
  :

  warning 'Not implemented yet'
  return 1
}

### execute the check command of the bootstrap domain
executeBootstrapRunCommand() {
  # TODO handle options, draft version
  local returnCode=1

  if [ "$DOMAIN" = 'bootstrap' ] \
     && [ "$COMMAND" = 'run' ]; then
    info 'bootstrap run requested'
    bootstrap_run
    returnCode=$?

    [ $returnCode -ne 0 ] \
    && error 'could not bootstrap the system.'
  fi

  debug 'executeBootstrapRunCommand() Result'
  [ $returnCode -eq 0 ] \
  && debug 'execution succeeded' \
  || debug 'execution failed'

  return $returnCode
}

### execute the build command of the image domain
executeImageBuildCommand() {
  # TODO handle options, incomplete
  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'build' ] \
     || [ -z "$DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE" ]; then
    info "incomplete or incorrect execution context:
  DOMAIN=$DOMAIN
  COMMAND=$COMMAND
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE"
    return 1
  fi

  info 'splitting provided sequence using space character'
  local sequence="$(
    splitSequence \
    "$DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE" \
    ','
  )"

  # build each image in the sequence, calling the right script in a subshell
  local image=
  local returnCode=1
  for image in $sequence; do
    # the first image build failing return from that function
    image_build "$image"
    local returnCode=$?

    if [ $returnCode -ne 0 ]; then
      error 'Failed to build the requested '"$image"' image.'
      return $returnCode
    fi
  done

  return 0
}

### execute the list command of the image domain
executeImageListCommand() {
  :

  warning 'Not implemented yet'
  return 1
}

### execute the check command of the image domain
executeImageCheckCommand() {
  :

  warning 'Not implemented yet'
  return 1
}

### execute the info command of the image domain
executeImageInfoCommand() {
  :

  warning 'Not implemented yet'
  return 1
}

### execute the upgrade command of the image domain
executeImageUpgradeCommand() {
  :

  warning 'Not implemented yet'
  return 1
}

### execute the factorize command of the image domain
executeImageFactorizeCommand() {
  :

  fatal 'Not implemented yet'
  return 0
}

### execute the build command of the appliance domain
executeApplianceBuildCommand() {
  # TODO handle options, incomplete
  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'build' ] \
     || [ -z "$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE" ]; then
    info "incomplete or incorrect execution context:
  DOMAIN=$DOMAIN
  COMMAND=$COMMAND
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE"
    return 1
  fi

  # the sequence is comma separated, get it space separated
  local sequence="$(
    splitSequence \
    "$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE" \
    ','
  )"

  # build each appliance in the sequence, calling the right script in a subshell
  local appliance=
  for appliance in $sequence; do
    # the first appliance build failing return from that function
    ( appliance_manage 'build' "$appliance" )

    local returnCode=$?

    if [ $returnCode -ne 0 ]; then
      error 'Failed to build the requested '"$appliance"' appliance.'
      return $returnCode
    fi
  done

  return 0
}

### execute the list command of the appliance domain
executeApplianceListCommand() {
  :

  warning 'Not implemented yet'
  return 1
}

### execute the check command of the appliance domain
executeApplianceCheckCommand() {
  :

  warning 'Not implemented yet'
  return 1
}

### execute the info command of the appliance domain
executeApplianceInfoCommand() {
  :

  warning 'Not implemented yet'
  return 1
}

### execute the upgrade command of the appliance domain
executeApplianceUpgradeCommand() {
  :

  warning 'Not implemented yet'
  return 1
}

### execute the start command of the appliance domain
executeApplianceStartCommand() {
  # TODO handle options, incomplete
  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'start' ] \
     || [ -z "$DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE" ]; then
    info "incomplete or incorrect execution context:
  DOMAIN=$DOMAIN
  COMMAND=$COMMAND
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE"
    return 1
  fi

  # the sequence is comma separated, get it space separated
  local sequence="$(
    splitSequence \
    "$DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE" \
    ','
  )"

  # build each appliance in the sequence, calling the right script in a subshell
  local appliance=
  for appliance in $sequence; do
    # the first appliance build failing return from that function
    ( appliance_manage 'start' "$appliance" )

    local returnCode=$?

    if [ $returnCode -ne 0 ]; then
      warning 'Failed to start the requested '"$appliance"' appliance.'
      return $returnCode
    fi
  done

  return 0
}

### execute the stop command of the appliance domain
executeApplianceStopCommand() {
  # TODO handle options, incomplete
  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'stop' ] \
     || [ -z "$DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE" ]; then
    info "incomplete or incorrect execution context:
  DOMAIN=$DOMAIN
  COMMAND=$COMMAND
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE"
    return 1
  fi

  # the sequence is comma separated, get it space separated
  local sequence="$(
    splitSequence \
    "$DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE" \
    ','
  )"

  # build each appliance in the sequence, calling the right script in a subshell
  local appliance=
  for appliance in $sequence; do
    # the first appliance build failing return from that function
    ( appliance_manage 'stop' "$appliance" )

    local returnCode=$?

    if [ $returnCode -ne 0 ]; then
      error 'Failed to stop the requested '"$appliance"' appliance.'
      return $returnCode
    fi
  done

  return 0
}

### execute the volumes command of the appliance domain
executeApplianceVolumesCommand() {
  :

  warning 'Not implemented yet'
  return 1
}

### helper function executing the specified bootstrap command
executeBootstrapCommand() {
  info 'attempting to execute one bootstrap command one after another'

  executeBootstrapCheckCommand \
  || executeBootstrapRunCommand

  local returnCode=$?

  debug 'executeBootstrapCommand() Result'
  [ $returnCode -eq 0 ] \
  && debug 'execution succeeded' \
  || debug 'execution failed'

  return $returnCode
}

### helper function executing the specified image command
executeImageCommand() {
  info 'attempting to execute one image command one after another'

  executeImageBuildCommand \
  || executeImageListCommand \
  || executeImageCheckCommand \
  || executeImageInfoCommand \
  || executeImageUpgradeCommand \
  || executeImageFactorizeCommand

  local returnCode=$?

  debug 'executeImageCommand() Result'
  [ $returnCode -eq 0 ] \
  && debug 'execution succeeded' \
  || debug 'execution failed'

  return $returnCode
}

### helper function executing the specified apliance command
executeApplianceCommand() {
  info 'attempting to execute one appliance command one after another'

  executeApplianceBuildCommand \
  || executeApplianceListCommand \
  || executeApplianceCheckCommand \
  || executeApplianceInfoCommand \
  || executeApplianceUpgradeCommand \
  || executeApplianceStartCommand \
  || executeApplianceStopCommand \
  || executeApplianceVolumesCommand

  local returnCode=$?

  debug 'executeApplianceCommand() Result'
  [ $returnCode -eq 0 ] \
  && debug 'execution succeeded' \
  || debug 'execution failed'

  return $returnCode
}

### helper function executing one global command if specified
executeGlobalCommand() {
  info 'Attempting to execute one global command one after another'

  executeHelpCommand \
  || executeInfoCommand \
  || executeInstallCommand \
  || executePackCommand \
  || executeUnpackCommand \
  || executeVagrantCommand

  local returnCode=$?

  debug 'executeGlobalCommand() Result'
  [ $returnCode -eq 0 ] \
  && debug 'execution succeeded' \
  || debug 'execution failed'

  return $returnCode
}

### helper function executing one domain command if specified
executeDomainCommand() {
  info 'attempting to execute one command from all domains one after another'

  executeBootstrapCommand \
  || executeImageCommand \
  || executeApplianceCommand

  local returnCode=$?

  debug 'executeDomainCommand() Result'
  [ $returnCode -eq 0 ] \
  && debug 'execution succeeded' \
  || debug 'execution failed'

  return $returnCode
}

### Helper function activating the trace mode if requested (--log-level=trace)
### and executing this script from its very start
executeWithTraceIfRequested() {
  if isTraceLogLevel \
     && [ ! ${TRACE_ENABLED+0} ]; then
    debug 'trace enabled; restarting script...'

    local carrier_script="$(
      sed '2i\set -x' ${CARRIER_SCRIPT_PATH}
    )"

    TRACE_ENABLED= eval "$carrier_script"

    local returnCode=$?
    debug 'script execution finished, exiting with status code :'$returnCode
    exit $returnCode
  fi

  return 0
}

### Once the execution context is set, execute the script using it. As the
### execution context is verified when set, one function must succeed
executeWithContext() {
  debug "Execution Context:
$(debugOutputExecutionContext)"

  executeGlobalCommand \
  || executeDomainCommand

  local returnCode=$?

  debug 'executeWithContext() Result'
  [ $returnCode -eq 0 ] \
  && debug 'execution succeeded' \
  || debug 'execution failed'

  return $returnCode
}

#### Execution context mutator definition area #################################

### Mutator to set the log level. Valid call in any circumstances
contextSetLogLevel() {
  # key/value pair
  GLOBAL_OPTION_LOG_LEVEL="$2"
  debug 'GLOBAL_OPTION_LOG_LEVEL='"$2"

  return 0
}

### Mutator to set the log output. Valid call in any circumstances
contextSetLogOutput() {
  # key/value pair
  GLOBAL_OPTION_LOG_OUTPUT="$2"
  debug 'GLOBAL_OPTION_LOG_OUTPUT='"$2"

  return 0
}

### Mutator to set a global command. Valid call if:
### - no domain specified
contextSetGlobalCommand() {
  if [ ! -z "$DOMAIN" ]; then
    info 'A domain name must not be specified to set the '"$1"' global command'
    return 1
  fi

  # the key specified (first argument) is the command
  COMMAND="$1"
  debug 'COMMAND='"$1"

  return 0
}

### mutator to set the help mode. Valid call if:
### - command is 'help'
contextSetHelpMode() {
  if [ ! "$COMMAND" = 'help' ]; then
    info "$(cat << EOI
contextSetHelpMode() can only be used when specified command is help
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  # the key (first value) is the help mode
  GLOBAL_COMMAND_HELP_OPTION_MODE="$1"
  debug 'GLOBAL_COMMAND_HELP_OPTION_MODE='"$1"

  return 0
}

### mutator to set the domain. Valid call if:
### - no global command specified sooner
contextSetDomain() {
  # empty domain and non empty command denotes a global command specified sooner
  if [ -z "$DOMAIN" ] \
     && [ ! -z "$COMMAND" ]; then
    info "$(cat << EOI
contextSetDomain() can only be used if domain and command are unspecified
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  # the specified key (first arg) is the domain
  DOMAIN="$1"
  debug 'DOMAIN='"$1"

  return 0
}

### mutator to setup the bootstrap command. Valid call if:
### - domain is bootstrap
contextSetBootstrapCommand() {
  if [ ! "$DOMAIN" = 'bootstrap' ]; then
    info "$(cat << EOI
contextSetBootstrapCommand() can only be called if DOMAIN is bootstrap
  current DOMAIN=$DOMAIN
EOI
    )"
    return 1
  fi

  # the specified key (first arg) is the bootstrap command
  COMMAND="$1"
  debug 'COMMAND='"$1"

  return 0
}

### mutator to setup the image command. Valid call if:
### - domain is image
contextSetImageCommand() {
  if [ ! "$DOMAIN" = 'image' ]; then
    info "$(cat << EOI
contextSetImageCommand() can only be called if domain is image
  current DOMAIN=$DOMAIN
EOI
    )"
    return 1
  fi

  # the specified key (first arg) is the image command
  COMMAND="$1"
  debug 'COMMAND='"$1"

  return 0
}

### mutator to setup the sequence of image to build. Valid call if:
### - domain is image
### - command is build
contextSetImageBuildImageSequence() {
  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'build' ]; then
  info "$(cat << EOI
contextSetImageBuildImageSequence() can only be used when the domain is image
and the command is build.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
  )"
    return 1
  fi

  # the key (first arg) is the image sequence
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE="$1"
  debug 'DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE='"$1"

  return 0
}

### TODO NYI
contextSetImageListOnlyLocal() {
  :

  warning 'Not yet implemented'
  return 1
}

### TODO NYI
contextSetImageInfoImage() {
  :

  warning 'Not yet implemented'
  return 1
}

### TODO NYI
contextSetImageUpgradeImageSequence() {
  :

  warning 'Not yet implemented'
  return 1
}

### TODO NYI
contextSetImageCheckImageSequence() {
  :

  warning 'Not yet implemented'
  return 1
}

contextSetImageFactorizeBaseImagePrefix() {
  :

  warning 'Not yet implemented'
  return 1
}

contextSetImageFactorizeFactorizedImagePrefix() {
  :

  warning 'Not yet implemented'
  return 1
}

contextSetImageFactorizeBaseImageName() {
  :

  warning 'Not yet implemented'
  return 1
}

contextSetImageFactorizeImageSequence() {
  :

  fatal 'Not yet implemented'
  return 0
}

contextSetImageFactorizeRemoveOriginalImages() {
  :

  warning 'Not yet implemented'
  return 1
}

### mutator to setup the appliance command. Valid call if:
### - domain is appliance
contextSetApplianceCommand() {
  if [ ! "$DOMAIN" = 'appliance' ]; then
    info "$(cat << EOI
contextSetApplianceCommand() can only be called if domain is appliance
  current DOMAIN=$DOMAIN
EOI
    )"
    return 1
  fi

  # the specified key (first arg) is the appliance command
  COMMAND="$1"
  debug 'COMMAND='"$1"

  return 0
}

### TODO NYI
contextSetApplianceInfoAppliance() {
  :

  warning 'Not yet implemented'
  return 1
}

### TODO NYI
contextSetApplianceListOnlyLocal() {
  :

  warning 'Not yet implemented'
  return 1
}

### TODO NYI
contextSetApplianceVolumesList() {
  :

  warning 'Not yet implemented'
  return 1
}

contextSetApplianceCheckApplianceList() {
  :

  warning 'Not yet implemented'
  return 1
}

contextSetApplianceUpgradeApplianceSequence() {
  :

  warning 'Not yet implemented'
  return 1
}

### mutator to setup the sequence of appliance to build. Valid call if:
### - domain is appliance
### - command is build
contextSetApplianceBuildApplianceSequence() {
  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'build' ]; then
    info "$(cat << EOI
contextSetApplianceBuildApplianceSequence() can only be called when domain is
appliance and command is build.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  # the key (first arg) is the appliance sequence
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE="$1"
  debug 'DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE='"$1"

  return 0
}

### mutator to setup the sequence of appliance to start. Valid call if:
### - domain is appliance
### - command is start
contextSetApplianceStartApplianceSequence() {
  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'start' ]; then
    info "$(cat << EOI
contextSetApplianceStartApplianceSequence() can only be used if domain is
appliance and command is start
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  # the key (first arg) is the appliance sequence
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE="$1"
  debug 'DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE='"$1"

  return 0
}

### mutator to setup the sequence of appliance to start. Valid call if:
### - domain is appliance
### - command is start
contextSetApplianceStopApplianceSequence() {
  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'stop' ]; then
    info "$(cat << EOI
contextSetApplianceStopApplianceSequence() can only be used if domain is
appliance and command is stop
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  # the key (first arg) is the appliance sequence
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE="$1"
  debug 'DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE='"$1"

  return 0
}

#### End of execution context mutator definition area ##########################

#### bootstrap domain specific functions

### simply copy the bootstrap dir from share to a temporary staging area
bootstrap_fetchInStagingArea() {
  cp -r "$CARRIER_SHARE_BOOTSTRAP_DIR" "$CARRIER_TMP_DIR"

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'Unabled to copy bootstrap files in staging area.'

  debug 'bootstrap_fetchInStagingArea() Result'
  [ $returnCode -eq 0 ] \
  && debug 'execution succeeded' \
  || debug 'execution failed'

  return $returnCode
}

### copy useful lib script to the temporary staging area where bootstrap file
### reside
bootstrap_fetchLibInStagingArea() {
  cp "$CARRIER_LIB_DIR"/exportPackageTo \
     "$CARRIER_LIB_DIR"/importPackageFrom \
     "$CARRIER_LIB_DIR"/functions.sh \
     "$CARRIER_TMP_DIR"/bootstrap

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'Unabled to copy utilities files in staging area.'

  debug 'bootstrap_fetchLibInStagingArea() Result'
  [ $returnCode -eq 0 ] \
  && debug 'execution succeeded' \
  || debug 'execution failed'

  return $returnCode
}

### build the bootstrap docker image responsible to bootstrap the system
bootstrap_build() {
  cd "$CARRIER_TMP_DIR"/bootstrap

  docker build --squash -t metabarj0/bootstrap . \
  && docker image prune -f

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'bootstrap image build failed.'

  debug 'bootstrap_build() Result'
  [ $returnCode -eq 0 ] \
  && debug 'execution succeeded' \
  || debug 'execution failed'

  cd - 1>/dev/null 2>&1

  return $returnCode
}

### ask for some configuration and run the bootstrap image to bootstrap the
### system
bootstrap_run_image() {
  # TODO : take into account some variable of the execution context (auto answer yes)
  # need some functions
  . "$CARRIER_TMP_DIR"/bootstrap/functions.sh

  cat << EOI
Specify the version of GCC you want to build. Note that today, only 7.2.0
and 7.3.0 are supported : [7.3.0]
EOI

  local gcc_version="$(readValueWithDefault '7.3.0')"

  cat << EOI
Specify the binutils version you want to build. Note that for GCC 7.3.0, 2.29
is a working version : [2.29]
EOI

  local binutils_version="$(readValueWithDefault '2.29')"

  cat << EOI
Specify the version of Kernel headers you want to use. Note that for GCC 7.3.0
the 4.14.3 version works perfectly well. Moreover, only version 4+ is
supported : [4.14.14]
EOI

  local kernel_version="$(readValueWithDefault '4.14.14')"

  cat << EOI
Specify the make version you want to use. Note that version 4.2 is
good : [4.2]
EOI

  local make_version="$(readValueWithDefault '4.2')"

  # run the bootstrap image
  docker run --rm -it \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -e GCC_VERSION="$gcc_version" \
    -e BINUTILS_VERSION="$binutils_version" \
    -e KERNEL_VERSION="$kernel_version" \
    -e MAKE_VERSION="$make_version" \
    metabarj0/bootstrap

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'bootstrap image failed to run correctly.' \
  && return $returnCode

  cat << EOI
Bootstrapping successfully done! Would you like to remove the
metabarj0/bootstrap docker image? [Y/n]
EOI

  local remove_bootstrap="$(readValueWithDefault 'Y')"

  if [ $remove_bootstrap = 'Y' ] || [ $remove_bootstrap = 'y' ]; then
    docker rmi metabarj0/bootstrap

    returnCode=$?

    [ $returnCode -ne 0 ] \
    && fatal 'Unabled to remove the bootstrap image.' \
    return $returnCode
  fi

  debug 'bootstrap_run_image() Result'
  [ $returnCode -eq 0 ] \
  && debug 'execution succeeded' \
  || debug 'execution failed'

  return $returnCode
}

### once the system is bootstrapped, clean the staging area
bootstrap_cleanupStagingArea() {
  rm -rf "$CARRIER_TMP_DIR"/bootstrap

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'Unabled to swipe bootstrap files in staging area.'

  debug 'bootstrap_cleanupStagingArea() Result'
  [ $returnCode -eq 0 ] \
  && debug 'execution succeeded' \
  || debug 'execution failed'

  return $?
}

### run the full bootstrap procedure
bootstrap_run() {
  info 'Running the bootstrap procedure'

  bootstrap_fetchInStagingArea \
  && bootstrap_fetchLibInStagingArea \
  && bootstrap_build \
  && bootstrap_run_image \
  && bootstrap_cleanupStagingArea

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'bootstrap procedure failed at some point'

  debug 'bootstrap_run() Result'
  [ $returnCode -eq 0 ] \
  && debug 'execution succeeded' \
  || debug 'execution failed'

  return $returnCode
}
#### End of bootstrap domain specific functions

#### image domain specific functions

### checking image name or image's manifest file path.
image_checkManifestPathOrName() {
  local argument_error_message="$(
  cat << EOI
Error: Bad argument specified.
Expected is either :
- an absolute path to a manifest file of a docker image project located in the
  docker/share/images directory
- a relative path from your current directory to a manifest file of a docker
  image project located in the docker/share/images directory
- the name of the directory of the docker image project you want to build,
  located in the docker/share/images directory

Taking theses remarks into account should help you to resolve your
problem...exiting...
EOI
  )"

  # This script needs one argument: either
  #  - an absolute path to a manifest file
  #  - a relative path to a manifest file
  #  - a valid docker image name which can be found in the share/image directory
  if [ ! $# -eq 1 ]; then
    error "$argument_error_message"
    return 1
  fi

  # try to resolve the manifest file path by:
  #  - appending it to the current user directory, useful if relative path is
  #    provided
  #  - testing directly the file path, useful if absolute path is provided
  local manifest_arg="$1"
  if [ ! -f ${USER_DIRECTORY}/"$manifest_arg" ] \
     && [ ! -f "$manifest_arg" ]; then
    # not a file path, testing the image name
    manifest_arg=${CARRIER_SHARE_IMAGES_DIR}/"$1"/manifest
    if [ ! -f ${manifest_arg} ]; then
      error "$argument_error_message"
      return 1
    fi
  fi

  # OK, valid argument, exposing the manifest file absolute path
  MANIFEST_FILE_PATH=${manifest_arg}

  return 0
}

### look for the existence of foundation images on the docker host. If this
### check fails, no build is possible.
image_checkBootstrapImages() {
  # first, verify if bootstrap has built all necessary foundation images, that
  # is metabarj0/manifest, metabarj0/gcc, metabarj0/make and
  # metabarj0/docker-cli and alpine/wget
  local required_images="$(
  cat << EOI
metabarj0/manifest
metabarj0/gcc
metabarj0/make
metabarj0/docker-cli
alpine/wget
EOI
  )"

  for i in $required_images; do
    id=$(docker image ls -q $i)
    if [ -z $id ]; then
      error "$(cat << EOI
Error: the mandatory image "$i" has not been found on your docker host. Make
sure you have properly bootstrapped your docker host before attempting any
image build...exiting...
EOI
)"
      return 1
    fi
  done

  return 0
}

### check for the existence of zll dependencies of the image requested to be
### built and attempt to build them if they are not present on the docker host.
image_buildDependencies() {
  # browse all dependencies
  for dep in $REQUIRES; do
    # first, check on the host if the image exists; if so, continue without
    # building it
    local repository=$(docker image ls -q "$dep")
    if [ ! -z "$repository" ]; then
      info 'image '"$dep"' found on the docker host...continuing...'
      continue
    fi

    # no existing image found on the host, building it, the current directory
    # being the image staging directory, there must be a docker directory to
    # look into from the global docker tmp directory
    # TODO : rethink how manifest is found : source variables instead sed-ing
    #        it. Allows user to define its PROVIDES variable using any form
    #        that is valid in shell
    local dependency_manifest=$(
      find ${FETCHED_MANIFEST} \
        -name manifest \
        -exec \
          grep -EH 'PROVIDES='$dep'$' {} \; \
          | sed -E 's/^([^:]+):.+/\1/'
    )

    # transform dependency_manifest to be just the image name
    local dependency_manifest_dir=$(dirname $dependency_manifest)
    dependency_manifest=$(basename $dependency_manifest_dir)

    local this_script_name=$(basename $0)
    local this_script_path=${DOCKER_BIN_DIRECTORY}/$this_script_name

    # calling in a sub-shell, isolating shell variables from each other
    ( image_build "$dependency_manifest" )

    local returnCode=$?

    [ $returnCode -ne 0 ] \
    && error 'Failed to build image targetd by '"$dependency_manifest" \
    && return $returnCode
  done

  return 0
}

### fill the staging area with file necessary to build the image and its
### dependencies
image_fillStagingArea() {
  local image_directory=$(dirname $MANIFEST_FILE_PATH)

  # create the intermediate images directory in the staging area if it does not
  # already exist
  local staging_directory=${CARRIER_TMP_DIR}/images

  # sanitize the satging area if this is this execution is the first (no
  # recursion)
  if [ -z "$FETCHED_MANIFEST" ]; then
    info 'cleaning staging area '"$staging_directory"
    rm -rf $staging_directory
  fi

  mkdir -p $staging_directory

  # copy the project in the staging area
  cp -a $image_directory $staging_directory

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'could not copy image files to staging area...exiting...' \
  && return 1

  # copy necessary lib files in the project directory in the staging area
  local image_name=$(basename $image_directory)
  IMAGE_STAGING_DIRECTORY=${staging_directory}/$image_name

  cd $CARRIER_LIB_DIR

  cp \
    .dockerignore \
    build-image.sh \
    build.sh \
    Dockerfile.build-image \
    exportPackageTo \
    functions.sh \
    importPackageFrom \
    $IMAGE_STAGING_DIRECTORY

  returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'could not copy utility files to staging area...exiting...' \
  && return 1

  cd $USER_DIRECTORY

  return 0
}

### attempt to build the image and all of its dependencies
image_buildImageAndDependencies() {
  # source the content of the manifest file, that will initialize some useful
  # variables
  . $MANIFEST_FILE_PATH

  # build all dependencies of this project first if there are
  if [ ! -z "$REQUIRES" ]; then
    info 'fetching genuine carrier repository...'

    fetchManifestImageContent $IMAGE_STAGING_DIRECTORY
    image_buildDependencies
  fi

  # rely on some variables extracted from the manifest file that was parsed
  (
    exec \
      ${IMAGE_STAGING_DIRECTORY}/build.sh \
      $PROVIDES \
      $IMAGE_STAGING_DIRECTORY \
      "$SOURCES_FETCH_IMAGE" \
      "$SOURCES_FETCH_COMMAND" \
      "$SOURCES_TARBALL_NAME" \
      "$REQUIRES" \
      "$BUILD_EXTRA_DOCKERFILE_COMMANDS" \
      "$BASE_IMAGE" \
      "$FINAL_EXTRA_DOCKERFILE_COMMANDS"
  )

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'could not build image providing '"$PROVIDES"'...exiting...' \
  && return 1

  return 0
}

### when the build is complete, cleanup the staging area
image_cleanupStagingArea() {
  info 'cleaning up the staging area for images'

  rm -rf $IMAGE_STAGING_DIRECTORY

  if [ -z "$(ls ${CARRIER_TMP_DIR}/images)" ]; then
    rm -r ${CARRIER_TMP_DIR}/images
  fi

  return 0
}

### entrypoint for carrier image build... may be called recursively in case of
### dependency image building
### accept an image name or a manifest file path
image_build() {
  image_checkBootstrapImages \
  && image_checkManifestPathOrName "$1" \
  && image_fillStagingArea \
  && image_buildImageAndDependencies \
  && image_cleanupStagingArea

  local returnCode=$?

  debug 'image_build() Result'
  [ $returnCode -eq 0 ] \
  && debug 'execution succeeded' \
  || debug 'execution failed'

  return 0
}
#### End of image domain specific functions

#### appliance domain specific functions

### source and validate (or invalidate) the appliance's manifest file. Ensure
### all mandatory variables are set. This is not a deep validation, this
### functions only verify the exposition of a global variable.
appliance_shallowValidateManifestFile() {
  # first, source the manifest file
  . "$MANIFEST_FILE_PATH"

  # then, testing mandatory variables existence
  if [ -z "$COMPOSE_BUILD_CONTEXT" ]; then
    error "$(
    cat << EOI
The appliance's manifest file is ill formed as it lacks one mandatory variable
values.
In order to build an appliance, you must provide a value for the following
mandatory variable :

  COMPOSE_BUILD_CONTEXT

This variable maps a service's image name (in your docker-compose.yml file)
and a function name (defined in the manifest file). With these elements, the
appliance management system will be able to generate a Dockerfile for each
service of your appliance and build this image.

Taking into account this remark should help you to resolve your
problem...exiting...
EOI
    )"
    return 1
  fi

  # shallow validation complete, the appliance name is gotten, assuming all is
  # OK so far
  APPLIANCE_NAME="$(basename "$(dirname "$MANIFEST_FILE_PATH")")"

  return 0
}

### help message on how to use the appliance management system.
appliance_showUsage() {
  error "$(
  cat << EOI
Invalid arguments specified. Usage :

  manage-appliance <command> <appliance> where

<command> is either :

  build
  start
  stop

and <appliance> is either :
- an absolute path to a manifest file of an appliance
- a relative path of a manifest file of an appliance
- an appliance name

Example :

  manage-appliance start devenv_cpp

will attempt to start the devenv_cpp appliance.

Notes :
- If an appliance is asked for starting and is not built beforehand, the system
  will attempt to build it first automatically.
- Attempting to stop an appliance that is not started does nothing.
EOI
  )"

  return 0
}

### check the argument provided by the user to this script. Ensure that
### arguments are correct before going any further
appliance_checkArgument() {
  # TODO : the command should be known, no necessary to cheack here, has been
  # checked before
  COMMAND="$1"

  # verify the command specified, if invalid, returns 1
  if [ "$COMMAND" != 'build' ] \
     && [ "$COMMAND" != 'start' ] \
     && [ "$COMMAND" != 'stop' ]; then
    appliance_showUsage
    return 1
  fi

  # try to resolve the manifest file path by:
  #  - appending it to the current user directory, useful if relative path is
  #    provided
  #  - testing directly the file path, useful if absolute path is provided
  # TODO : refactor that, same mechanics for image building
  local manifest_arg="$2"
  if [ ! -f "${USER_DIRECTORY}"/"$manifest_arg" ] \
     && [ ! -f "$manifest_arg" ]; then
    # not a file path, testing the appliance name
    manifest_arg="${CARRIER_SHARE_APPLIANCES_DIR}"/"$2"/manifest
    if [ ! -f "${manifest_arg}" ]; then
      appliance_showUsage
      return 1
    fi
  fi

  # OK, valid argument, exposing the manifest file absolute path
  MANIFEST_FILE_PATH="${manifest_arg}"

  return 0
}

### put all necessary files intor the being built appliance staging directory.
appliance_fillStagingArea() {
  # TODO : take a look at filling staging area in the image build feature to
  #        see if a refacto could be done
  local appliance_directory="$(dirname "$MANIFEST_FILE_PATH")"

  # create the intermediate appliance directory in the staging area if it does
  # not already exist
  local staging_directory=${CARRIER_TMP_DIR}/appliances
  APPLIANCE_STAGING_DIRECTORY="${staging_directory}"/"$APPLIANCE_NAME"

  # sanitize the staging area if it does already exist
  rm -rf "$APPLIANCE_STAGING_DIRECTORY"
  mkdir -p "$staging_directory"
  cp -a "$appliance_directory" "$staging_directory"

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'could not copy appliance files into staging area...exiting...' \
  && return $returnCode

  # copy necessary lib files in the project directory in the staging area
  cd "$CARRIER_LIB_DIR"

  cp \
    .dockerignore \
    exportPackageTo \
    functions.sh \
    importPackageFrom \
    "$APPLIANCE_STAGING_DIRECTORY"

  returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'could not copy utility files into staging area...exiting...' \
  && return $returnCode

  cd "$USER_DIRECTORY"

  return 0
}

### fetch a copy of the master branch of the carrier directory then, copy the
### entire docker directory into the staging directory. This manifest is used
### to build various dependencies and serve as a genuine repository.
appliance_fetchManifest() {
  # use the metabarj0/manifest docker image that MUST exist
  local manifest_image="$(
    docker image ls --format='{{.Repository}}' metabarj0/manifest)"

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'could not locate metabarj0/manifest image on the docker host' \
  && return $returnCode

  if [ -z "$manifest_image" ]; then
    error "$(cat << EOI
Error: cannot find the metabarj0/manifest docker image on your docker host. This
image is built by the bootstrap process.
Possible causes are :

  - you did not bootstrap your system. See bootstrap documentation.
  - you accidentally (or not) removed or untagged the metabarj0/bootstrap docker
    image.

Taking these remarks into account should help you to resolve your
problem...exiting...
EOI
    )"
    return 1
  fi

  # call to a functions.sh's utility
  fetchManifestImageContent "$APPLIANCE_STAGING_DIRECTORY"

  returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'could not fetch genuine carrier copy' \
  && return $returnCode

  return 0
}

### build an image that is required for the appliance and that was not found on
### the docker host. Relies on the image build system.
appliance_buildDependentImage() {
  # uses the metabarj0/manifest container to build required images. It'll result
  # in the creation of a docker directory inside the appliance staging directory
  appliance_fetchManifest

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'could not fetch genuine carrier copy' \
  && return $returnCode

  local required_image_name="$1"

  # look for the manifest file providing this image, in genuine location, the
  # fetched manifest
  # TODO : same remark in build image system : source the variable value
  #        instead of sed-ing it
  local image_manifest_path="$(
    find "$FETCHED_MANIFEST" \
      -type f \
      -name manifest \
      -exec grep -EH 'PROVIDES='"$required_image_name"'$' {} \; \
      | sed -E 's/(.+):.*$/\1/')"

  if [ -z "$image_manifest_path" ]; then
    error "$( cat << EOI
Error: cannot find a suitable project to build the "$required_image_name".
Possible causes are :

  - mis-spelled required image name
  - project does not exist in the docker/share/images directory
  - project exists in your local copy of the docker/share/images directory but
    not on the distant repository that is fetched to build your dependent image
  - project is an image provided by the bootstrap process and
    your system is not bootstrapped. Such images are metabarj0/gcc,
    metabarj0/make... See bootstrap documentation for more details
  - The project exists on the distant repository and has all the necessary to be
    built BUT the 'PROVIDES' variable in the manifest file is not defined on an
    unique line (use the '\\' character after '=' for instance).

Taking these remarks into account should help you to solve you
problem...exiting
EOI
    )"

    return 1
  fi

  # I've the absolute path of the required image's manifest file, let's build it
  # in a new sub-shell
  # TODO : using carrier directly here; check if it breaks something
  ( ${CARRIER_BIN_DIR}/carrier image build "$image_manifest_path" )

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'could not build the dependent image targeted by '\
"$image_manifest_path" \
  && return $returnCode

  return 0
}

### enumerates all required images needed by the appliance and build them if
### they are not on the docker host
appliance_checkRequiredImages() {
  # manifest file read and validated, check existing images and attempt build
  # them if necessary
  local image=
  for image in $REQUIRED_IMAGES; do
    local image_name="$(
      docker image ls --format='{{.Repository}}' $image)"

    local returnCode=$?
    [ $returnCode -ne 0 ] \
    && fatal 'could not request '"$image"' on the docker host' \
    && return $returnCode

    # image does not exist on the docker host
    if [ -z "$image_name" ]; then
      appliance_buildDependentImage "$image"
    fi
  done

  return 0
}

### Generate the entire Dockerfile of an image of the appliance, relying on the
### content of the manifest file and values computed by the process of
### appliance building.
appliance_compileDockerfile() {
  # TODO refactor this function by breaking it in more atomic parts
  # create a map between image used in build stages and their alias that will be
  # used later
  local names_aliases_map="$(
    mapImageNamesAndBuildStageAliases "$REQUIRED_IMAGES"
    )"

  # create a Dockerfile in the appliance staging directory. Using required image
  # specified in the manifest as well as other variables :
  local dependencies_build_stages=
  local build_stage=
  local pair=
  local name=
  local alias=
  for pair in $names_aliases_map; do
    # extract image name and build stage alias
    name="$(keyOf "$pair")"
    alias="$(valueOf "$pair")"

    # instruction to export the dependency image package
    build_stage="$(cat << EOI
FROM $name as $alias
USER root:root
RUN exportPackageTo /tmp/package
EOI
    )"

    # group these instructions together
    dependencies_build_stages="$(
      append "$dependencies_build_stages" \
             "$build_stage" \
             $'\n'
    )"
  done

  # copy tooling to extract dependencies' packages
  local appliance_build_stage="$(cat << EOI
FROM $BASE_IMAGE as final
RUN mkdir -p /usr/local/bin/
COPY importPackageFrom /usr/local/bin
EOI
  )"

  # import each dependency image package
  local appliance_image_imports=
  local dependency_import=
  for pair in $names_aliases_map; do
    # extract build stage alias
    alias="$(valueOf "$pair")"

    # create import instruction for each dependency
    dependency_import="$(cat << EOI
COPY --from=$alias /tmp/package /tmp/
RUN importPackageFrom /tmp/package
EOI
    )"

    # aggregate them
    appliance_image_imports="$(
      append "$appliance_image_imports" \
             "$dependency_import" \
             $'\n'
    )"
  done

  # final step, create the Dockerfile and appending the
  # EXTRA_DOCKERFILE_COMMANDS
  cat << EOI > "${APPLIANCE_STAGING_DIRECTORY}"/Dockerfile
$dependencies_build_stages
$appliance_build_stage
$appliance_image_imports
RUN rm /usr/local/bin/importPackageFrom
$EXTRA_DOCKERFILE_COMMANDS
EOI

  return 0
}

### create the service's docker image on the docker host using the generated
### Dockerfile
appliance_buildServiceImage() {
  # now we have a dockerfile, we just have to use it to build the appliance
  # image, go to the build context
  cd "$APPLIANCE_STAGING_DIRECTORY"

  # build a squashed image, docker compose can't do that yet
  # then cleanup intermediate images, docker compose don't do that yet
  docker build --squash -t "$IMAGE_NAME" . \
  && docker image prune -f

  local returnCode=$?
  [ $returnCode -ne 0 ] \
  && fatal 'could not build service '"$IMAGE_NAME" \
  && return $returnCode

  cd "$USER_DIRECTORY"

  return 0
}

### cleanup the appliance staging area when the build is complete
appliance_cleanupStagingArea() {
  if [ -d "$APPLIANCE_STAGING_DIRECTORY" ]; then
    rm -rf "$APPLIANCE_STAGING_DIRECTORY"
  fi

  if [ -z "$(ls "${CARRIER_TMP_DIR}"/appliances)" ]; then
    rm -r "${CARRIER_TMP_DIR}"/appliances
  fi

  return 0
}

### source the specified function, exposing glabal variables useful to build a
### service image.
### $1 : function name
appliance_callBuildContextFunction() {
  # execute the function
  "$1"

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'the build context function '"$1"' returned in error' \
  && return $returnCode

  # verify the presence of a mandatory variable, that must be defined by the
  # function execution
  if [ -z "$BASE_IMAGE" ]; then
    error "$(cat << EOI
Error: the BASE_IMAGE variable is not set.
This variable is mandatory to build your service image as it is the name of the
base image.

This variable must be exposed in the body of your build context function inside
the manifest file of your appliance.

Note that this variable must be global as a local variable has no definition
outside its function scope.

Taking this remark into account should help you to resolve your
problem...exiting...
EOI
    )"
    return 1
  fi

  return 0
}

### unset global variables exposed by one of the manifest's function call
appliance_unsetBuildContextVariables() {
  unset IMAGE_NAME
  unset BASE_IMAGE
  unset REQUIRED_IMAGES
  unset EXTRA_DOCKERFILE_COMMANDS

  return 0
}

### this function will build each and every image that are needed to build each
### service of the appliance. It relies on the content of the manifest file
### that has been source and roughly validated
appliance_buildServiceImages() {
  # a common part of an error message
  local part_error_message="$(cat << EOI
Make sure that the COMPOSE_BUILD_CONTEXT variable is defined like following :

  COMPOSE_BUILD_CONTEXT="image_name1 function_name1
image_name2 function_name2
image_name3 function_name3" and so on...

Taking this remark into account should help you to resolve your
problem...exiting
EOI
)"

  # iterate through each pair of image name/function to build
  local pair_element=
  local function_name=
  for pair_element in $COMPOSE_BUILD_CONTEXT; do
    # extract pair's elements
    if [ -z "$IMAGE_NAME" ]; then
      # first, verify current pair_element
      if [ -z "$pair_element" ]; then
        error "$(cat << EOI
Error: Cannot read the image name in the definition of COMPOSE_BUILD_CONTEXT in
your appliance manifest file.
$part_error_message
EOI
        )"
        return 1
      fi

      # extracting the image name
      IMAGE_NAME="$pair_element"

      # loop at once to get the function name
      continue
    else
      # image name is set, assuming we are reading a function name but first,
      # make a check
      if [ -z "$pair_element" ]; then
        error "$(cat << EOI
Error: Cannot read the function name in the definition of COMPOSE_BUILD_CONTEXT
in your appliance manifest file.
$part_error_message
EOI
        )"
        return 1
      fi

      # extracting the function name
      function_name="$pair_element"
    fi

    # image already exists, nothing to do
    local repository_id="$(docker image ls -q "$IMAGE_NAME")"

    local returnCode=$?

    [ $returnCode -ne 0 ] \
    && fatal 'could not query '"$IMAGE_NAME"' on the docker host' \
    && return $returnCode

    if [ ! -z "$repository_id" ]; then
      # some global variable have been set, rollback context
      IMAGE_NAME=
      function_name=
      continue
    fi

    # validate and run the function, exposing global variables to build the
    # image
    # then, check if requested docker images are built. If not, the system will
    # attempt to build them.
    # then, generate the dockerfile to build the appliance docker image
    # then, build the image
    # finally unset all global variables set by the build context function call
    appliance_callBuildContextFunction "$function_name" \
    && appliance_checkRequiredImages \
    && appliance_compileDockerfile \
    && appliance_buildServiceImage \
    && appliance_unsetBuildContextVariables

    returnCode=$?

    [ $returnCode -ne 0 ] \
    && error 'Appliance service image build failed at some point' \
    && return $returnCode

    # resetting the function name, for one more iteration
    function_name=
  done

  return 0
}

### entrypoint of the build command. In finality, create the appliance's docker
### image on the docker host.
appliance_build() {
  appliance_fillStagingArea \
  && appliance_buildServiceImages \
  && appliance_cleanupStagingArea

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'Appliance build failed at some point' \
  && return $returnCode

  return 0
}

### entrypoint of the start command. If the appliance requested to start has
### not been built yet, the system will attempt to build it first.
appliance_start() {
  # if some image are not yet built, build them
  appliance_build \
  && appliance_fillStagingArea

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'error when preparing appliance to start' \
  && return $returnCode

  cd "$APPLIANCE_STAGING_DIRECTORY"

  # crafting the docker-compose command, inhibiting image creation that is
  # handled by this script and forcing container recreation, containers being
  # ephemeral
  local command='docker-compose up --no-build -d'

  # execute the docker-compose command
  eval "$command"

  returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'could not start up the appliance. command was '"$command" \
  return $returnCode

  cd "$USER_DIRECTORY"

  appliance_cleanupStagingArea

  returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'could not cleanup the staging area after appliance start' \
  && return $returnCode

  info 'Appliance '"$APPLIANCE_NAME"' successfully started.'

  return 0
}

### entrypoint for the stop command. If the appliance is running, stops it.
appliance_stop() {
  appliance_fillStagingArea

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'error when preparing appliance to stop' \
  && return $returnCode

  cd "$APPLIANCE_STAGING_DIRECTORY"

  # crafting the docker-compose command, removing ephemeral containers
  local command='docker-compose rm -sf'

  # execute the docker-compose command
  eval "$command"

  [ $returnCode -ne 0 ] \
  && fatal 'could not stop the appliance. command was '"$command" \
  return $returnCode

  cd "$USER_DIRECTORY"

  appliance_cleanupStagingArea

  [ $returnCode -ne 0 ] \
  && error 'could not cleanup the staging area after appliance stop' \
  && return $returnCode

  info 'Appliance '"$APPLIANCE_NAME"' successfully stopped.'

  return 0
}

### generic function executing the right function depending on the command
### provided. The name of the function to call is built appending the command
### name and 'Appliance'
appliance_executeRequestedCommand() {
  # build the function name according to the provided command
  local function_name=appliance_${COMMAND}

  # make sure the manifest file is well formed and contains mandatory stuff
  appliance_shallowValidateManifestFile

  local returnCode=$?

  [ $returnCode -ne 0 ] \
    && error 'Could not validate the manifest file of the appliance' \
    return $returnCode

  # simply call the function
  $function_name

  returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'Could not execute the requested appliance command' \
  && return $returnCode

  return 0
}

### main entrypoint to manage appliances (build, start, stop, )
appliance_manage() {
  appliance_checkArgument "$1" "$2" \
  && appliance_executeRequestedCommand

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'Appliance command execution failed at some point' \
  && return $returnCode

  return 0
}

#### End of appliance domain specific functions

### entry point
run() {
  info 'starting carrier execution'

  executeWithTraceIfRequested

  info "building arguments referential, initializing execution context and
building the final execution context from provided arguments"

  buildArgumentsReferential \
  && initializeExecutionContext \
  && buildExecutionContextFromArguments "$@"

  local returnCode=$?

  if [ "$returnCode" -ne 0 ]; then
    error 'Failed to initialize carrier'
    return 1
  else
    executeWithContext

    returnCode=$?

    if [ "$returnCode" -ne 0 ]; then
      usage
      return 1
    fi
  fi

  return 0
}

#### The script starts here once the standalone mode has passed
run "$@"
