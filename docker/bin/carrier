#!/bin/sh

#### standalone mode, external utility functions not loaded yet ################
set -e

### set up paths after calling this script
initializePaths() {
  # get the full path of the called script
  cd $(dirname "$0")
  CALLED_SCRIPT="$(pwd -P)"/"$(basename "$0")"
  cd - 1>/dev/null 2>&1

  # if it is a symlink, resolve it, keeping the link path
  if [ -L "$CALLED_SCRIPT" ]; then
    INSTALLED_LINK_PATH="$CALLED_SCRIPT"
    CARRIER_SCRIPT_PATH="$(readlink -f "$CALLED_SCRIPT")"
  else
    CARRIER_SCRIPT_PATH="$CALLED_SCRIPT"
  fi

  # if the carrier script has been renammed, not supported => error
  if [ ! "$(basename "$CARRIER_SCRIPT_PATH")" = 'carrier' ]; then
    echo '`carrier` script has been renammed, not supported...exiting' 1>&2
    return 1
  fi

  # this directory exists and its path is absolute, verifying its name though
  CARRIER_BIN_DIR="$(dirname "$CARRIER_SCRIPT_PATH")"

  if [ ! "$(basename "$CARRIER_BIN_DIR")" = 'bin' ]; then
    cat << EOI 1>&2
The \`carrier\` script must reside in the \`bin/\` directory.
Not supported...exiting...
EOI
  return 1
  fi

  # set up each carrier directories and verify them
  local relative_carrier_root_dir="$CARRIER_BIN_DIR"/..
  local relative_carrier_lib_dir="$relative_carrier_root_dir"/lib
  local relative_carrier_share_dir="$relative_carrier_root_dir"/share
  local relative_carrier_share_bootstrap_dir=\
"$relative_carrier_share_dir"/bootstrap
  local relative_carrier_share_images_dir="$relative_carrier_share_dir"/images
  local relative_carrier_share_appliances_dir=\
"$relative_carrier_share_dir"/appliances
  local relative_carrier_src_dir="$relative_carrier_root_dir"/src

  if [ ! -d "$relative_carrier_lib_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_lib_dir does not exist. Your \`carrier\` package seems
broken or corrupted. Not supported...exiting...
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_dir does not exist. Your \`carrier\` package
seems broken or corrupted. Not supported...exiting...
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_bootstrap_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_bootstrap_dir does not exist. Your \`carrier\`
package seems broken or corrupted. Not supported...exiting...
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_images_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_images_dir does not exist. Your \`carrier\`
package seems broken or corrupted. Not supported...exiting...
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_appliances_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_appliances_dir does not exist. Your \`carrier\`
package seems broken or corrupted. Not supported...exiting...
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_src_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_src_dir does not exist. Your \`carrier\` package seems
broken or corrupted. Not supported...exiting...
EOI
  return 1
  fi

  cd $relative_carrier_root_dir
  CARRIER_ROOT_DIR="$(pwd -P)"
  cd - 1>/dev/null 2>&1

  CARRIER_LIB_DIR="$CARRIER_ROOT_DIR"/lib
  CARRIER_SHARE_DIR="$CARRIER_ROOT_DIR"/share
  CARRIER_SHARE_BOOTSTRAP_DIR="$CARRIER_SHARE_DIR"/bootstrap
  CARRIER_SHARE_IMAGES_DIR="$CARRIER_SHARE_DIR"/images
  CARRIER_SHARE_APPLIANCES_DIR="$CARRIER_SHARE_DIR"/appliances
  CARRIER_SRC_DIR="$CARRIER_ROOT_DIR"/src
}

### load utilities located in $CARRIER_LIB_DIR/functions.sh
loadUtilities() {
  local functions_sh_path="$CARRIER_LIB_DIR"/functions.sh

  if [ ! -f "$functions_sh_path" ]; then
    cat << EOI 1>&2
Fatal: $CARRIER_LIB_DIR/functions.sh does not exist. Your \`carrier\` package
seems broken or corrupted. not supported...existing...
EOI
    return 1
  fi

  # source stuff!
  . "$functions_sh_path"
}

initializePaths
loadUtilities

# log function wired, fail on error is not necessary anymore
set +e
#### end of standalone mode, external utility functions loaded #################

### basic usage function, shows syntax, how to use, purpose and so on...
usage() {
  cat << EOI
Usage:
  carrier [global options] \\
          [[domain] [domain options] command [command options]] | \\
          command [command options]

Use:

  carrier help --full to get a full usage description
EOI
}

### internal that remove unnecessary information from global options referential
### specified in argument
removeIrrelevantDetailsFromReferentialOption() {
  local referential="$1"

  echo "$referential"\
  | sed -E '/^--$/d' \
  | sed -E '/contextSet.+/d'
}

### Get a full help on usage
usageFull() {
  cat << EOI
$(usage)

Global options:
$(removeIrrelevantDetailsFromReferentialOption "$GLOBAL_OPTIONS_REFERENTIAL")

Global commands:
$(removeIrrelevantDetailsFromReferentialOption "$GLOBAL_COMMANDS_REFERENTIAL")

Help command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL")

Info command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL")

Install command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_INSTALL_OPTIONS_REFERENTIAL")

Pack command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_PACK_OPTIONS_REFERENTIAL")

Unpack command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_UNPACK_OPTIONS_REFERENTIAL")

Vagrant command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_VAGRANT_OPTIONS_REFERENTIAL")

Domains:
$(removeIrrelevantDetailsFromReferentialOption "$DOMAINS_REFERENTIAL")

Bootstrap domain commands:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_BOOTSTRAP_COMMANDS_REFERENTIAL")

Bootstrap run command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTIONS_REFERENTIAL")

Bootstrap check command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS_REFERENTIAL")

Image domain commands:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMANDS_REFERENTIAL")

Image build command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_BUILD_OPTIONS_REFERENTIAL")

Image list command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_LIST_OPTIONS_REFERENTIAL")

Image check command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_CHECK_OPTIONS_REFERENTIAL")

Image info command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_INFO_OPTIONS_REFERENTIAL")

Image upgrade command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL")

Appliance domain commands:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMANDS_REFERENTIAL")

Appliance build command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTIONS_REFERENTIAL")

Appliance list command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_LIST_OPTIONS_REFERENTIAL")

Appliance check command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTIONS_REFERENTIAL")

Appliance info command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_INFO_OPTIONS_REFERENTIAL")

Appliance start command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_START_OPTIONS_REFERENTIAL")

Appliance stop command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_STOP_OPTIONS_REFERENTIAL")

Appliance volumes command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTIONS_REFERENTIAL")

Appliance upgrade command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL")
EOI
}

### built the argument referential, sort of description and constraints about
### each valid argument.
### each line of a variable definition define a pattern one arg can match at a
### time :
###
### line 0: optional comment lines starting with #
### line 1: pattern for argument
### line 2: pattern for argument value or --
### line 3: function name initializing execution context
buildArgumentsReferential() {
  GLOBAL_OPTIONS_REFERENTIAL="$(cat << EOI
# desired log level. Defaulted to '2' or 'error'.
# i.e. carrier info --log-level=error
#      carrier info -l 2
(-l|--log-level)=?
1|2|3|4|5|6|fatal|error|warning|info|debug|trace
contextSetLogLevel

# desired output for logs. Defaulted to '&2' that is stderr
# i.e. carrier info --log-output=error.log
#      carrier info -o '&2'
(-o|--log-output)=?
.+
contextSetLogOutput
EOI
  )"

  GLOBAL_COMMANDS_REFERENTIAL="$(cat << EOI
# domainless commands. only valid when not any domain is specified.
#
# help: provides help about carrier usage
#       i.e. carrier help
#
# info: Provides general information about carrier
#       i.e. carrier info
#
# install: Install carrier to the specified location. Installation is a simple
#          process consisting in creating a symbolic link to the specified
#          location. If carrier is already installed somewhere or a symlink exist
#          with the specified name, the process fails by default.
#          Note: If a file (not a symlink) exists at the specified location the
#          process will always fails even if forced.
#          If a symlink exists and points on something existing other than a
#          carrier installation, the process will always fails to preserve
#          system integrity.
#
# pack: Packs carrier into a single executable file, easying its transportation
#       and allowing it to be used on network-isolated systems (using specific
#       command options). By default, all the directory architecture of carrier
#       is packed, including necessary resources to bootstrap your system. Thus,
#       an internet connection is required to pack carrier.
#       Moreover, user file ~/.carrier will also be included. The resulting file
#       will be a shell script containing shell code and base64 encoded tar
#       archive. As a result, modern tar and base64 implementations are
#       necessary to use the pack command efficiently
#       i.e. carrier pack
#
# unpack: unpack a packed version of carrier, creating the original directory
#         structure of carrier. If you downloaded image sources in the packed
#         carrier, you can choose to keep them (this is not the default behavior
#         though). The .carrier file is extracted to the user directory.
#
# vagrant: manipulate the vagrant environment of carrier. Each command and
#          option you specify are directly forwarded to the vagrant program. If
#          vagrant is not found, the process fails.
help|info|install|pack|unpack|vagrant
--
contextSetCommand
EOI
  )"

  GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL="$(cat << EOI
# options for the domainless help command. Turn on exhaustive help
# i.e. carrier help -H
#      carrier help --full
-H|--full
--
contextSetHelpMode
EOI
  )"

  GLOBAL_COMMAND_INFO_OPTIONS_REFERENTIAL="$(cat << EOI
# specify the output format:
# - shell: give a a list of pairs of the form VAR=VAL
# - json: create a json object containing requested properties
(-f|--format)=?
shell|json
contextSetInfoFormat
EOI
  )"

  GLOBAL_COMMAND_INSTALL_OPTIONS_REFERENTIAL="$(cat << EOI
# Force the installation of carrier to the path specified even if a previous
# installation has been detected. If a reinstallation occurs, remove the
# previous one. Even if this flag is set, installation may fail if destination
# already exists and does not correspond to a previous carrier installation
-f|--force
--
contextSetInstallForce

# If reinstallation occurs, keep the existing one.
# i.e carrier install --force --keep-previous-installation
-k|--keep-previous-installation
--
contextSetInstallKeep
EOI
  )"

  GLOBAL_COMMAND_PACK_OPTIONS_REFERENTIAL="$(cat << EOI
# While packing, fetch all supported image sources from the internet and embbed
# them in the package. Beware as the package could grow arbitrarily large. Using
# this option is interesting if you want to use carrier on a network isolated
# system. This is not the default behavior of packing.
# i.e carrier pack --fetch-all-images-sources
-s|--fetch-all-images-sources
--
contextSetPackFetchAll

# Instead of packing carrier, only fetch sources of images. This option can be
# specified with -s and -i. This is not the default behavior of packing.
-o|--only-fetch-sources
--
contextSetPackFetchOnly

# While packing, fetch sources of specified images only. Sources of unspecified
# images will not be fetched, leading to a less heavy package but forcing one to
# grab source from the internet if an attempt to build an image that does not
# have its source stored locally is made. This is not the default behavior of
# packing.
# i.e carrier pack -i metabarj0/wget,metabarj0/llvm
(-i|--fetch-images-sources)=?
[^,]+(,[^,]+)*
contextSetPackSpecificImageFetch
EOI
  )"

  GLOBAL_COMMAND_UNPACK_OPTIONS_REFERENTIAL="$(cat << EOI
# While unpaking, do not delete fetch sources. This is not the default behavior
-k|--keep-sources-if-any
--
contextSetUnpackKeepSources
EOI
  )"

  GLOBAL_COMMAND_VAGRANT_OPTIONS_REFERENTIAL="$(cat << EOI
# Specify where to find the vagrant program. Defaulted to vagrant, therefore,
# vagrant is supposed to be found in the PATH environment variable.
(-p|--vagrant-path)=?
.+
contextSetVagrantPath

# commands/arguments/options to forward to the vagrant program. Must be enclosed
# by quotes to be parsed as a single argument in the carrier point of view.
'.+'
--
contextSetVagrantArguments
EOI
  )"

  DOMAINS_REFERENTIAL="$(cat << EOI
# specific domain of application for carrier. A domain is the highest level
# context carrier acts on.
#
# bootstrap: the bootstrap context can be used with bootstrap specific commands
#            and options. Allows one to deal with all the bootstrapping stuff.
#
# image: the image context is related to docker image manipulation and provides
#        image specific commands and options.
#
# appliance: the appliance domain deals with appliance manipulation and provides
#            appliance specific commands and options.
bootstrap|image|appliance
--
contextSetDomain
EOI
  )"

  DOMAIN_BOOTSTRAP_COMMANDS_REFERENTIAL="$(cat << EOI
# available commands in the bootstrap domain
# - check verify the current environment is correctly bootstrap
# - run bootstrap the system
check|run
--
contextSetCommand
EOI
  )"

  DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS_REFERENTIAL="$(cat << EOI
# no options yet
EOI
  )"

  DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTIONS_REFERENTIAL="$(cat << EOI
# specifying this option for a bootstrap run command allows to keep existing
# images produced by a previous bootstrap run. Images will be tagged with the
# current data and time using the '+%Y%m%d%H%M%S' format usable with the date
# command.
-t|--retag-existing-images
--
contextSetBootstrapRunRetag
EOI
  )"

  DOMAIN_IMAGE_COMMANDS_REFERENTIAL="$(cat << EOI
# available commands for the image domain.
# - build can build one or more images
# - list can list images on the system, reporting information about the
#   availability of images
# - check verifies one or more images are healthy and up to date
# - info report about internal informations about an image
# - upgrade can upgrade one or more image regarding their dependencies status
build|list|check|info|upgrade
--
contextSetCommand
EOI
  )"

  DOMAIN_IMAGE_COMMAND_BUILD_OPTIONS_REFERENTIAL="$(cat << EOI
# specifying this option while building an image prevent the system to tag a
# previous version existing on the docker host. As a result, if a previous
# version of the image being built were present; it is deleted instead of being
# retagged. This is not the default behavior.
-r|--remove-existing-images
--
contextSetImageBuildRemoveExisting

# sequence (or unique) image to be built. The sequence can be made of :
# - image name (the directory name containing image files)
# - relative path of the image manifest file
# - absolute path of the image manifest file
# - a mix of all three
[^,]+(,[^,]+)?
--
contextSetImageBuildImageSequence
EOI
  )"

  DOMAIN_IMAGE_COMMAND_LIST_OPTIONS_REFERENTIAL="$(cat << EOI
# list all images, built, not built, local and remote
-a|--all
--
contextSetImageListAll

# list only built images
-b|--only-built
--
contextSetImageListOnlyBuilt

# list only not built images
-n|--only-not-built
--
contextSetImageListOnlyNotBuilt

# list only local images that are not present on remote repository (new images
# being created for instance)
-l|--only-local
--
contextSetImageListOnlyLocal

# list only supported images that are present on the remote repository.
-r|--only-remote
--
contextSetImageListOnlyRemote

# specify the output format:
# - one-line outputs the result in one line, each image name being separated by
#   a space character and formated as following:
#   image1:flags,image2:flags,...
#   flags being:
#   - b for built
#   - n for not built
#   - l for local
#   - r for remote
# Note that local and remote are not exclusive though it is unlikely to have an
# image flagged as remote that is not present on your local system (unless you
# deliberatly removed it)
# - pretty outputs a very nice table (default)
# - docker relies on the docker client to output the result. You can specify
# docker specific format information appending
# \`:'docker format args for docker images'\`
# The docker format works only for built images
(-f|--format)=?
one-line|pretty|docker(:'.*')?
contextSetImageListFormat
EOI
  )"

  DOMAIN_IMAGE_COMMAND_CHECK_OPTIONS_REFERENTIAL="$(cat << EOI
# checks all built image by checking their dependencies integrity. If an image
# name is output, it means that something is wrong with the dependency chain.
# Image name is output if:
# - a dependency is newer than the image, meaning the image may need to be
#   rebuilt
# - a dependency is missing meaning the image may not be up to date
# - the /image.dist file of the image is missing or corrupted, meaning something
#   went wrong when image has been built.
# checking all images is the default behavior
-a|--all-installed
--
contextSetImageCheckAllBuilt

# ignore the build date of dependecies when checking images
-d|--ignore-date
--
contextSetImageCheckIgnoreDate

# ignore if dependency is missing on the docker host when checking images
-m|--ignore-missing
--
contextSetImageCheckIgnoreMissing

# ignore detected defect in image checking (not recommended)
-i|--ignore-image-dist-defects
--
contextSetImageCheckIgnoreDependencyDefects

# format the output if something is found:
# - list gives a list of the form:
#   image:issue1,issue2...
# - pretty ouput a nice table (default)
(-f|--format)=?
list|pretty
contextSetImageCheckFormat

# explicit image list to cheack instead of all
(-l|--image-list)=?
[^,]+(,[^,]+)*
contextSetImageCheckImageSequence
EOI
  )"

  DOMAIN_IMAGE_COMMAND_INFO_OPTIONS_REFERENTIAL="$(cat << EOI
# report all properties of requested image (default behavior)
-a|--report-all
--
contextSetImageInfoAllProps

# only report the image.dist content
-i|--report-image-content
--
contextSetImageInfoOnlyContent

# only report the docker image name provided
-p|--report-provides
--
contextSetImageInfoOnlyProvides

# only report dependency image names
-r|--report-requires
--
contextSetImageInfoOnlyRequires

# report the name of the base image
-b|--report-base-image
--
contextSetImageInfoOnlyBaseImage

# report the name of the image used to fetch sources
-d|--report-sources-fetch-image
--
contextSetImageInfoOnlyFetchImage

# report the command used to fetch sources
-s|--report-sources-fetch-command
--
contextSetImageInfoOnlyFetchCommand

# report the name of the sources tarball
-c|--report-sources-tarball-name
--
contextSetImageInfoOnlyTarballName

# report extra dockerfile commands appended to the generated Dockerfile for the
# image building process
-x|--report-build-extra-dockerfile-commands
--
contextSetImageInfoOnlyBuildExtraDockerfileCommands

# report extra dockerfile commands used to build the final image
-z|--report-final-extra-dockerfile-commands
--
contextSetImageInfoOnlyFinalExtraDockerfileCommands

# specify the output format:
# - shell: give a a list of pairs of the form VAR=VAL
# - json: create a json object containing requested properties
(-f|--format)=?
shell|json
contextSetImageInfoFormat

# the image to observe
.+
--
contextSetImageInfoImage
EOI
  )"

  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL="$(cat << EOI
# attempt an upgrade of all built images by checking their dependencies
# integrity and status. If one or more dependencies have a problem or is newer
# than the observed image, both actions are taken:
# - dependencies is corrupted: report the issue and does nothing else
# - a dependency is newer than the image : the observed image is rebuilt
# - a dependency is missing : report and does nothing else
# this is the default behavior
-a|--all-installed
--
contextSetImageUpgradeAll

# ignore the date of dependencies of the observed image. Note that ignore date
# in using the upgrade command will always inhibit the image rebuild.
-d|--ignore-date
--
contextSetImageUpgradeIgnoreDate

# does not report missing dependency
-m|--ignore-missing
--
contextSetImageUpgradeIgnoreMissing

# does not report a defect problem in a dependency image
-i|--ignore-image-dist-defects
--
contextSetImageUpgradeIgnoreDependencyDefects

# specify an image list instead of attempting to upgrade them all. list has the
# form :
# image1,image2...
(-l|--image-list)=?
[^,]+(,[^,]+)*
contextSetImageUpgradeImageSequence
EOI
  )"

  DOMAIN_APPLIANCE_COMMANDS_REFERENTIAL="$(cat << EOI
# available commands for the appliance domain.
# - build can build one or more appliances.
# - list can list appliances on the system, reporting information about the
#   availability of appliances
# - check verifies one or more appliances are healthy and up to date
# - info report about internal informations about an appliance
# - upgrade can upgrade one or more appliances regarding their service image and
#   dependencies status
# - start can start an appliance or several
# - stop can stop one or more appliances
# - volumes can help the user to manage columes used by an appliance
build|list|check|info|upgrade|start|stop|volumes
--
contextSetCommand
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTIONS_REFERENTIAL="$(cat << EOI
# When building an appliance, remove all appliance service images that already
# exist on the docker host. This is not the default behavior as by default, if
# images exist, nothing is built
-r|--remove-existing-images
--
contextSetApplianceBuildRemoveExisting

# When building an appliance, tag all existing service image using the
# '+%Y%m%d%H%M%S' format usable with the date command. This is not the default
# behavior as by default, if images exist, nothing is built
-t|--tag-existing-images
--
contextSetApplianceBuildTagExisting

# the appliance list to build. Has the form:
# appliance1,appliance2...
[^,]+(,[^,]+)?
--
contextSetApplianceBuildApplianceSequence
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_LIST_OPTIONS_REFERENTIAL="$(cat << EOI
# list all appliances, built, not built, local and remote
-a|--all
--
contextSetApplianceListAll

# list only built appliances
-b|--only-built
--
contextSetApplianceListOnlyBuilt

# list only not built appliances
-n|--only-not-built
--
contextSetApplianceListOnlyNotBuilt

# list only local appliances that are not present on remote repository (new
# appliances being created for instance)
-l|--only-local
--
contextSetApplianceListOnlyLocal

# list only supported appliances that are present on the remote repository.
-r|--only-remote
--
contextSetApplianceListOnlyRemote

# specify the output format:
# - one-line outputs the result in one line, each appliance name being separated
#   by a space character and formated as following:
#   appliance1:flags,appliance2:flags,...
#   flags being:
#   - b for built
#   - n for not built
#   - l for local
#   - r for remote
# Note that local and remote are not exclusive though it is unlikely to have an
# appliance flagged as remote that is not present on your local system (unless you
# deliberatly removed it)
# - pretty outputs a very nice table (default)
(-f|--format)=?
one-line|pretty
contextSetApplianceListFormat
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTIONS_REFERENTIAL="$(cat << EOI
# verify all built appliances by checking each of its service image. (default
# behavior)
-a|--all-installed
--
contextSetApplianceCheckAll

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are more up to date than the
# service image, it is ignored and the service image will be considered ok
-d|--ignore-date
--
contextSetApplianceCheckIgnoreDate

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are missing on the docker host
# it is ignored and the service image will be considered ok
-m|--ignore-missing
--
contextSetApplianceCheckIgnoreMissing

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies have something wrong in their
# image.dist file, it is ignored and the service image will be considered ok
# (this is not recommended)
-i|--ignore-image-dist-defects
--
contextSetApplianceCheckIgnoreDependencyDefects

# explicit list of appliance to check. The list has the form:
# appliance1,appliance2...
(-l|--appliance-list)=?
[^,]+(,[^,]+)*
contextSetApplianceCheckApplianceList
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_INFO_OPTIONS_REFERENTIAL="$(cat << EOI
# report all information properties of the appliance (default behavior)
-a|--report-all
--
contextSetApplianceInfoAllProps

# report only the base image used for the observed service image
-b|--report-base-image
--
contextSetApplianceInfoOnlyBase

# execute a docker-compose config on the appliance docker-compose.yml file
-c|--report-config
--
contextSetApplianceInfoOnlyConfig

# reports only dependent images required for the service being observed
-r|--report-requires
--
contextSetApplianceInfoOnlyRequires

# report only extra Dockerfile commands used in the observed service image
-x|--report-extra-dockerfile-commands
--
contextSetApplianceInfoOnlyExtraDockerfileCommands

# inspect all services of the appliance (default behavior)
-s|--all-services
--
contextSetApplianceInfoAllServices

# specify a list of service to observe. List has the form:
# service1,service2...
(-s|--service)=?
[^,]+(,[^,])*
contextSetApplianceInfoServiceSequence

# output format of the report
# shell is a list of pairs of the form key=value (default)
# json output the result in a json object
(-f|--format)=?
shell|json
contextSetApplianceInfoFormat

# the appliance to get info from
.+
--
contextSetApplianceInfoAppliance
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_START_OPTIONS_REFERENTIAL="$(cat << EOI
# if appliances requested to start does not exist, attempt to build it
# beforehand using default options. Default behavior
-b|--build
--
contextSetApplianceStartBuild

# do not attempt to build appliance service image if they are missing. If one
# or more service images are missing this command will fail(not default behavior)
-n|--dont-build
--
contextSetApplianceStartDontBuild

# list of appliance to start. List has the form:
# appliance1,appliance2...
[^,]+(,[^,]+)*
--
contextSetApplianceStartApplianceSequence
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_STOP_OPTIONS_REFERENTIAL="$(cat << EOI
# when stopping an appliance, also remove created containers. Containers are
# considered ephemeral by design so it is the default behavior
-d|--rm
--
contextSetApplianceStopRemoveContainers

# do not delete appliance container when stopping. This is not the default
# behavior
-k|--keep-containers
--
contextSetApplianceStopKeepContainers

# list of appliance to stop. List has the form:
# appliance1,appliance2...
[^,]+(,[^,]+)*
--
contextSetApplianceStopApplianceSequence
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTIONS_REFERENTIAL="$(cat << EOI
# list the appliance volumes
-l|--list
--
contextSetApplianceVolumesList

# remove all the appliance volumes
-r|--rm
--
contextSetApplianceVolumesRemove

# dump specified volumes
-d|--dump
--
contextSetApplianceVolumesDump

# specify the dump file path (defaulted to current directory)
(-p|--dump-file-path)=?
.+
contextSetApplianceVolumesDumpPath

# specific list of volume. used with --rm and --dump options
(-v|--volume-list)=?
[^,]+(,[^,]+)*
contextSetApplianceVolumesList

# targeted appliance
(-a|--appliance)=?
.+
contextSetApplianceVolumesAppliance
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL="$(cat << EOI
# scan all built appliances
-a|--all-installed
--
contextSetApplianceUpgradeAll

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are more up to date than the
# service image, it is ignored and the service image will be considered up to
# date
-d|--ignore-date
--
contextSetApplianceUpgradeIgnoreDate

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are missing on the docker host
# it is ignored and the service image will be considered up to date
-m|--ignore-missing
--
contextSetApplianceUpgradeIgnoreMissing

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies have something wrong in their
# image.dist file, it is ignored and the service image will be considered up to
# date (this is not recommended)
-i|--ignore-image-dist-defects
--
contextSetApplianceUpgradeIgnoreDependencyDefects

# explicit list of appliance to check. The list has the form:
# appliance1,appliance2...
(-l|--appliance-list)=?
[^,]+(,[^,]+)*
contextSetApplianceUpgradeApplianceSequence
EOI
  )"
}

### initialize the execution context of carrier, dictating what to do with
### provided arguments
initializeExecutionContext() {
  # carrier --log-level=2 ...
  GLOBAL_OPTION_LOG_LEVEL=2
  GLOBAL_OPTION_LOG_OUTPUT='&2'

  # carrier help
  COMMAND='help'

  # carrier help -H
  GLOBAL_COMMAND_HELP_OPTION_MODE=

  # carrier info --format=shell
  GLOBAL_COMMAND_INFO_OPTION_FORMAT='shell'

  # carrier install --force -k
  GLOBAL_COMMAND_INSTALL_OPTION_FORCE='no'
  GLOBAL_COMMAND_INSTALL_OPTION_KEEP='no'

  # carrier pack -s
  GLOBAL_COMMAND_PACK_OPTION_FETCH_ALL_SOURCES='no'
  GLOBAL_COMMAND_PACK_OPTION_ONLY_FETCH_SOURCES='no'
  GLOBAL_COMMAND_PACK_OPTION_FETCH_SPECIFIC_IMAGE_SOURCES=

  # carrier unpack -k
  GLOBAL_COMMAND_UNPACK_OPTION_KEEP_SOURCES='no'

  # carrier vagrant -p '/usr/local/bin/vagrant' up
  GLOBAL_COMMAND_VAGRANT_OPTION_PATH='vagrant'
  GLOBAL_COMMAND_VAGRANT_OPTION_ARGUMENTS=

  # bootstrap or image or appliance
  DOMAIN=

  # not used yet
  DOMAIN_OPTIONS=

  # not used yet
  DOMAIN_BOOTSTRAP_OPTIONS=
  DOMAIN_IMAGE_OPTIONS=
  DOMAIN_APPLIANCE_OPTIONS=

  # carrier bootstrap check
  DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS=

  # carrier bootstrap run --retag-existing-images
  DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTION_RETAG_EXISTING='no'

  # carrier image build -r metabarj0/wget
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_REMOVE_EXISTING='no'
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE=

  # carrier image list -b --format json
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ALL='yes'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_BUILT='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_NOT_BUILT='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_LOCAL='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_REMOTE='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_FORMAT='pretty'

  # carrier image check --all --ignore-missing
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_ALL_IMAGES='yes'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DATE='no'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_MISSING='no'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_FORMAT='pretty'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IMAGE_SEQUENCE=

  # carrier image info --report-base-image -f shell
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ALL='yes'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_CONTENT='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_PROVIDES='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_REQUIRES='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_BASE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_IMAGE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_COMMAND='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_TARBALL_NAME='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_BUILD_DOCKERFILE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_FINAL_DOCKERFILE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_FORMAT='shell'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_IMAGE=

  # docker carrier image upgrade metabarj0/git,metabarj0/gdb
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_ALL='yes'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DATE='no'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING='no'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IMAGE_SEQUENCE=

  # carrier appliance build devenv_cpp -r
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_REMOVE_EXISTING='no'
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_TAG_EXISTING='no'
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_LIST=

  # carrier appliance list --only-remote -f one-line
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_BUILT='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_NOT_BUILT='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_LOCAL='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_REMOTE='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_FORMAT='pretty'

  # carrier appliance check devenv_cpp
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DATE='no'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_MISSING='no'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_APPLIANCE_LIST='no'

  # carrier appliance info --report-config
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_REPORT_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_BASE='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_CONFIG='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_REQUIRES='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_EXTRA_DOCKERFILE='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_ALL_SERVICES='yes'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_SERVICE_LIST=
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_FORMAT='shell'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_APPLIANCE=

  # carrier appliance start devenv_cpp -n
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_BUILD='yes'
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE=

  # carrier appliance stop  --keep-containers devenv_cpp
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_REMOVE_CONTAINERS='yes'
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE=

  # carrier appliance volumes devenv_cpp
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_LIST='yes'
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_REMOVE='no'
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_DUMP='no'
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_DUMP_PATH='./'
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_VOLUME_SEQUENCE=
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_APPLIANCE=

  # carrier appliance upgrade devev_cpp
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DATE='no'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING='no'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_APPLIANCE_SEQUENCE=
}

### utility function mutating the execution context provided with a referential
### and a pair of key value
tryMutateReferential() {
  local referential="$1"
  local key="$2";
  local value="$3";

  # each 'entry' in a referential is made of 3 lines
  local key_pattern= ; local value_pattern= ; local mutator=

  # iterating through the referential
  for line in $referential; do
    # iterate to initialize locals
    if [ -z "$key_pattern" ]; then
      key_pattern="$line"
      continue
    fi

    if [ -z "$value_pattern" ]; then
      value_pattern="$line"
      continue
    fi

    mutator="$line"

    # test the provided key
    echo "$key" | grep -Ex -- "$key_pattern" 1> /dev/null

    if [ ! $? -eq 0 ]; then
      # the key do not match, test another entry in the referential
      # resetting patterns and mutator for another turn
      key_pattern= ; value_pattern= ; mutator=
      continue
    fi

    # testing value if necessary, a '--' pattern indicating that the key has not
    # value associated in the referential
    if [ ! "$value_pattern" = '--' ]; then
      echo "$value" | grep -Ex -- "$value_pattern" 1> /dev/null

      if [ ! $? -eq 0 ]; then
        # the value do not match, test another entry in the referential
        # resetting patterns and mutator for another turn
        key_pattern= ; value_pattern= ; mutator=
      continue
      fi

      # value matched the pattern, call the mutator with both key and value
      echo m="$mutator" k="$key" v="$value"
      return $?
    else
      # no value needed for this referential entry, call the mutator passing
      # only the key
      echo m="$mutator" k="$key"
      return $?
    fi
  done

  # failed to modify the execution context for this referential. unless it is
  # the most specialized referential (command options) it is not fatal as more
  # specialized referential will be explored for mutation
  return 1
}

### specialized mutator designed to mutate global options settings. Provided with
### 2 arguments with at least one that must be non empty.
tryMutateGlobalOptions() {
  # key MUST be set
  local key="$1";
  local value="$2";

  # clean referential, removing all comments
  local referential="$(deleteCommentLines "$GLOBAL_OPTIONS_REFERENTIAL")"

  tryMutateReferential "$referential" "$key" "$value"
  return $?
}

### specialized mutator designed to mutate the domain. Provided with
### 2 arguments with at least one that must be non empty.
tryMutateDomain() {
  # key MUST be set
  local key="$1";
  local value="$2";

  # clean referential, removing all comments
  local referential="$(deleteCommentLines "$DOMAINS_REFERENTIAL")"

  tryMutateReferential "$referential" "$key" "$value"
  return $?
}

### specialized mutator designed to mutate domain options settings. Provided
### with 2 arguments with at least one that must be non empty.
tryMutateDomainOptions() {
  # there is not any domain option that are supported so far
  return 1
}

### specialized mutator designed to mutate global commands settings. Provided
### with 2 arguments with at least one that must be non empty.
tryMutateGlobalCommand() {
  # key MUST be set
  local key="$1";
  local value="$2";

  # clean referential, removing all comments
  local referential="$(deleteCommentLines "$GLOBAL_COMMANDS_REFERENTIAL")"

  tryMutateReferential "$referential" "$key" "$value"
  return $?
}

### attempt to mutate a domain command. Test all domains command in chain. if
### all fail, it means the key and value are not domain commands
tryMutateDomainCommand() {
  # key MUST be set
  local key="$1";
  local value="$2";

  # clean referentials, removing all comments
  local bootstrap_referential="$(
    deleteCommentLines "$DOMAIN_BOOTSTRAP_COMMANDS_REFERENTIAL"
  )"

  local image_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMANDS_REFERENTIAL"
  )"

  local appliance_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMANDS_REFERENTIAL"
  )"

  tryMutateReferential "$bootstrap_referential" "$key" "$value" \
  || tryMutateReferential "$image_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_referential" "$key" "$value" \
  || return 1

  # allright, mutation occured
  return 0
}

### attempt to modify the execution context related to options of global
### commands.
tryMutateGlobalCommandOptions() {
  # key MUST be set
  local key="$1";
  local value="$2";

  # clean referentials, removing all comments
  local help_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL"
  )"

  local info_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_INFO_OPTIONS_REFERENTIAL"
  )"

  local install_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_INSTALL_OPTIONS_REFERENTIAL"
  )"

  local pack_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_PACK_OPTIONS_REFERENTIAL"
  )"

  local unpack_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_UNPACK_OPTIONS_REFERENTIAL"
  )"

  local vagrant_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_VAGRANT_OPTIONS_REFERENTIAL"
  )"

  # chaining mutation attempt, if all fail, argument were not about global
  # command options
  tryMutateReferential "$help_referential" "$key" "$value" \
  || tryMutateReferential "$info_referential" "$key" "$value" \
  || tryMutateReferential "$install_referential" "$key" "$value" \
  || tryMutateReferential "$pack_referential" "$key" "$value" \
  || tryMutateReferential "$unpack_referential" "$key" "$value" \
  || tryMutateReferential "$vagrant_referential" "$key" "$value" \
  || return 1

  # allright, mutation occured
  return 0
}

tryMutateDomainCommandOptions() {
  # key MUST be set
  local key="$1";
  local value="$2";

  # clean referentials, removing all comments
  local bootstrap_check_referential="$(
    deleteCommentLines "$DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS_REFERENTIAL"
  )"

  local bootstrap_run_referential="$(
    deleteCommentLines "$DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTIONS_REFERENTIAL"
  )"

  local image_build_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_BUILD_OPTIONS_REFERENTIAL"
  )"

  local image_list_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_LIST_OPTIONS_REFERENTIAL"
  )"

  local image_check_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_CHECK_OPTIONS_REFERENTIAL"
  )"

  local image_info_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_INFO_OPTIONS_REFERENTIAL"
  )"

  local image_upgrade_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL"
  )"

  local appliance_build_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTIONS_REFERENTIAL"
  )"

  local appliance_list_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_LIST_OPTIONS_REFERENTIAL"
  )"

  local appliance_check_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTIONS_REFERENTIAL"
  )"

  local appliance_info_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_INFO_OPTIONS_REFERENTIAL"
  )"

  local appliance_upgrade_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL"
  )"

  local appliance_start_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_START_OPTIONS_REFERENTIAL"
  )"

  local appliance_stop_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_STOP_OPTIONS_REFERENTIAL"
  )"

  local appliance_volumes_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTIONS_REFERENTIAL"
  )"

  tryMutateReferential "$bootstrap_check_referential" "$key" "$value" \
  || tryMutateReferential "$bootstrap_run_referential" "$key" "$value" \
  || tryMutateReferential "$image_build_referential" "$key" "$value" \
  || tryMutateReferential "$image_list_referential" "$key" "$value" \
  || tryMutateReferential "$image_check_referential" "$key" "$value" \
  || tryMutateReferential "$image_info_referential" "$key" "$value" \
  || tryMutateReferential "$image_upgrade_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_build_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_list_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_check_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_info_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_upgrade_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_start_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_stop_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_volumes_referential" "$key" "$value" \
  || return 1

  # allright, mutation occured
  return 0
}

### mutates the execution context with a key and a value as arguments
tryMutateExecutionContext() {
  local key="$1"
  local value="$2"

  # contextual mutation of the execution environment
  # - modification of global option is context free
  # - modification of the domain is ok only if not already set
  # - modification of domain option ok if domain is set
  # - modification of the command ok if not already set and depends if domain is
  #   set or not => global command or domain command
  # - command options modification can only take place after a command is set
  # as a result, a pair <key value> is used to mutate in order :
  # - global options                                   | more     ^ less
  # - domain                                           | specific | specific
  # - domain options                                   |          |
  # - global command or domain command                 |          |
  # - global command options or domain command options V          |
  #
  # Moreover, mutating global command and domain command are mutually exclusive
  # based on the domain set
  # same thing about global command option and domain command option, makes
  # sense.
  # general logic is following. The deeper you go the more specific you get:
  #
  # try mutate global option
  # `-> success => return 0
  # `-> failure ->
  #     try mutate domain
  #     `-> success => return 0
  #     `-> failure ->
  #         `-> try mutate domain option
  #             `-> success => return 0
  #             `-> failure ->
  #                 try mutate global command
  #                 `-> success => return 0
  #                 `-> failure ->
  #                     `-> try mutate domain command
  #                         `-> success => return 0
  #                         `-> failure ->
  #                             `-> try mutate global command options
  #                                 `-> success => return 0
  #                                 `-> failure ->
  #                                     try mutate domain command options
  #                                     `-> success => return 0
  #                                     `-> failure => return 1

  # chaining mutators by specificity order
  tryMutateGlobalOptions "$key" "$value" \
  || tryMutateDomain "$key" "$value" \
  || tryMutateDomainOptions "$key" "$value" \
  || tryMutateGlobalCommand "$key" "$value" \
  || tryMutateDomainCommand "$key" "$value" \
  || tryMutateGlobalCommandOptions "$key" "$value" \
  || tryMutateDomainCommandOptions "$key" "$value" \
  || return 1

  # mutation succeeded!
  return 0
}

### internal function attempting to mutate the execution context with a provided
### argument of the form key=value
tryMutateExecutionContextWithKeyEqualsValueArg() {
  if ! isPair "$1"; then
    return 1
  fi

  local key="$(keyOf "$1")"
  local value="$(valueOf "$1")"

  tryMutateExecutionContext "$key" "$value"

  return $?
}

### build the final execution context regarding provided arguments
buildExecutionContextFromArguments() {
  # the arguments provided could take 2 different forms :
  # - simple switch
  # - key-value pair
  # The simple switch may have the dashed or double dashed form
  # The key-value pair may have the space or the '=' as separator. A space
  # character could be specified more than once. This is not the case for the
  # '=' character separator.

  # description of the algorithm:
  # As arguments may take several forms that are parsed differently, the
  # behavior of the algorithm depends of the form of the argument.
  # The most deterministic form is the key=value form.
  # Thus, the algorithm will attempt to mutate the execution context trying to
  # extract key and value from the next argument.
  # If the key/value extraction fails, the algorithm will try to mutate the
  # execution context with the next argument as if it had the dashed or double
  # dashed form. If it fails, the algorithm will attempt to extract the next
  # argument and consider it as the value of the previous one (that is the key
  # therefore)

  local extractedKeyFromArg=

  local arg=
  for arg in $@; do
    if [ -z "$extractedKeyFromArg" ]; then
      # assuming I have a key=value argument
      tryMutateExecutionContextWithKeyEqualsValueArg "$arg" && continue

      # didn't work, assuming the arg is a single switch
      tryMutateExecutionContext "$arg" && continue

      # didn't work, arg may be the key of a key/value pair
      extractedKeyFromArg="$arg" && continue
    else
      # attempting to mutate the execution context with a key/value pair. this
      # is the last chance thus, failing here is fatal and denotes that the
      # argument pair is not conform to the referential
      tryMutateExecutionContext \
        "$extractedKeyFromArg" \
        "$arg" \
      || return 1

      extractedKeyFromArg=
    fi
  done
}

### entry point
run() {
  # argument are positional. First come global options, then, if any, domain
  # then domain options then then domain's command come, finally the command's
  # options.
  # if domain is not specified, that is perfectly valid, directly jump to
  # command and command's option

  # first build the argument referential
  buildArgumentsReferential

  # parse provided argument and use referentials to extract the execution
  # context. It will dictate how the carrier script will behave, which domain,
  # command and options to take into account.
  initializeExecutionContext

  # once initialization is done, overwrite values in variables regarding
  # provided arguments
  buildExecutionContextFromArguments "$@"
}

run "$@"
