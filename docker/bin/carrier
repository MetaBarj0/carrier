#!/bin/sh

#### standalone mode, external utility functions not loaded yet ################
set -e

# disable globbing. Referential contains string with '*' that behave wrongly
# when iterated by a for loop.
set -f

### set up paths after calling this script
initializePaths() {
  # get the full path of the called script
  cd $(dirname "$0")
  CALLED_SCRIPT="$(pwd -P)"/"$(basename "$0")"
  cd - 1>/dev/null 2>&1

  # if it is a symlink, resolve it, keeping the link path
  if [ -L "$CALLED_SCRIPT" ]; then
    INSTALLED_LINK_PATH="$CALLED_SCRIPT"
    CARRIER_SCRIPT_PATH="$(readlink -f "$CALLED_SCRIPT")"
  else
    CARRIER_SCRIPT_PATH="$CALLED_SCRIPT"
  fi

  # if the carrier script has been renammed, not supported => error
  if [ ! "$(basename "$CARRIER_SCRIPT_PATH")" = 'carrier' ]; then
    echo '`carrier` script has been renammed, not supported' 1>&2
    return 1
  fi

  # this directory exists and its path is absolute, verifying its name though
  CARRIER_BIN_DIR="$(dirname "$CARRIER_SCRIPT_PATH")"

  if [ ! "$(basename "$CARRIER_BIN_DIR")" = 'bin' ]; then
    cat << EOI 1>&2
The \`carrier\` script must reside in the \`bin/\` directory.
Not supported
EOI
  return 1
  fi

  # set up each carrier directories and verify them
  local relative_carrier_root_dir="$CARRIER_BIN_DIR"/..
  local relative_carrier_lib_dir="$relative_carrier_root_dir"/lib
  local relative_carrier_share_dir="$relative_carrier_root_dir"/share
  local relative_carrier_share_bootstrap_dir=\
"$relative_carrier_share_dir"/bootstrap
  local relative_carrier_share_images_dir="$relative_carrier_share_dir"/images
  local relative_carrier_share_appliances_dir=\
"$relative_carrier_share_dir"/appliances
  local relative_carrier_src_dir="$relative_carrier_root_dir"/src

  if [ ! -d "$relative_carrier_lib_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_lib_dir does not exist. Your \`carrier\` package seems
broken or corrupted. Not supported.
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_dir does not exist. Your \`carrier\` package
seems broken or corrupted. Not supported.
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_bootstrap_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_bootstrap_dir does not exist. Your \`carrier\`
package seems broken or corrupted. Not supported.
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_images_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_images_dir does not exist. Your \`carrier\`
package seems broken or corrupted. Not supported.
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_appliances_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_appliances_dir does not exist. Your \`carrier\`
package seems broken or corrupted. Not supported.
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_src_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_src_dir does not exist. Your \`carrier\` package seems
broken or corrupted. Not supported.
EOI
  return 1
  fi

  cd $relative_carrier_root_dir
  CARRIER_ROOT_DIR="$(pwd -P)"
  CARRIER_LIB_DIR="$CARRIER_ROOT_DIR"/lib
  CARRIER_SHARE_DIR="$CARRIER_ROOT_DIR"/share
  CARRIER_SHARE_BOOTSTRAP_DIR="$CARRIER_SHARE_DIR"/bootstrap
  CARRIER_SHARE_IMAGES_DIR="$CARRIER_SHARE_DIR"/images
  CARRIER_SHARE_APPLIANCES_DIR="$CARRIER_SHARE_DIR"/appliances
  CARRIER_SRC_DIR="$CARRIER_ROOT_DIR"/src
  CARRIER_TMP_DIR="$CARRIER_ROOT_DIR"/tmp
  USER_DIRECTORY="$(cd -)"

  return 0
}

### load utilities located in $CARRIER_LIB_DIR/functions.sh
loadUtilities() {
  local functions_sh_path="$CARRIER_LIB_DIR"/functions.sh

  if [ ! -f "$functions_sh_path" ]; then
    cat << EOI 1>&2
Fatal: $CARRIER_LIB_DIR/functions.sh does not exist. Your \`carrier\` package
seems broken or corrupted. not supported...existing...
EOI
    return 1
  fi

  # source stuff!
  . "$functions_sh_path"

  return $?
}

initializePaths
loadUtilities

# log function wired, fail on error is not necessary anymore
set +e
#### end of standalone mode, external utility functions loaded #################

### utility function returning true if log level is trace
isTraceLogLevel() {
  [ "$GLOBAL_OPTION_LOG_LEVEL" = 'trace' ]

  return $?
}

### utility function returning true if log level is debug
isDebugLogLevel() {
  isTraceLogLevel \
  || [ "$GLOBAL_OPTION_LOG_LEVEL" = 'debug' ]

  return $?
}

### utility function returning true if log level is info or greater
isInfoLogLevel() {
  isDebugLogLevel \
  || [ "$GLOBAL_OPTION_LOG_LEVEL" = 'info' ]

  return $?
}

### utility function returning true if log level is warning or greater
isWarningLogLevel() {
  isInfoLogLevel \
  || [ "$GLOBAL_OPTION_LOG_LEVEL" = 'warning' ]

  return $?
}

### utility function returning true if log level is error or greater
isErrorLogLevel() {
  isWarningLogLevel \
  || [ "$GLOBAL_OPTION_LOG_LEVEL" = 'error' ]

  return $?
}

### utility function returning true if log level is fatal or greater
isFatalLogLevel() {
  isErrorLogLevel \
  || [ "$GLOBAL_OPTION_LOG_LEVEL" = 'fatal' ]

  return $?
}

### logging function, designed to debug
### first and unique argument is the message
debug() {
  isDebugLogLevel && log '[debug] '"$1" "$GLOBAL_OPTION_LOG_OUTPUT"
  return 0
}

### logging function, designed to info
### first and unique argument is the message
info() {
  isInfoLogLevel && log '[info] '"$1" "$GLOBAL_OPTION_LOG_OUTPUT"
  return 0
}

### logging function, designed to warning
### first and unique argument is the message
warning() {
  isWarningLogLevel && log '[warning] '"$1" "$GLOBAL_OPTION_LOG_OUTPUT"
  return 0
}

### logging function, designed to error
### first and unique argument is the message
error() {
  isErrorLogLevel && log '[error] '"$1" "$GLOBAL_OPTION_LOG_OUTPUT"
  return 0
}

### logging function, designed to fatal
### first and unique argument is the message
fatal() {
  isFatalLogLevel && log '[fatal] '"$1" "$GLOBAL_OPTION_LOG_OUTPUT"
  return 0
}

### basic usage function, shows syntax, how to use, purpose and so on...
usage() {
  cat << EOI
Usage:
  carrier [global options] \\
          [[domain] [domain options] command [command options]] | \\
          command [command options]

Use:

  carrier help --full to get a full usage description
EOI

  return 0
}

### internal function that remove unnecessary information from global options
### referential specified in argument
removeIrrelevantDetailsFromReferentialOption() {
  local referential="$1"

  info 'removing irrelevant data from '"$referential"

  echo "$referential"\
  | sed -E '/^--$/d' \
  | sed -E '/contextSet.+/d'

  local returnCode=$?

  [ "$returnCode" -ne 0 ] \
  && fatal 'could not purify the options referential to get detailed help'

  return $returnCode
}

### Get a full help on usage
usageFull() {
  info 'printing full usage help'

  cat << EOI
$(usage)

Global options:
$(removeIrrelevantDetailsFromReferentialOption "$GLOBAL_OPTIONS_REFERENTIAL")

Global commands:
$(removeIrrelevantDetailsFromReferentialOption "$GLOBAL_COMMANDS_REFERENTIAL")

Help command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL")

Info command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL")

Install command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_INSTALL_OPTIONS_REFERENTIAL")

Pack command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_PACK_OPTIONS_REFERENTIAL")

Unpack command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_UNPACK_OPTIONS_REFERENTIAL")

Vagrant command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_VAGRANT_OPTIONS_REFERENTIAL")

Domains:
$(removeIrrelevantDetailsFromReferentialOption "$DOMAINS_REFERENTIAL")

Bootstrap domain commands:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_BOOTSTRAP_COMMANDS_REFERENTIAL")

Bootstrap run command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTIONS_REFERENTIAL")

Bootstrap check command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS_REFERENTIAL")

Image domain commands:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMANDS_REFERENTIAL")

Image build command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_BUILD_OPTIONS_REFERENTIAL")

Image list command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_LIST_OPTIONS_REFERENTIAL")

Image check command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_CHECK_OPTIONS_REFERENTIAL")

Image info command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_INFO_OPTIONS_REFERENTIAL")

Image upgrade command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL")

Image factorize command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTIONS_REFERENTIAL")

Appliance domain commands:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMANDS_REFERENTIAL")

Appliance build command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTIONS_REFERENTIAL")

Appliance list command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_LIST_OPTIONS_REFERENTIAL")

Appliance check command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTIONS_REFERENTIAL")

Appliance info command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_INFO_OPTIONS_REFERENTIAL")

Appliance start command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_START_OPTIONS_REFERENTIAL")

Appliance stop command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_STOP_OPTIONS_REFERENTIAL")

Appliance volumes command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTIONS_REFERENTIAL")

Appliance upgrade command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL")
EOI

  return $?
}

### built the argument referential, sort of description and constraints about
### each valid argument.
### each line of a variable definition define a pattern one arg can match at a
### time :
###
### line 0: optional comment lines starting with #
### line 1: pattern for argument
### line 2: pattern for argument value or --
### line 3: function name initializing execution context
buildArgumentsReferential() {
  info 'setting up the arguments referential'

  GLOBAL_OPTIONS_REFERENTIAL="$(cat << EOI
# desired log level. Defaulted to 'error'.
# i.e. carrier info --log-level=error
#      carrier info -l debug
(-l|--log-level)=?
fatal|error|warning|info|debug|trace
contextSetLogLevel

# desired output for logs. Defaulted to '&2' that is stderr
# i.e. carrier info --log-output=error.log
#      carrier info -o '&2'
(-o|--log-output)=?
.+
contextSetLogOutput
EOI
  )"

  GLOBAL_COMMANDS_REFERENTIAL="$(cat << EOI
# domainless commands. only valid when not any domain is specified.
#
# help: provides help about carrier usage
#       i.e. carrier help
#
# info: Provides general information about carrier
#       i.e. carrier info
#
# install: Install carrier to the specified location. Installation is a simple
#          process consisting in creating a symbolic link to the specified
#          location. If carrier is already installed somewhere or a symlink
#          exist with the specified name, the process fails by default.  Note:
#          If a file (not a symlink) exists at the specified location the
#          process will always fails even if forced.  If a symlink exists and
#          points on something existing other than a carrier installation, the
#          process will always fails to preserve system integrity.
#
# pack: Packs carrier into a single executable file, easying its transportation
#       and allowing it to be used on network-isolated systems (using specific
#       command options). By default, all the directory architecture of carrier
#       is packed, including necessary resources to bootstrap your system. Thus,
#       an internet connection is required to pack carrier.
#       Moreover, user file ~/.carrier will also be included. The resulting file
#       will be a shell script containing shell code and base64 encoded tar
#       archive. As a result, modern tar and base64 implementations are
#       necessary to use the pack command efficiently
#       i.e. carrier pack
#
# unpack: unpack a packed version of carrier, creating the original directory
#         structure of carrier. If you downloaded image sources in the packed
#         carrier, you can choose to keep them (this is not the default behavior
#         though). The .carrier file is extracted to the user directory.
#
# vagrant: manipulate the vagrant environment of carrier. Each command and
#          option you specify are directly forwarded to the vagrant program. If
#          vagrant is not found, the process fails.
help|info|install|pack|unpack|vagrant
--
contextSetGlobalCommand
EOI
  )"

  GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL="$(cat << EOI
# options for the domainless help command. Turn on exhaustive help
# i.e. carrier help -H
#      carrier help --full
-H|--full
--
contextSetHelpMode
EOI
  )"

  GLOBAL_COMMAND_INFO_OPTIONS_REFERENTIAL="$(cat << EOI
# specify the output format:
# - shell: give a a list of pairs of the form VAR=VAL
# - json: create a json object containing requested properties
(-f|--format)=?
shell|json
contextSetInfoFormat
EOI
  )"

  GLOBAL_COMMAND_INSTALL_OPTIONS_REFERENTIAL="$(cat << EOI
# Force the installation of carrier to the path specified even if a previous
# installation has been detected. If a reinstallation occurs, remove the
# previous one. Even if this flag is set, installation may fail if destination
# already exists and does not correspond to a previous carrier installation
-f|--force
--
contextSetInstallForce

# If reinstallation occurs, keep the existing one.
# i.e carrier install --force --keep-previous-installation
-k|--keep-previous-installation
--
contextSetInstallKeep
EOI
  )"

  GLOBAL_COMMAND_PACK_OPTIONS_REFERENTIAL="$(cat << EOI
# While packing, fetch all supported image sources from the internet and embbed
# them in the package. Beware as the package could grow arbitrarily large. Using
# this option is interesting if you want to use carrier on a network isolated
# system. This is not the default behavior of packing.
# i.e carrier pack --fetch-all-images-sources
-s|--fetch-all-images-sources
--
contextSetPackFetchAll

# Instead of packing carrier, only fetch sources of images. This option can be
# specified with -s and -i. This is not the default behavior of packing.
-o|--only-fetch-sources
--
contextSetPackFetchOnly

# While packing, fetch sources of specified images only. Sources of unspecified
# images will not be fetched, leading to a less heavy package but forcing one to
# grab source from the internet if an attempt to build an image that does not
# have its source stored locally is made. This is not the default behavior of
# packing.
# i.e carrier pack -i metabarj0/wget,metabarj0/llvm
(-i|--fetch-images-sources)=?
[^,]+(,[^,]+)*
contextSetPackSpecificImageFetch
EOI
  )"

  GLOBAL_COMMAND_UNPACK_OPTIONS_REFERENTIAL="$(cat << EOI
# While unpaking, do not delete fetch sources. This is not the default behavior
-k|--keep-sources-if-any
--
contextSetUnpackKeepSources
EOI
  )"

  GLOBAL_COMMAND_VAGRANT_OPTIONS_REFERENTIAL="$(cat << EOI
# Specify where to find the vagrant program. Defaulted to vagrant, therefore,
# vagrant is supposed to be found in the PATH environment variable.
(-p|--vagrant-path)=?
.+
contextSetVagrantPath

# commands/arguments/options to forward to the vagrant program. Must be enclosed
# by quotes to be parsed as a single argument in the carrier point of view.
'.+'
--
contextSetVagrantArguments
EOI
  )"

  DOMAINS_REFERENTIAL="$(cat << EOI
# specific domain of application for carrier. A domain is the highest level
# context carrier acts on.
#
# bootstrap: the bootstrap context can be used with bootstrap specific commands
#            and options. Allows one to deal with all the bootstrapping stuff.
#
# image: the image context is related to docker image manipulation and provides
#        image specific commands and options.
#
# appliance: the appliance domain deals with appliance manipulation and provides
#            appliance specific commands and options.
bootstrap|image|appliance
--
contextSetDomain
EOI
  )"

  DOMAIN_BOOTSTRAP_COMMANDS_REFERENTIAL="$(cat << EOI
# available commands in the bootstrap domain
# - check verify the current environment is correctly bootstrap
# - run bootstrap the system
check|run
--
contextSetBootstrapCommand
EOI
  )"

  DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS_REFERENTIAL="$(cat << EOI
# no options yet
EOI
  )"

  DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTIONS_REFERENTIAL="$(cat << EOI
# specifying this option for a bootstrap run command allows to keep existing
# images produced by a previous bootstrap run. Images will be tagged with the
# current data and time using the '+%Y%m%d%H%M%S' format usable with the date
# command.
-t|--retag-existing-images
--
contextSetBootstrapRunRetag
EOI
  )"

  DOMAIN_IMAGE_COMMANDS_REFERENTIAL="$(cat << EOI
# available commands for the image domain.
# - build can build one or more images
# - list can list images on the system, reporting information about the
#   availability of images
# - check verifies one or more images are healthy and up to date
# - info report about internal informations about an image
# - upgrade can upgrade one or more image regarding their dependencies status
build|list|check|info|upgrade|factorize
--
contextSetImageCommand
EOI
  )"

  DOMAIN_IMAGE_COMMAND_BUILD_OPTIONS_REFERENTIAL="$(cat << EOI
# specifying this option while building an image prevent the system to tag a
# previous version existing on the docker host. As a result, if a previous
# version of the image being built were present; it is deleted instead of being
# retagged. This is not the default behavior.
-r|--remove-existing-images
--
contextSetImageBuildRemoveExisting

# sequence (or unique) image to be built. The sequence can be made of :
# - image name (the directory name containing image files)
# - relative path of the image manifest file
# - absolute path of the image manifest file
# - a mix of all three
[^,]+(,[^,]+)*
--
contextSetImageBuildImageSequence
EOI
  )"

  DOMAIN_IMAGE_COMMAND_LIST_OPTIONS_REFERENTIAL="$(cat << EOI
# list all images, built, not built, local and remote
-a|--all
--
contextSetImageListAll

# list only built images
-b|--only-built
--
contextSetImageListOnlyBuilt

# list only not built images
-n|--only-not-built
--
contextSetImageListOnlyNotBuilt

# list only local images that are not present on remote repository (new images
# being created for instance)
-l|--only-local
--
contextSetImageListOnlyLocal

# list only supported images that are present on the remote repository.
-r|--only-remote
--
contextSetImageListOnlyRemote

# specify the output format:
# - one-line outputs the result in one line, each image name being separated by
#   a space character and formated as following:
#   image1:flags,image2:flags,...
#   flags being:
#   - b for built
#   - n for not built
#   - l for local
#   - r for remote
# Note that local and remote are not exclusive though it is unlikely to have an
# image flagged as remote that is not present on your local system (unless you
# deliberatly removed it)
# - pretty outputs a very nice table (default)
# - docker relies on the docker client to output the result. You can specify
# docker specific format information appending
# \`:'docker format args for docker images'\`
# The docker format works only for built images
(-f|--format)=?
one-line|pretty|docker(:'.*')?
contextSetImageListFormat
EOI
  )"

  DOMAIN_IMAGE_COMMAND_CHECK_OPTIONS_REFERENTIAL="$(cat << EOI
# checks all built image by checking their dependencies integrity. If an image
# name is output, it means that something is wrong with the dependency chain.
# Image name is output if:
# - a dependency is newer than the image, meaning the image may need to be
#   rebuilt
# - a dependency is missing meaning the image may not be up to date
# - the /image.dist file of the image is missing or corrupted, meaning something
#   went wrong when image has been built.
# checking all images is the default behavior
-a|--all-installed
--
contextSetImageCheckAllBuilt

# ignore the build date of dependecies when checking images
-d|--ignore-date
--
contextSetImageCheckIgnoreDate

# ignore if dependency is missing on the docker host when checking images
-m|--ignore-missing
--
contextSetImageCheckIgnoreMissing

# ignore detected defect in image checking (not recommended)
-i|--ignore-image-dist-defects
--
contextSetImageCheckIgnoreDependencyDefects

# format the output if something is found:
# - list gives a list of the form:
#   image:issue1,issue2...
# - pretty ouput a nice table (default)
(-f|--format)=?
list|pretty
contextSetImageCheckFormat

# explicit image list to cheack instead of all
(-l|--image-list)=?
[^,]+(,[^,]+)*
contextSetImageCheckImageSequence
EOI
  )"

  DOMAIN_IMAGE_COMMAND_INFO_OPTIONS_REFERENTIAL="$(cat << EOI
# report all properties of requested image (default behavior)
-a|--report-all
--
contextSetImageInfoAllProps

# only report the image.dist content
-i|--report-image-content
--
contextSetImageInfoOnlyContent

# only report the docker image name provided
-p|--report-provides
--
contextSetImageInfoOnlyProvides

# only report dependency image names
-r|--report-requires
--
contextSetImageInfoOnlyRequires

# report the name of the base image
-b|--report-base-image
--
contextSetImageInfoOnlyBaseImage

# report the name of the image used to fetch sources
-d|--report-sources-fetch-image
--
contextSetImageInfoOnlyFetchImage

# report the command used to fetch sources
-s|--report-sources-fetch-command
--
contextSetImageInfoOnlyFetchCommand

# report the name of the sources tarball
-c|--report-sources-tarball-name
--
contextSetImageInfoOnlyTarballName

# report extra dockerfile commands appended to the generated Dockerfile for the
# image building process
-x|--report-build-extra-dockerfile-commands
--
contextSetImageInfoOnlyBuildExtraDockerfileCommands

# report extra dockerfile commands used to build the final image
-z|--report-final-extra-dockerfile-commands
--
contextSetImageInfoOnlyFinalExtraDockerfileCommands

# specify the output format:
# - shell: give a a list of pairs of the form VAR=VAL
# - json: create a json object containing requested properties
(-f|--format)=?
shell|json
contextSetImageInfoFormat

# the image to observe
.+
--
contextSetImageInfoImage
EOI
  )"

  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL="$(cat << EOI
# attempt an upgrade of all built images by checking their dependencies
# integrity and status. If one or more dependencies have a problem or is newer
# than the observed image, both actions are taken:
# - dependencies is corrupted: report the issue and does nothing else
# - a dependency is newer than the image : the observed image is rebuilt
# - a dependency is missing : report and does nothing else
# this is the default behavior
-a|--all-installed
--
contextSetImageUpgradeAll

# ignore the date of dependencies of the observed image. Note that ignore date
# in using the upgrade command will always inhibit the image rebuild.
-d|--ignore-date
--
contextSetImageUpgradeIgnoreDate

# does not report missing dependency
-m|--ignore-missing
--
contextSetImageUpgradeIgnoreMissing

# does not report a defect problem in a dependency image
-i|--ignore-image-dist-defects
--
contextSetImageUpgradeIgnoreDependencyDefects

# specify an image list instead of attempting to upgrade them all. list has the
# form :
# image1,image2...
(-l|--image-list)=?
[^,]+(,[^,]+)*
contextSetImageUpgradeImageSequence
EOI
  )"

  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTIONS_REFERENTIAL="$(cat << EOI
# options available when factorizing two or more images to extract a base that
# contains all common files. Factorizing images consists in taking 2 or more
# images, extract all files that are common in all these images, create a brand
# new image with these common files, and create new images with their
# respective files without common extracted ones.

# the name to give to the extracted base image. Note that the provided name
# must be conform to the docker standart in term of naming.
(-n|--base-image-name)=?
.+
contextSetImageFactorizeBaseImageName

# this is the prefix used to name the extracted base image. As a result, a
# prefixed base image will look like : prefix/base_image_name when listing
# docker images
# if not specified, defaulted to 'base'
(-b|--base-image-prefix)=?
.*
contextSetImageFactorizeBaseImagePrefix

# prefix used on factorized images. A prefixed factorized image will look like
# prefix/factorize_image when listing docker images. If the prefix is not
# specified, the prefixed base image name is used.
(-f|--factorized-image-prefix)=?
.*
contextSetImageFactorizeFactorizedImagePrefix

# the image list to factorize. At least 2 images have to be specified but
# specifying more than 2 is perfectly valid. However, keep in mind that
# specified images having lots of files in common tend to be more factorizable.
(-l|--image-list)=?
[^,]+(,[^,]+)+
contextSetImageFactorizeImageSequence

# indicates if original images must be removed after a successful
# factorization. defaulted to 'no'
(-r|--remove-original-images)=?
--
contextSetImageFactorizeRemoveOriginalImages
EOI
  )"

  DOMAIN_APPLIANCE_COMMANDS_REFERENTIAL="$(cat << EOI
# available commands for the appliance domain.
# - build can build one or more appliances.
# - list can list appliances on the system, reporting information about the
#   availability of appliances
# - check verifies one or more appliances are healthy and up to date
# - info report about internal informations about an appliance
# - upgrade can upgrade one or more appliances regarding their service image and
#   dependencies status
# - start can start an appliance or several
# - stop can stop one or more appliances
# - volumes can help the user to manage columes used by an appliance
build|list|check|info|upgrade|start|stop|volumes
--
contextSetApplianceCommand
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTIONS_REFERENTIAL="$(cat << EOI
# When building an appliance, remove all appliance service images that already
# exist on the docker host. This is not the default behavior as by default, if
# images exist, nothing is built
-r|--remove-existing-images
--
contextSetApplianceBuildRemoveExisting

# When building an appliance, tag all existing service image using the
# '+%Y%m%d%H%M%S' format usable with the date command. This is not the default
# behavior as by default, if images exist, nothing is built
-t|--tag-existing-images
--
contextSetApplianceBuildTagExisting

# the appliance list to build. Has the form:
# appliance1,appliance2...
[^,]+(,[^,]+)*
--
contextSetApplianceBuildApplianceSequence
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_LIST_OPTIONS_REFERENTIAL="$(cat << EOI
# list all appliances, built, not built, local and remote
-a|--all
--
contextSetApplianceListAll

# list only built appliances
-b|--only-built
--
contextSetApplianceListOnlyBuilt

# list only not built appliances
-n|--only-not-built
--
contextSetApplianceListOnlyNotBuilt

# list only local appliances that are not present on remote repository (new
# appliances being created for instance)
-l|--only-local
--
contextSetApplianceListOnlyLocal

# list only supported appliances that are present on the remote repository.
-r|--only-remote
--
contextSetApplianceListOnlyRemote

# specify the output format:
# - one-line outputs the result in one line, each appliance name being separated
#   by a space character and formated as following:
#   appliance1:flags,appliance2:flags,...
#   flags being:
#   - b for built
#   - n for not built
#   - l for local
#   - r for remote
# Note that local and remote are not exclusive though it is unlikely to have an
# appliance flagged as remote that is not present on your local system (unless
# you deliberatly removed it)
# - pretty outputs a very nice table (default)
(-f|--format)=?
one-line|pretty
contextSetApplianceListFormat
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTIONS_REFERENTIAL="$(cat << EOI
# verify all built appliances by checking each of its service image. (default
# behavior)
-a|--all-installed
--
contextSetApplianceCheckAll

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are more up to date than the
# service image, it is ignored and the service image will be considered ok
-d|--ignore-date
--
contextSetApplianceCheckIgnoreDate

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are missing on the docker host
# it is ignored and the service image will be considered ok
-m|--ignore-missing
--
contextSetApplianceCheckIgnoreMissing

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies have something wrong in their
# image.dist file, it is ignored and the service image will be considered ok
# (this is not recommended)
-i|--ignore-image-dist-defects
--
contextSetApplianceCheckIgnoreDependencyDefects

# explicit list of appliance to check. The list has the form:
# appliance1,appliance2...
(-l|--appliance-list)=?
[^,]+(,[^,]+)*
contextSetApplianceCheckApplianceList
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_INFO_OPTIONS_REFERENTIAL="$(cat << EOI
# report all information properties of the appliance (default behavior)
-a|--report-all
--
contextSetApplianceInfoAllProps

# report only the base image used for the observed service image
-b|--report-base-image
--
contextSetApplianceInfoOnlyBase

# execute a docker-compose config on the appliance docker-compose.yml file
-c|--report-config
--
contextSetApplianceInfoOnlyConfig

# reports only dependent images required for the service being observed
-r|--report-requires
--
contextSetApplianceInfoOnlyRequires

# report only extra Dockerfile commands used in the observed service image
-x|--report-extra-dockerfile-commands
--
contextSetApplianceInfoOnlyExtraDockerfileCommands

# inspect all services of the appliance (default behavior)
-s|--all-services
--
contextSetApplianceInfoAllServices

# specify a list of service to observe. List has the form:
# service1,service2...
(-s|--service)=?
[^,]+(,[^,])*
contextSetApplianceInfoServiceSequence

# output format of the report
# shell is a list of pairs of the form key=value (default)
# json output the result in a json object
(-f|--format)=?
shell|json
contextSetApplianceInfoFormat

# the appliance to get info from
.+
--
contextSetApplianceInfoAppliance
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_START_OPTIONS_REFERENTIAL="$(cat << EOI
# if appliances requested to start does not exist, attempt to build it
# beforehand using default options. Default behavior
-b|--build
--
contextSetApplianceStartBuild

# do not attempt to build appliance service image if they are missing. If one
# or more service images are missing this command will fail(not default
# behavior)
-n|--dont-build
--
contextSetApplianceStartDontBuild

# list of appliance to start. List has the form:
# appliance1,appliance2...
[^,]+(,[^,]+)*
--
contextSetApplianceStartApplianceSequence
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_STOP_OPTIONS_REFERENTIAL="$(cat << EOI
# when stopping an appliance, also remove created containers. Containers are
# considered ephemeral by design so it is the default behavior
-d|--rm
--
contextSetApplianceStopRemoveContainers

# do not delete appliance container when stopping. This is not the default
# behavior
-k|--keep-containers
--
contextSetApplianceStopKeepContainers

# list of appliance to stop. List has the form:
# appliance1,appliance2...
[^,]+(,[^,]+)*
--
contextSetApplianceStopApplianceSequence
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTIONS_REFERENTIAL="$(cat << EOI
# list the appliance volumes
-l|--list
--
contextSetApplianceVolumesList

# remove all the appliance volumes
-r|--rm
--
contextSetApplianceVolumesRemove

# dump specified volumes
-d|--dump
--
contextSetApplianceVolumesDump

# specify the dump file path (defaulted to current directory)
(-p|--dump-file-path)=?
.+
contextSetApplianceVolumesDumpPath

# specific list of volume. used with --rm and --dump options
(-v|--volume-list)=?
[^,]+(,[^,]+)*
contextSetApplianceVolumesList

# targeted appliance
(-a|--appliance)=?
.+
contextSetApplianceVolumesAppliance
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL="$(cat << EOI
# scan all built appliances
-a|--all-installed
--
contextSetApplianceUpgradeAll

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are more up to date than the
# service image, it is ignored and the service image will be considered up to
# date
-d|--ignore-date
--
contextSetApplianceUpgradeIgnoreDate

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are missing on the docker host
# it is ignored and the service image will be considered up to date
-m|--ignore-missing
--
contextSetApplianceUpgradeIgnoreMissing

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies have something wrong in their
# image.dist file, it is ignored and the service image will be considered up to
# date (this is not recommended)
-i|--ignore-image-dist-defects
--
contextSetApplianceUpgradeIgnoreDependencyDefects

# explicit list of appliance to check. The list has the form:
# appliance1,appliance2...
(-l|--appliance-list)=?
[^,]+(,[^,]+)*
contextSetApplianceUpgradeApplianceSequence
EOI
  )"

  return $?
}

### initialize the execution context of carrier, dictating what to do with
### provided arguments
initializeExecutionContext() {
  info 'Initializing the execution context with default values'

  # user can set up this variable value before executing this script. It allows
  # to take benefit of the log level before having to parse arguments passed to
  # the script, allowing to log level higher than error before the execution
  # begins
  # carrier --log-level=error ...
  [ -z "$GLOBAL_OPTION_LOG_LEVEL" ] \
  && GLOBAL_OPTION_LOG_LEVEL=error

  GLOBAL_OPTION_LOG_OUTPUT='&2'

  # carrier help, carrier appliance run ...
  COMMAND=

  # carrier help -H
  GLOBAL_COMMAND_HELP_OPTION_MODE=

  # carrier info --format=shell
  GLOBAL_COMMAND_INFO_OPTION_FORMAT='shell'

  # carrier install --force -k
  GLOBAL_COMMAND_INSTALL_OPTION_FORCE='no'
  GLOBAL_COMMAND_INSTALL_OPTION_KEEP='no'

  # carrier pack -s
  GLOBAL_COMMAND_PACK_OPTION_FETCH_ALL_SOURCES='no'
  GLOBAL_COMMAND_PACK_OPTION_ONLY_FETCH_SOURCES='no'
  GLOBAL_COMMAND_PACK_OPTION_FETCH_SPECIFIC_IMAGE_SOURCES=

  # carrier unpack -k
  GLOBAL_COMMAND_UNPACK_OPTION_KEEP_SOURCES='no'

  # carrier vagrant -p '/usr/local/bin/vagrant' up
  GLOBAL_COMMAND_VAGRANT_OPTION_PATH='vagrant'
  GLOBAL_COMMAND_VAGRANT_OPTION_ARGUMENTS=

  # bootstrap or image or appliance
  DOMAIN=

  # not used yet
  DOMAIN_OPTIONS=

  # not used yet
  DOMAIN_BOOTSTRAP_OPTIONS=
  DOMAIN_IMAGE_OPTIONS=
  DOMAIN_APPLIANCE_OPTIONS=

  # carrier bootstrap check
  DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS=

  # carrier bootstrap run --retag-existing-images
  DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTION_RETAG_EXISTING='no'

  # carrier image build -r metabarj0/wget
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_REMOVE_EXISTING='no'
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE=

  # carrier image list -b --format json
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ALL='yes'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_BUILT='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_NOT_BUILT='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_LOCAL='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_REMOTE='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_FORMAT='pretty'

  # carrier image check --all --ignore-missing
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_ALL_IMAGES='yes'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DATE='no'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_MISSING='no'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_FORMAT='pretty'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IMAGE_SEQUENCE=

  # carrier image info --report-base-image -f shell
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ALL='yes'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_CONTENT='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_PROVIDES='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_REQUIRES='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_BASE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_IMAGE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_COMMAND='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_TARBALL_NAME='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_BUILD_DOCKERFILE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_FINAL_DOCKERFILE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_FORMAT='shell'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_IMAGE=

  # carrier image upgrade metabarj0/git,metabarj0/gdb
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_ALL='yes'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DATE='no'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING='no'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IMAGE_SEQUENCE=

  # carrier image factorize \
  #   -n dev_toolchains \
  #   -l metabarj0/llvm,metabarj0/gcc
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME=
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_PREFIX='base'
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_FACTORIZED_IMAGE_PREFIX=
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE=
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_REMOVE_ORIGINAL_IMAGES='no'

  # carrier appliance build devenv_cpp -r
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_REMOVE_EXISTING='no'
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_TAG_EXISTING='no'
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE=

  # carrier appliance list --only-remote -f one-line
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_BUILT='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_NOT_BUILT='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_LOCAL='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_REMOTE='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_FORMAT='pretty'

  # carrier appliance check devenv_cpp
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DATE='no'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_MISSING='no'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_APPLIANCE_LIST='no'

  # carrier appliance info --report-config
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_REPORT_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_BASE='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_CONFIG='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_REQUIRES='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_EXTRA_DOCKERFILE='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_ALL_SERVICES='yes'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_SERVICE_LIST=
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_FORMAT='shell'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_APPLIANCE=

  # carrier appliance start devenv_cpp -n
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_BUILD='yes'
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE=

  # carrier appliance stop  --keep-containers devenv_cpp
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_REMOVE_CONTAINERS='yes'
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE=

  # carrier appliance volumes devenv_cpp
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_LIST='yes'
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_REMOVE='no'
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_DUMP='no'
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_DUMP_PATH='./'
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_VOLUME_SEQUENCE=
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_APPLIANCE=

  # carrier appliance upgrade devev_cpp
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DATE='no'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING='no'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_APPLIANCE_SEQUENCE=

  return $?
}

### internal function displyaing the content of the execution context
debugOutputExecutionContext() {
  info 'outputting current execution context'

  cat << EOI
  GLOBAL_OPTION_LOG_LEVEL=\
$GLOBAL_OPTION_LOG_LEVEL
  GLOBAL_OPTION_LOG_OUTPUT=\
$GLOBAL_OPTION_LOG_OUTPUT
  COMMAND=\
$COMMAND
  GLOBAL_COMMAND_HELP_OPTION_MODE=\
$GLOBAL_COMMAND_HELP_OPTION_MODE
  GLOBAL_COMMAND_INFO_OPTION_FORMAT=\
$GLOBAL_COMMAND_INFO_OPTION_FORMAT
  GLOBAL_COMMAND_INSTALL_OPTION_FORCE=\
$GLOBAL_COMMAND_INSTALL_OPTION_FORCE
  GLOBAL_COMMAND_INSTALL_OPTION_KEEP=\
$GLOBAL_COMMAND_INSTALL_OPTION_KEEP
  GLOBAL_COMMAND_PACK_OPTION_FETCH_ALL_SOURCES=\
$GLOBAL_COMMAND_PACK_OPTION_FETCH_ALL_SOURCES
  GLOBAL_COMMAND_PACK_OPTION_ONLY_FETCH_SOURCES=\
$GLOBAL_COMMAND_PACK_OPTION_ONLY_FETCH_SOURCES
  GLOBAL_COMMAND_PACK_OPTION_FETCH_SPECIFIC_IMAGE_SOURCES=\
$GLOBAL_COMMAND_PACK_OPTION_FETCH_SPECIFIC_IMAGE_SOURCES
  GLOBAL_COMMAND_UNPACK_OPTION_KEEP_SOURCES=\
$GLOBAL_COMMAND_UNPACK_OPTION_KEEP_SOURCES
  GLOBAL_COMMAND_VAGRANT_OPTION_PATH=\
$GLOBAL_COMMAND_VAGRANT_OPTION_PATH
  GLOBAL_COMMAND_VAGRANT_OPTION_ARGUMENTS=\
$GLOBAL_COMMAND_VAGRANT_OPTION_ARGUMENTS
  DOMAIN=\
$DOMAIN
  DOMAIN_OPTIONS=\
$DOMAIN_OPTIONS
  DOMAIN_BOOTSTRAP_OPTIONS=\
$DOMAIN_BOOTSTRAP_OPTIONS
  DOMAIN_IMAGE_OPTIONS=\
$DOMAIN_IMAGE_OPTIONS
  DOMAIN_APPLIANCE_OPTIONS=\
$DOMAIN_APPLIANCE_OPTIONS
  DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS=\
$DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS
  DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTION_RETAG_EXISTING=\
$DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTION_RETAG_EXISTING
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_REMOVE_EXISTING=\
$DOMAIN_IMAGE_COMMAND_BUILD_OPTION_REMOVE_EXISTING
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ALL=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ALL
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_BUILT=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_BUILT
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_NOT_BUILT=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_NOT_BUILT
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_LOCAL=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_LOCAL
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_REMOTE=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_REMOTE
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_FORMAT=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_FORMAT
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_ALL_IMAGES=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_ALL_IMAGES
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DATE=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DATE
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_MISSING=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_MISSING
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_FORMAT=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_FORMAT
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IMAGE_SEQUENCE
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ALL=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ALL
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_CONTENT=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_CONTENT
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_PROVIDES=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_PROVIDES
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_REQUIRES=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_REQUIRES
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_BASE=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_BASE
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_IMAGE=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_IMAGE
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_COMMAND=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_COMMAND
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_TARBALL_NAME=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_TARBALL_NAME
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_BUILD_DOCKERFILE=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_BUILD_DOCKERFILE
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_FINAL_DOCKERFILE=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_FINAL_DOCKERFILE
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_FORMAT=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_FORMAT
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_IMAGE=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_IMAGE
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_ALL=\
$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_ALL
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DATE=\
$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DATE
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING=\
$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS=\
$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IMAGE_SEQUENCE
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_PREFIX=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_PREFIX
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_FACTORIZED_IMAGE_PREFIX=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_FACTORIZED_IMAGE_PREFIX
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_REMOVE_ORIGINAL_IMAGES=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_REMOVE_ORIGINAL_IMAGES
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_REMOVE_EXISTING=\
$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_REMOVE_EXISTING
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_TAG_EXISTING=\
$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_TAG_EXISTING
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ALL=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ALL
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_BUILT=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_BUILT
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_NOT_BUILT=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_NOT_BUILT
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_LOCAL=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_LOCAL
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_REMOTE=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_REMOTE
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_FORMAT=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_FORMAT
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_ALL=\
$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_ALL
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DATE=\
$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DATE
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_MISSING=\
$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_MISSING
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS=\
$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_APPLIANCE_LIST=\
$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_APPLIANCE_LIST
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_REPORT_ALL=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_REPORT_ALL
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_BASE=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_BASE
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_CONFIG=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_CONFIG
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_REQUIRES=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_REQUIRES
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_EXTRA_DOCKERFILE=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_EXTRA_DOCKERFILE
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_ALL_SERVICES=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_ALL_SERVICES
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_SERVICE_LIST=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_SERVICE_LIST
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_FORMAT=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_FORMAT
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_APPLIANCE=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_APPLIANCE
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_BUILD=\
$DOMAIN_APPLIANCE_COMMAND_START_OPTION_BUILD
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_REMOVE_CONTAINERS=\
$DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_REMOVE_CONTAINERS
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_LIST=\
$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_LIST
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_REMOVE=\
$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_REMOVE
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_DUMP=\
$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_DUMP
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_DUMP_PATH=\
$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_DUMP_PATH
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_VOLUME_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_VOLUME_SEQUENCE
  DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_APPLIANCE=\
$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTION_APPLIANCE
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_ALL=\
$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_ALL
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DATE=\
$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DATE
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING=\
$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS=\
$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_APPLIANCE_SEQUENCE
EOI

  return $?
}

### utility function mutating the execution context provided with a referential
### and a pair of key value
tryMutateReferential() {
  info 'attempting to mutate the execution context'

  local referential="$1"
  local key="$2";
  local value="$3";

  debug "referential="$referential"
key="$key"
value="$value""

  # each 'entry' in a referential is made of 3 lines
  local key_pattern= ; local value_pattern= ; local mutator=

  # iterating through the referential
  for line in $referential; do
    # iterate to initialize locals, then do the processing
    [ -z "$key_pattern" ] && key_pattern="$line" && continue
    [ -z "$value_pattern" ] && value_pattern="$line" && continue
    mutator="$line"

    debug "$(cat << EOI
key_pattern=$key_pattern
value_pattern=$value_pattern
mutator=$mutator
EOI
    )"

    # test the provided key
    exactMatchWithPattern "$key" "$key_pattern"

    if [ $? -ne 0 ]; then
      # the key do not match, test another entry in the referential
      # resetting patterns and mutator for another turn
      key_pattern= ; value_pattern= ; mutator=

      debug "$(cat << EOI
provided key: $key does not match the explored referential key
pattern: $key_pattern
EOI
      )"

      continue
    fi

    # testing value if necessary, a '--' pattern indicating that the key has not
    # value associated in the referential
    if [ ! "$value_pattern" = '--' ]; then
      exactMatchWithPattern "$value" "$value_pattern"

      if [ ! $? -eq 0 ]; then
        # the value do not match, test another entry in the referential
        # resetting patterns and mutator for another turn
        key_pattern= ; value_pattern= ; mutator=

        debug "$(cat << EOI
provided value: $value does not match the explored referential value
pattern: $value_pattern
EOI
        )"

        continue
      fi
    fi

    debug 'key is not associated with any value in the referential'

    debug 'calling '"$mutator"' '"$key"' '"$value"

    # value matched the pattern, call the mutator with both key and value,
    # though value may be empty
    # echo m="$mutator" k="$key" v="$value"
    "$mutator" "$key" "$value"
    local returnCode=$?

    [ "$returnCode" -ne 0 ] \
    && debug "$(cat << EOI
The mutator: $mutator failed to execute correctly with key: $key and
value: $value
EOI
          )"

    return $returnCode
  done

  # failed to modify the execution context for this referential. unless it is
  # the most specialized referential (command options) it is not fatal as more
  # specialized referential will be explored for mutation
  debug 'Could not modify the referential: '"$referential"

  return 1
}

### specialized mutator designed to mutate global options settings. Provided
### with 2 arguments with at least one that must be non empty.
tryMutateGlobalOptions() {
  info 'attempting to mutate global options'

  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referential, removing all comments
  local referential="$(deleteCommentLines "$GLOBAL_OPTIONS_REFERENTIAL")" \
  && tryMutateReferential "$referential" "$key" "$value"

  return $?
}

### specialized mutator designed to mutate the domain. Provided with
### 2 arguments with at least one that must be non empty.
tryMutateDomain() {
  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referential, removing all comments
  local referential="$(deleteCommentLines "$DOMAINS_REFERENTIAL")"

  tryMutateReferential "$referential" "$key" "$value"

  return $?
}

### specialized mutator designed to mutate domain options settings. Provided
### with 2 arguments with at least one that must be non empty.
tryMutateDomainOptions() {
  debug 'Not Implemented Yet'

  # there is not any domain option that are supported so far
  return 1
}

### specialized mutator designed to mutate global commands settings. Provided
### with 2 arguments with at least one that must be non empty.
tryMutateGlobalCommand() {
  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referential, removing all comments
  local referential="$(deleteCommentLines "$GLOBAL_COMMANDS_REFERENTIAL")"

  tryMutateReferential "$referential" "$key" "$value"

  return $?
}

### attempt to mutate a domain command. Test all domains command in chain. if
### all fail, it means the key and value are not domain commands
tryMutateDomainCommand() {
  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referentials, removing all comments
  local bootstrap_referential="$(
    deleteCommentLines "$DOMAIN_BOOTSTRAP_COMMANDS_REFERENTIAL"
  )"

  local image_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMANDS_REFERENTIAL"
  )"

  local appliance_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMANDS_REFERENTIAL"
  )"

  tryMutateReferential "$bootstrap_referential" "$key" "$value" \
  || tryMutateReferential "$image_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_referential" "$key" "$value"

  return $?
}

### attempt to modify the execution context related to options of global
### commands.
tryMutateGlobalCommandOptions() {
  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referentials, removing all comments
  local help_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL"
  )"

  local info_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_INFO_OPTIONS_REFERENTIAL"
  )"

  local install_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_INSTALL_OPTIONS_REFERENTIAL"
  )"

  local pack_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_PACK_OPTIONS_REFERENTIAL"
  )"

  local unpack_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_UNPACK_OPTIONS_REFERENTIAL"
  )"

  local vagrant_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_VAGRANT_OPTIONS_REFERENTIAL"
  )"

  # chaining mutation attempt, if all fail, argument were not about global
  # command options
  tryMutateReferential "$help_referential" "$key" "$value" \
  || tryMutateReferential "$info_referential" "$key" "$value" \
  || tryMutateReferential "$install_referential" "$key" "$value" \
  || tryMutateReferential "$pack_referential" "$key" "$value" \
  || tryMutateReferential "$unpack_referential" "$key" "$value" \
  || tryMutateReferential "$vagrant_referential" "$key" "$value"

  return $?
}

tryMutateDomainCommandOptions() {
  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referentials, removing all comments
  local bootstrap_check_referential="$(
    deleteCommentLines "$DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS_REFERENTIAL"
  )"

  local bootstrap_run_referential="$(
    deleteCommentLines "$DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTIONS_REFERENTIAL"
  )"

  local image_build_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_BUILD_OPTIONS_REFERENTIAL"
  )"

  local image_list_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_LIST_OPTIONS_REFERENTIAL"
  )"

  local image_check_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_CHECK_OPTIONS_REFERENTIAL"
  )"

  local image_info_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_INFO_OPTIONS_REFERENTIAL"
  )"

  local image_upgrade_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL"
  )"

  local image_factorize_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTIONS_REFERENTIAL"
  )"

  local appliance_build_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTIONS_REFERENTIAL"
  )"

  local appliance_list_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_LIST_OPTIONS_REFERENTIAL"
  )"

  local appliance_check_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTIONS_REFERENTIAL"
  )"

  local appliance_info_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_INFO_OPTIONS_REFERENTIAL"
  )"

  local appliance_upgrade_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL"
  )"

  local appliance_start_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_START_OPTIONS_REFERENTIAL"
  )"

  local appliance_stop_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_STOP_OPTIONS_REFERENTIAL"
  )"

  local appliance_volumes_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_VOLUMES_OPTIONS_REFERENTIAL"
  )"

  tryMutateReferential "$bootstrap_check_referential" "$key" "$value" \
  || tryMutateReferential "$bootstrap_run_referential" "$key" "$value" \
  || tryMutateReferential "$image_build_referential" "$key" "$value" \
  || tryMutateReferential "$image_list_referential" "$key" "$value" \
  || tryMutateReferential "$image_check_referential" "$key" "$value" \
  || tryMutateReferential "$image_info_referential" "$key" "$value" \
  || tryMutateReferential "$image_upgrade_referential" "$key" "$value" \
  || tryMutateReferential "$image_factorize_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_build_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_list_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_check_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_info_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_upgrade_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_start_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_stop_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_volumes_referential" "$key" "$value"

  return $?
}

### mutates the execution context with a key and a value as arguments
tryMutateExecutionContext() {
  local key="$1"
  local value="$2"

  debug "key=$key
value=$value"

  # contextual mutation of the execution environment
  # - modification of global option is context free
  # - modification of the domain is ok only if not already set
  # - modification of domain option ok if domain is set
  # - modification of the command ok if not already set and depends if domain is
  #   set or not => global command or domain command
  # - command options modification can only take place after a command is set
  # as a result, a pair <key value> is used to mutate in order :
  # - global options                                   | more     ^ less
  # - domain                                           | specific | specific
  # - domain options                                   |          |
  # - global command or domain command                 |          |
  # - global command options or domain command options V          |
  #
  # Moreover, mutating global command and domain command are mutually exclusive
  # based on the domain set
  # same thing about global command option and domain command option, makes
  # sense.
  # general logic is following. The deeper you go the more specific you get:
  #
  # try mutate global option
  # `-> success => return 0
  # `-> failure ->
  #     try mutate domain
  #     `-> success => return 0
  #     `-> failure ->
  #         `-> try mutate domain option
  #             `-> success => return 0
  #             `-> failure ->
  #                 try mutate global command
  #                 `-> success => return 0
  #                 `-> failure ->
  #                     `-> try mutate domain command
  #                         `-> success => return 0
  #                         `-> failure ->
  #                             `-> try mutate global command options
  #                                 `-> success => return 0
  #                                 `-> failure ->
  #                                     try mutate domain command options
  #                                     `-> success => return 0
  #                                     `-> failure => return 1

  # chaining mutators by specificity order
  tryMutateGlobalOptions "$key" "$value" \
  || tryMutateDomain "$key" "$value" \
  || tryMutateDomainOptions "$key" "$value" \
  || tryMutateGlobalCommand "$key" "$value" \
  || tryMutateDomainCommand "$key" "$value" \
  || tryMutateGlobalCommandOptions "$key" "$value" \
  || tryMutateDomainCommandOptions "$key" "$value"

  return $?
}

### internal function attempting to mutate the execution context with a provided
### argument of the form key=value
tryMutateExecutionContextWithKeyEqualsValueArg() {
  if ! isPair "$1"; then
    debug 'A pair is needed here. '"$1"' is not a pair'
    return 1
  fi

  local key="$(keyOf "$1")"
  local value="$(valueOf "$1")"

  debug "key=$key
value=$value"

  tryMutateExecutionContext "$key" "$value"

  return $?
}

### build the final execution context regarding provided arguments
buildExecutionContextFromArguments() {
  info 'attempting to mutate the execution context with provided arguments'

  # the arguments provided could take 2 different forms :
  # - simple switch
  # - key-value pair
  # The simple switch may have the dashed or double dashed form
  # The key-value pair may have the space or the '=' as separator. A space
  # character could be specified more than once. This is not the case for the
  # '=' character separator.

  # description of the algorithm:
  # As arguments may take several forms that are parsed differently, the
  # behavior of the algorithm depends of the form of the argument.
  # The most deterministic form is the key=value form.
  # Thus, the algorithm will attempt to mutate the execution context trying to
  # extract key and value from the next argument.
  # If the key/value extraction fails, the algorithm will try to mutate the
  # execution context with the next argument as if it had the dashed or double
  # dashed form. If it fails, the algorithm will attempt to extract the next
  # argument and consider it as the value of the previous one (that is the key
  # therefore)

  local result=1
  local extractedKeyFromArg=

  local arg=
  for arg in $@; do
    debug 'current parsed argument : '"$arg"

    if [ -z "$extractedKeyFromArg" ]; then
      if tryMutateExecutionContextWithKeyEqualsValueArg "$arg"; then
        debug 'key=value args successfully altered the execution context'

        result=0
        continue
      fi

      if tryMutateExecutionContext "$arg"; then
        debug 'single arg successfully altered the execution context'

        result=0
        continue
      fi

      debug 'mutation failed with arg: '"$arg"' continuing...'
      extractedKeyFromArg="$arg"

      result=1
    else
      if tryMutateExecutionContext "$extractedKeyFromArg" "$arg"; then
        debug 'key value args successfully altered the execution context'

        result=0
      else
        debug "$(cat << EOI
Failed to modify the execution context with key: $extractedKeyFromArg and
value: $arg
EOI
        )"

        result=1
      fi

      extractedKeyFromArg=
    fi
  done

  return $result
}

### helper function executing the help command with its options if required
executeHelpCommand() {
  if [ "$COMMAND" = 'help' ]; then
    info 'help command has been requested'

    local mode="$GLOBAL_COMMAND_HELP_OPTION_MODE"
    [ "$mode" = '-H' ] || [ "$mode" = '--full' ]
    local fullMode=$?

    if [ "$fullMode" -eq 0 ]; then
      info 'full mode help requested'
      usageFull 
    else
      info 'brief mode help requested'
      usage
    fi
  else
    info 'help was not the requested command'
    return 1
  fi

  return 0
}

### helper function executing the info command with its options if required
executeInfoCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### helper function executing the install command with its options if required
executeInstallCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### helper function executing the pack command with its options if required
executePackCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### helper function executing the unpack command with its options if required
executeUnpackCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### helper function executing the vagrant command with its options if required
executeVagrantCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the check command of the bootstrap domain
executeBootstrapCheckCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the check command of the bootstrap domain
executeBootstrapRunCommand() {
  # TODO handle options, draft version
  if [ "$DOMAIN" = 'bootstrap' ] \
     && [ "$COMMAND" = 'run' ]; then
    info 'bootstrap run requested'

    bootstrap_run

    return $?
  fi

  return 1
}

### execute the build command of the image domain
executeImageBuildCommand() {
  # TODO handle options, incomplete
  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'build' ] \
     || [ -z "$DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE" ]; then
    info "incomplete or incorrect execution context:
  DOMAIN=$DOMAIN
  COMMAND=$COMMAND
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE"
    return 1
  fi

  info 'splitting provided sequence using space character'
  local sequence="$(
    splitSequence \
    "$DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE" \
    ','
  )" \
  && sequence="$(makeUnique "$sequence")" \
  || return $?

  debug 'image sequence to build :'"$sequence"

  # build each image in the sequence, calling the right script in a subshell
  local image=
  for image in $sequence; do
    debug 'calling image_build '"$image"

    image_build "$image" \
    || return $?
  done

  return 0
}

### execute the list command of the image domain
executeImageListCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the check command of the image domain
executeImageCheckCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the info command of the image domain
executeImageInfoCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the upgrade command of the image domain
executeImageUpgradeCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the factorize command of the image domain
executeImageFactorizeCommand() {
  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'factorize' ] \
     || [ -z "$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME" ] \
     || [ -z "$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE" ]; then
    info "incomplete or incorrect execution context:
incomplete or incorrect execution context:
  DOMAIN=$DOMAIN
  COMMAND=$COMMAND
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE"
    return 1
  fi

  # call the feature
  image_factorize

  return $?
}

### execute the build command of the appliance domain
executeApplianceBuildCommand() {
  # TODO handle options, incomplete
  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'build' ] \
     || [ -z "$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE" ]; then
    info "incomplete or incorrect execution context:
  DOMAIN=$DOMAIN
  COMMAND=$COMMAND
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE"
    return 1
  fi

  # the sequence is comma separated, get it space separated
  local sequence="$(
    splitSequence \
    "$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE" \
    ','
  )" \
  && sequence="$(makeUnique "$sequence")" \
  || return $?

  debug 'appliance sequence to build: '"$sequence"

  # build each appliance in the sequence, calling the right script in a subshell
  local appliance=
  for appliance in $sequence; do
    debug 'calling appliance_manage '"$appliance"

    ( appliance_manage "$appliance" ) \
    || return $?
  done

  return 0
}

### execute the list command of the appliance domain
executeApplianceListCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the check command of the appliance domain
executeApplianceCheckCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the info command of the appliance domain
executeApplianceInfoCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the upgrade command of the appliance domain
executeApplianceUpgradeCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the start command of the appliance domain
executeApplianceStartCommand() {
  # TODO handle options, incomplete
  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'start' ] \
     || [ -z "$DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE" ]; then
    info "incomplete or incorrect execution context:
  DOMAIN=$DOMAIN
  COMMAND=$COMMAND
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE"
    return 1
  fi

  # the sequence is comma separated, get it space separated
  local sequence="$(
    splitSequence \
    "$DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE" \
    ','
  )" \
  && sequence="$(makeUnique "$sequence")" \
  || return $?

  debug 'appliance sequence to start: '"$sequence"

  # build each appliance in the sequence, calling the right script in a subshell
  local appliance=
  for appliance in $sequence; do
    debug 'calling appliance_manage '"$appliance"

    ( appliance_manage "$appliance" ) \
    || return $?
  done

  return 0
}

### execute the stop command of the appliance domain
executeApplianceStopCommand() {
  # TODO handle options, incomplete
  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'stop' ] \
     || [ -z "$DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE" ]; then
    info "incomplete or incorrect execution context:
  DOMAIN=$DOMAIN
  COMMAND=$COMMAND
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE"
    return 1
  fi

  # the sequence is comma separated, get it space separated
  local sequence="$(
    splitSequence \
    "$DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE" \
    ','
  )" \
  && sequence="$(makeUnique "$sequence")" \
  || return $?

  debug 'appliance sequence to stop: '"$sequence"

  # build each appliance in the sequence, calling the right script in a subshell
  local appliance=
  for appliance in $sequence; do
    debug 'calling appliance_manage '"$appliance"

    ( appliance_manage "$appliance" ) \
    || return $?
  done

  return 0
}

### execute the volumes command of the appliance domain
executeApplianceVolumesCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### helper function executing the specified bootstrap command
executeBootstrapCommand() {
  info 'attempting to execute one bootstrap command one after another'

  executeBootstrapCheckCommand \
  || executeBootstrapRunCommand

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && info 'failed to execute bootstrap command'

  return $returnCode
}

### helper function executing the specified image command
executeImageCommand() {
  info 'attempting to execute one image command one after another'

  executeImageBuildCommand \
  || executeImageListCommand \
  || executeImageCheckCommand \
  || executeImageInfoCommand \
  || executeImageUpgradeCommand \
  || executeImageFactorizeCommand

  local returnCode=$?

  [ $returnCode -ne 0 ] \
    && info 'failed to execute image command'

  return $returnCode
}

### helper function executing the specified apliance command
executeApplianceCommand() {
  info 'attempting to execute one appliance command one after another'

  executeApplianceBuildCommand \
  || executeApplianceListCommand \
  || executeApplianceCheckCommand \
  || executeApplianceInfoCommand \
  || executeApplianceUpgradeCommand \
  || executeApplianceStartCommand \
  || executeApplianceStopCommand \
  || executeApplianceVolumesCommand

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && info 'failed to execute appliance command'

  return $returnCode
}

### helper function executing one global command if specified
executeGlobalCommand() {
  info 'Attempting to execute one global command one after another'

  executeHelpCommand \
  || executeInfoCommand \
  || executeInstallCommand \
  || executePackCommand \
  || executeUnpackCommand \
  || executeVagrantCommand

  local returnCode=$?

  [ $returnCode -ne 0 ] \
    && info 'failed to execute global command'

  return $returnCode
}

### helper function executing one domain command if specified
executeDomainCommand() {
  info 'attempting to execute one command from all domains one after another'

  executeBootstrapCommand \
  || executeImageCommand \
  || executeApplianceCommand

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && info 'failed to execute executeDomainCommand'

  return $returnCode
}

### Helper function activating the trace mode if requested (--log-level=trace)
### and executing this script from its very start
# TODO: repair trace mode
executeWithTraceIfRequested() {
  if isTraceLogLevel \
     && [ ! ${TRACE_ENABLED+0} ]; then
    debug 'trace enabled; restarting script...'

    local carrier_code="$(
      sed '2i\set -x' "${CARRIER_SCRIPT_PATH}"
    )"

    local carrier_script="${CARRIER_TMP_DIR}"/carrier

    echo "$carrier_code" > "$carrier_script"
    chmod +x "$carrier_script"

    ( TRACE_ENABLED= exec "$carrier_script" "$@" )

    local returnCode=$?
    debug 'script execution finished, exiting with status code :'$returnCode
    exit $returnCode
  fi

  return 0
}

### Once the execution context is set, execute the script using it. As the
### execution context is verified when set, one function must succeed
executeWithContext() {
  info 'executing carrier with setup context'

  debug "Execution Context:
$(debugOutputExecutionContext)"

  executeGlobalCommand \
  || executeDomainCommand

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'Failed to execute carrier with current execution context'

  return $returnCode
}

#### Execution context mutator definition area #################################

### Mutator to set the log level. Valid call in any circumstances
contextSetLogLevel() {
  info 'setting log level global option'

  # key/value pair
  GLOBAL_OPTION_LOG_LEVEL="$2"

  return 0
}

### Mutator to set the log output. Valid call in any circumstances
contextSetLogOutput() {
  info 'setting log output global option'

  # key/value pair
  GLOBAL_OPTION_LOG_OUTPUT="$2"

  return 0
}

### Mutator to set a global command. Valid call if:
### - no domain specified
contextSetGlobalCommand() {
  info 'setting global command'

  if [ ! -z "$DOMAIN" ]; then
    info 'A domain name must not be specified to set the '"$1"' global command'
    return 1
  fi

  # the key specified (first argument) is the command
  COMMAND="$1"

  return 0
}

### mutator to set the help mode. Valid call if:
### - command is 'help'
contextSetHelpMode() {
  info 'setting help mode'

  if [ ! "$COMMAND" = 'help' ]; then
    info "$(cat << EOI
contextSetHelpMode() can only be used when specified command is help
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  # the key (first value) is the help mode
  GLOBAL_COMMAND_HELP_OPTION_MODE="$1"

  return 0
}

### mutator to set the domain. Valid call if:
### - no global command specified sooner
contextSetDomain() {
  info 'setting domain'

  # empty domain and non empty command denotes a global command specified sooner
  if [ -z "$DOMAIN" ] \
     && [ ! -z "$COMMAND" ]; then
    info "$(cat << EOI
contextSetDomain() can only be used if domain and command are unspecified
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  # the specified key (first arg) is the domain
  DOMAIN="$1"

  return 0
}

### mutator to setup the bootstrap command. Valid call if:
### - domain is bootstrap
contextSetBootstrapCommand() {
  info 'setting bootstrap command'

  if [ ! "$DOMAIN" = 'bootstrap' ]; then
    info "$(cat << EOI
contextSetBootstrapCommand() can only be called if DOMAIN is bootstrap
  current DOMAIN=$DOMAIN
EOI
    )"
    return 1
  fi

  # the specified key (first arg) is the bootstrap command
  COMMAND="$1"

  return 0
}

### mutator to setup the image command. Valid call if:
### - domain is image
contextSetImageCommand() {
  info 'setting image command'

  if [ ! "$DOMAIN" = 'image' ]; then
    info "$(cat << EOI
contextSetImageCommand() can only be called if domain is image
  current DOMAIN=$DOMAIN
EOI
    )"
    return 1
  fi

  # the specified key (first arg) is the image command
  COMMAND="$1"

  return 0
}

### mutator to setup the sequence of image to build. Valid call if:
### - domain is image
### - command is build
contextSetImageBuildImageSequence() {
  info 'setting image build image sequence'

  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'build' ]; then
  info "$(cat << EOI
contextSetImageBuildImageSequence() can only be used when the domain is image
and the command is build.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
  )"
    return 1
  fi

  # the key (first arg) is the image sequence
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE="$1"

  return 0
}

### TODO NYI
contextSetImageListOnlyLocal() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageInfoImage() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageListOnlyNotBuilt() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageUpgradeImageSequence() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageCheckImageSequence() {
  :

  debug 'Not Implemented Yet'
  return 1
}

contextSetImageFactorizeBaseImagePrefix() {
  info 'setting image factorize base image prefix'

  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'factorize' ]; then
  info "$(cat << EOI
contextSetImageFactorizeBaseImagePrefix() can only be used when the domain is
image and the command is factorize.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
  )"
    return 1
  fi

  # the prefix is the second argument
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_PREFIX="$2"

  return 0
}

contextSetImageFactorizeFactorizedImagePrefix() {
  info 'setting image factorize factorized image prefix'

  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'factorize' ]; then
  info "$(cat << EOI
contextSetImageFactorizeFactorizedImagePrefix() can only be used when the
domain is image and the command is factorize.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
  )"
    return 1
  fi

  # the prefix is the second argument
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_FACTORIZED_IMAGE_PREFIX="$2"

  return 0
}

contextSetImageFactorizeBaseImageName() {
  info 'setting image factorize base image name'

  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'factorize' ]; then
  info "$(cat << EOI
contextSetImageFactorizeBaseImageName() can only be used when the domain is
image and the command is factorize.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
  )"
    return 1
  fi

  # the image name is the second argument
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME="$2"

  return 0
}

contextSetImageFactorizeImageSequence() {
  info 'setting image factorize image sequence'

  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'factorize' ]; then
  info "$(cat << EOI
contextSetImageFactorizeImageSequence() can only be used when the domain is
image and the command is factorize.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
  )"
    return 1
  fi

  # the image sequence is the second argument
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE="$2"

  return 0
}

contextSetImageFactorizeRemoveOriginalImages() {
  info 'setting image factorize remove original images flag'

  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'factorize' ]; then
  info "$(cat << EOI
contextSetImageFactorizeRemoveOriginalImages() can only be used when the domain
is image and the command is factorize.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
  )"
    return 1
  fi

  # no value here
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_REMOVE_ORIGINAL_IMAGES='yes'

  return 0
}

### mutator to setup the appliance command. Valid call if:
### - domain is appliance
contextSetApplianceCommand() {
  info 'setting appliance command'

  if [ ! "$DOMAIN" = 'appliance' ]; then
    info "$(cat << EOI
contextSetApplianceCommand() can only be called if domain is appliance
  current DOMAIN=$DOMAIN
EOI
    )"
    return 1
  fi

  # the specified key (first arg) is the appliance command
  COMMAND="$1"

  return 0
}

### TODO NYI
contextSetApplianceInfoAppliance() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetApplianceListOnlyLocal() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetApplianceVolumesList() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetApplianceListOnlyNotBuilt() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetApplianceStartDontBuild() {
  :

  debug 'Not Implemented Yet'
  return 1
}

contextSetApplianceCheckApplianceList() {
  :

  debug 'Not Implemented Yet'
  return 1
}

contextSetApplianceUpgradeApplianceSequence() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### mutator to setup the sequence of appliance to build. Valid call if:
### - domain is appliance
### - command is build
contextSetApplianceBuildApplianceSequence() {
  info 'setting appliance build appliance sequence'

  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'build' ]; then
    info "$(cat << EOI
contextSetApplianceBuildApplianceSequence() can only be called when domain is
appliance and command is build.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  # the key (first arg) is the appliance sequence
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE="$1"

  return 0
}

### mutator to setup the sequence of appliance to start. Valid call if:
### - domain is appliance
### - command is start
contextSetApplianceStartApplianceSequence() {
  info 'setting appliance start appliance sequence'

  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'start' ]; then
    info "$(cat << EOI
contextSetApplianceStartApplianceSequence() can only be used if domain is
appliance and command is start
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  # the key (first arg) is the appliance sequence
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE="$1"

  return 0
}

### mutator to setup the sequence of appliance to start. Valid call if:
### - domain is appliance
### - command is start
contextSetApplianceStopApplianceSequence() {
  info 'setting appliance stop appliance sequence'

  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'stop' ]; then
    info "$(cat << EOI
contextSetApplianceStopApplianceSequence() can only be used if domain is
appliance and command is stop
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  # the key (first arg) is the appliance sequence
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE="$1"

  return 0
}

#### End of execution context mutator definition area ##########################

#### bootstrap domain specific functions

### simply copy the bootstrap dir from share to a temporary staging area
# TODO : uniform staging area for bootstrap
bootstrap_fetchInStagingArea() {
  info 'Copying bootstrap files in bootstrap staging area...'

  cp -r "$CARRIER_SHARE_BOOTSTRAP_DIR" "$CARRIER_TMP_DIR" \
  || ( returnCode=$? \
       && fatal 'Unabled to copy bootstrap files in staging area.' \
       && return $returnCode )

  return $?
}

### copy useful lib script to the temporary staging area where bootstrap file
### reside
# TODO : uniform staging area for bootstrap
bootstrap_fetchLibInStagingArea() {
  info 'Fetching utility file in bootstrap staging area'

  cp "$CARRIER_LIB_DIR"/exportPackageTo \
     "$CARRIER_LIB_DIR"/importPackageFrom \
     "$CARRIER_LIB_DIR"/functions.sh \
     "$CARRIER_TMP_DIR"/bootstrap \
  || ( returnCode=$? \
       && fatal 'Unabled to copy utilities files in staging area.' \
       && return $returnCode )

  return $?
}

### build the bootstrap docker image responsible to bootstrap the system
bootstrap_build() {
  info 'building bootstrap docker image'

  cd "$CARRIER_TMP_DIR"/bootstrap \
  && docker build --squash -t metabarj0/bootstrap . \
  && docker image prune -f \
  && cd - 1>/dev/null 2>&1 \
  || ( returnCode=$? \
       && fatal 'bootstrap image build failed.' \
       && return $returnCode )

  return $?
}

### ask for some configuration and run the bootstrap image to bootstrap the
### system
bootstrap_run_image() {
  info 'running the bootstrap docker image'

  # TODO : take into account some variable of the execution context (auto answer yes…)
  # TODO: refacto, need some functions

  cat << EOI
Specify the version of GCC you want to build. Note that today, only 7.2.0
and 7.3.0 are supported : [7.3.0]
EOI

  local gcc_version="$(readValueWithDefault '7.3.0')"

  cat << EOI
Specify the binutils version you want to build. Note that for GCC 7.3.0, 2.29
is a working version : [2.29]
EOI

  local binutils_version="$(readValueWithDefault '2.29')"

  cat << EOI
Specify the version of Kernel headers you want to use. Note that for GCC 7.3.0
the 4.14.14 version works perfectly well. Moreover, only version 4+ is
supported : [4.14.14]
EOI

  local kernel_version="$(readValueWithDefault '4.14.14')"

  cat << EOI
Specify the make version you want to use. Note that version 4.2 is
good : [4.2]
EOI

  local make_version="$(readValueWithDefault '4.2')"

  # run the bootstrap image
  docker run --rm -it \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -e GCC_VERSION="$gcc_version" \
    -e BINUTILS_VERSION="$binutils_version" \
    -e KERNEL_VERSION="$kernel_version" \
    -e MAKE_VERSION="$make_version" \
    metabarj0/bootstrap

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'bootstrap image failed to run correctly.' \
  && return $returnCode

  cat << EOI
Bootstrapping successfully done! Would you like to remove the
metabarj0/bootstrap docker image? [Y/n]
EOI

  local remove_bootstrap="$(readValueWithDefault 'Y')"

  if [ $remove_bootstrap = 'Y' ] || [ $remove_bootstrap = 'y' ]; then
    docker rmi metabarj0/bootstrap

    returnCode=$?

    [ $returnCode -ne 0 ] \
    && fatal 'Unabled to remove the bootstrap image.' \
    && return $returnCode
  fi

  return $returnCode
}

### once the system is bootstrapped, clean the staging area
# TODO: uniform staging area mechanics for bootstrap
bootstrap_cleanupStagingArea() {
  info 'cleaning up the bootstrap staging area'

  rm -rf "$CARRIER_TMP_DIR"/bootstrap

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'Unabled to swipe bootstrap files in staging area.'

  return $returnCode
}

### run the full bootstrap procedure
bootstrap_run() {
  info 'Running the bootstrap procedure'

  bootstrap_fetchInStagingArea \
  && bootstrap_fetchLibInStagingArea \
  && bootstrap_build \
  && bootstrap_run_image \
  && bootstrap_cleanupStagingArea

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'bootstrap procedure failed at some point'

  return $returnCode
}
#### End of bootstrap domain specific functions

#### image domain specific functions

### prepare a joined sequence of image to be factorized. The input is a
### sequence joined with ','. The output will be a sequence of images space
### separated.
image_prepareImageSequenceForFactorization() {
  info 'Preparing image sequence value argument'

  local sequence="$(
    splitSequence \
      "$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE" \
      ','
  )" \
  && sequence="$(makeUnique "$sequence")" \
  || return $?

  echo "$sequence"

  return $?
}

### check on the docker host if the image exists.
### $1 image name
image_checkIfExistsOnDockerHost() {
  local image="$1"

  info 'checking if image '"$image"' exists on the docker host'

  local id=$(docker image ls -q "$image") \
  || ( returnCode=$? \
       && fatal 'Could not request image' \
       && return $returnCode ) \
  || return $?

  if [ -z $id ]; then
    error "$(cat << EOI
The specified image "$image" does not exist on the docker host
EOI
    )"
    return 1
  fi

  return 0
}

### extract the content of the image.dist file of the specified docker image.
### The file list is sorted and deduped
### $1 docker image name present on the docker host
image_extractImageDistFileFromImage() {
  info 'Extracting image.dist file content of '"$1"

  local file_sequence="$(
    docker run \
      --rm \
      --entrypoint '' \
      "$1" cat /image.dist \
    | sort \
    | uniq
  )" \
  || return $?

  if [ -z "$file_sequence" ]; then
    fatal "Could not extract the image.dist file from the "$1" docker
image. Is that image well formed?"
    return 1
  fi

  echo "$file_sequence"

  return 0
}

### initialize a shell variable containing a directory id for the factorize
### command staging area
image_initializeFactorizeStagingDirectory() {
  info 'Initializing image factorize staging area'

  if [ ! -z "$DOMAIN_IMAGE_COMMAND_FACTORIZE_STAGING_DIRECTORY" ]; then
    warning 'image factorize staging area is alerady initialized'
    return 0
  fi

  DOMAIN_IMAGE_COMMAND_FACTORIZE_STAGING_DIRECTORY="$(
    image_getStagingRootDirectory
  )"/factorize/"$(generateRandomString)" \
  || return $?

  mkdir -p "$DOMAIN_IMAGE_COMMAND_FACTORIZE_STAGING_DIRECTORY" \
  || fatal 'Could not create image factorize staging directory'
  
  return $?
}

### return the name of the staging directory for the build feature
image_getFactorizeStagingDirectory() {
  info 'getting image factorize staging area directory'

  [ -z "$DOMAIN_IMAGE_COMMAND_FACTORIZE_STAGING_DIRECTORY" ] \
    && error 'Image factorize staging directory has not been initialized' \
    && return 1

  echo "$DOMAIN_IMAGE_COMMAND_FACTORIZE_STAGING_DIRECTORY"

  return $?
}

### create or overwrite files in staging directory for factorize feature
### $1 file name to create/overwrite in staging directory
### $1 content to put in the file
image_addFileInFactorizeStagingAreaWithContent() {
  info 'adding a file in image factorize staging area'

  if [ -z "$1" ] || [ -z "$2" ]; then
    error 'Missing file informations (name or content)'
    return 1
  fi

  local staging_directory="$(image_getFactorizeStagingDirectory)" \
  && mkdir -p "$staging_directory" \
  && echo "$2" > "${staging_directory}"/"$1"

  local returnCode=$?

  [ $returnCode -ne 0 ] \
    && fatal 'could not add file in factorize staging area' \
    && return $returnCode

  return $returnCode
}

### remove temporary files created while factorizing images
image_cleanupFactorizeStagingDirectory() {
  info 'cleaning up the staging area for image factorize command'

  rm -rf "$(image_getFactorizeStagingDirectory)"

  local returnCode=$?

  [ $returnCode -ne 0 ] \
    && fatal 'could not clean up the fatctorize staging directory' \
    && return $returnCode

  removeDirectoryIfEmpty "$(image_getStagingRootDirectory)"

  return $?
}

### initialize the image.dist file of the base image. It will contains common
### files found in the two very first image iterated
# TODO : that one is to refactor
image_initializeBaseImageDistFileInStagingArea() {
  info 'Initializing tha base image of factorization'

  image_initializeImageToFactorizeSequence \
  || return $?

  local image=
  for image in $(image_getImageToFactorizeSequence); do
    [ -z "$first_image" ] \
    && local first_image="$image" && continue \
    || local second_image="$image" && break
  done

  local first_files_sequence="$(
    image_extractImageDistFileFromImage "$first_image"
  )" \
  || return $?

  local second_files_sequence="$(
    image_extractImageDistFileFromImage "$second_image"
  )" \
  ||  return $?

  image_addFileInFactorizeStagingAreaWithContent \
    'first_files_sequence.dist' \
    "$first_files_sequence" \
  && image_addFileInFactorizeStagingAreaWithContent \
    'second_files_sequence.dist' \
    "$second_files_sequence" \
  || return $?

  local common_files_sequence="$(
    extractCommonLinesInTwoFiles \
      "$(image_getFactorizeStagingDirectory)"/first_files_sequence.dist \
      "$(image_getFactorizeStagingDirectory)"/second_files_sequence.dist)" \
  && image_addFileInFactorizeStagingAreaWithContent \
    'base.image.dist' \
    "$common_files_sequence" \
  || return $?

  return $?
}

### initialize the image sequence to factorize in a shell variable
image_initializeImageToFactorizeSequence() {
  info 'initializing image to factorize sequence'

  if [ -z "$DOMAIN_IMAGE_COMMAND_FACTORIZE_IMAGE_TO_FACTORIZE_SEQUENCE" ]; then
    DOMAIN_IMAGE_COMMAND_FACTORIZE_IMAGE_TO_FACTORIZE_SEQUENCE="$(
      image_prepareImageSequenceForFactorization)"
  fi

  return $?
}

### get the image sequence to factorize. Must initialize it before
image_getImageToFactorizeSequence() {
  info 'getting image to factorize sequence'

  [ -z "$DOMAIN_IMAGE_COMMAND_FACTORIZE_IMAGE_TO_FACTORIZE_SEQUENCE" ] \
  && error 'Image to factorize sequence is not initialized' \
  && return 1

  echo "$DOMAIN_IMAGE_COMMAND_FACTORIZE_IMAGE_TO_FACTORIZE_SEQUENCE"

  return $?
}

### finalize the image.dist file of the base image and all images to factorize.
### A first version of base.image.dist file must be present in the staging area
# TODO : refactor that one
image_finalizeAllImageDistFileInStagingArea() {
  info 'finalizing image.dist files'

  local base_image_dist_file="$(
    image_getFactorizeStagingDirectory)"/base.image.dist \
  || return $?

  if [ ! -f "$base_image_dist_file" ]; then
    error 'Missing base.image.dist file in staging area'
    return 1
  fi

  local image=
  for image in $(image_getImageToFactorizeSequence); do
    image_checkIfExistsOnDockerHost "$image" \
    && local image_files_sequence="$(
      image_extractImageDistFileFromImage "$image"
    )" \
    && image_addFileInFactorizeStagingAreaWithContent \
      'image.dist' \
      "$image_files_sequence" \
    && local path64_image_dist_file_name="$(
      path64Encode "$image")".dist \
    && local image_dist_file="$(
      image_getFactorizeStagingDirectory)"/'image.dist' \
    && image_addFileInFactorizeStagingAreaWithContent \
      "$path64_image_dist_file_name" \
      "$(comm \
          -1 -3 \
          "$base_image_dist_file" \
          "$image_dist_file")" \
    && image_addFileInFactorizeStagingAreaWithContent \
      'base.image.dist' \
      "$(comm \
          -1 -2 \
          "$base_image_dist_file" \
          "$image_dist_file")" \
    || return $?
  done
  pause

  return $?
}

### create the image.dist file of the base image in the staging directory
image_createImagesDistFileInStagingDirectory() {
  info 'Creating image dist files in image factorize staging directory'

  image_initializeBaseImageDistFileInStagingArea \
  && image_finalizeAllImageDistFileInStagingArea

  return $?
}

### factorization feature of the image domain
image_factorize() {
  info 'factorizing images'

  image_initializeFactorizeStagingDirectory \
  && image_createImagesDistFileInStagingDirectory \
  && image_cleanupFactorizeStagingDirectory

  return $?
}

### checking image name or image's manifest file path.
image_checkManifestPathOrName() {
  info 'checking manifest file path or name'

  local argument_error_message="$(
  cat << EOI
Error: Bad argument specified.
Expected is either :
- an absolute path to a manifest file of a docker image project located in the
  docker/share/images directory
- a relative path from your current directory to a manifest file of a docker
  image project located in the docker/share/images directory
- the name of the directory of the docker image project you want to build,
  located in the docker/share/images directory

Taking theses remarks into account should help you to resolve your
problem
EOI
  )"

  # This script needs one argument: either
  #  - an absolute path to a manifest file
  #  - a relative path to a manifest file
  #  - a valid docker image name which can be found in the share/image directory
  if [ ! $# -eq 1 ]; then
    error "$argument_error_message"
    return 1
  fi

  # try to resolve the manifest file path by:
  #  - appending it to the current user directory, useful if relative path is
  #    provided
  #  - testing directly the file path, useful if absolute path is provided
  local manifest_arg="$1"
  if [ ! -f ${USER_DIRECTORY}/"$manifest_arg" ] \
     && [ ! -f "$manifest_arg" ]; then
    # not a file path, testing the image name
    manifest_arg=${CARRIER_SHARE_IMAGES_DIR}/"$1"/manifest
    if [ ! -f ${manifest_arg} ]; then
      error "$argument_error_message"
      return 1
    fi
  fi

  # OK, valid argument, exposing the manifest file absolute path
  MANIFEST_FILE_PATH=${manifest_arg}

  return $?
}

### look for the existence of foundation images on the docker host. If this
### check fails, no build is possible.
image_checkBootstrapImages() {
  info 'checking all bootstrap built images'

  # first, verify if bootstrap has built all necessary foundation images, that
  # is metabarj0/manifest, metabarj0/gcc, metabarj0/make and
  # metabarj0/docker-cli and alpine/wget
  local required_images="$(
  cat << EOI
metabarj0/manifest
metabarj0/gcc
metabarj0/make
metabarj0/docker-cli
alpine/wget
EOI
  )"

  for i in $required_images; do
    id=$(docker image ls -q $i)
    if [ -z $id ]; then
      error "$(cat << EOI
Error: the mandatory image "$i" has not been found on your docker host. Make
sure you have properly bootstrapped your docker host before attempting any
image build
EOI
)"
      return 1
    fi
  done

  return $?
}

### check for the existence of zll dependencies of the image requested to be
### built and attempt to build them if they are not present on the docker host.
image_buildDependencies() {
  info 'image build building dependencies'

  # browse all dependencies
  for dep in $REQUIRES; do
    # first, check on the host if the image exists; if so, continue without
    # building it
    local repository=$(docker image ls -q "$dep")
    if [ ! -z "$repository" ]; then
      info 'image '"$dep"' found on the docker host...continuing...'
      continue
    fi

    # no existing image found on the host, building it, the current directory
    # being the image staging directory, there must be a docker directory to
    # look into from the global docker tmp directory
    # TODO : rethink how manifest is found : source variables instead sed-ing
    #        it. Allows user to define its PROVIDES variable using any form
    #        that is valid in shell
    local dependency_manifest=$(
      find ${FETCHED_MANIFEST} \
        -name manifest \
        -exec \
          grep -EH 'PROVIDES='$dep'$' {} \; \
          | sed -E 's/^([^:]+):.+/\1/'
    )

    # transform dependency_manifest to be just the image name
    local dependency_manifest_dir=$(dirname $dependency_manifest)
    dependency_manifest=$(basename $dependency_manifest_dir)

    local this_script_name=$(basename $0)
    local this_script_path=${DOCKER_BIN_DIRECTORY}/$this_script_name

    # calling in a sub-shell, isolating shell variables from each other
    ( image_build "$dependency_manifest" )

    local returnCode=$?

    [ $returnCode -ne 0 ] \
    && error 'Failed to build image targeted by '"$dependency_manifest" \
    && return $returnCode
  done

  return $?
}

### gives the root directory of staging area used for image domain commands
image_getStagingRootDirectory() {
  info 'getting root staging directory'

  echo "${CARRIER_TMP_DIR}"/image
  return $?
}

### initialize a shell variable containing a directory id for the build command
### staging area
image_initializeImageBuildStagingDirectory() {
  info 'initializing image build staging directory'

  if [ ! -z "$DOMAIN_IMAGE_COMMAND_BUILD_STAGING_DIRECTORY" ]; then
    warning 'image build staging already initialized'
    return 0
  fi

  DOMAIN_IMAGE_COMMAND_BUILD_STAGING_DIRECTORY="$(
    image_getStagingRootDirectory
  )"/build/"$(generateRandomString)" \
  || return $?

  mkdir -p "$DOMAIN_IMAGE_COMMAND_BUILD_STAGING_DIRECTORY" \
  || fatal 'Could not create image build staging directory'
  
  return $?
}

### return the name of the staging directory for the build feature
image_getImageBuildStagingDirectory() {
  info 'getting image build staging directory'

  [ -z "$DOMAIN_IMAGE_COMMAND_BUILD_STAGING_DIRECTORY" ] \
  && error 'Image build staging directory has not been initialized' \
  && return 1

  echo "$DOMAIN_IMAGE_COMMAND_BUILD_STAGING_DIRECTORY"

  return $?
}

### fill the staging area with file necessary to build the image and its
### dependencies
image_fillImageBuildStagingArea() {
  info 'filling image build staging area'

  local image_directory="$(dirname $MANIFEST_FILE_PATH)" \
  || ( returnCode=$? \
       && fatal 'Could not get the image directory name' \
       && return $returnCode ) \
  || return $?

  local staging_directory="$(image_getImageBuildStagingDirectory)" \
  || return $?

  # copy the project in the staging area
  cp -a "$image_directory" "$staging_directory" \
  || ( returnCode=$? \
       && fatal 'could not copy image files to staging area' \
       && return $returnCode ) \
  || return $?

  # copy necessary lib files in the project directory in the staging area
  local image_name=$(basename $image_directory)
  DOMAIN_IMAGE_COMMAND_BUILD_IMAGE_STAGING_DIRECTORY=\
"${staging_directory}"/"$image_name" \
  || ( returnCode=$? \
       && fatal 'Could not get the image name' \
       && return $returnCode ) \
  || return $?

  cd $CARRIER_LIB_DIR \
  && cp \
    .dockerignore \
    build-image.sh \
    build.sh \
    Dockerfile.build-image \
    exportPackageTo \
    functions.sh \
    importPackageFrom \
    $DOMAIN_IMAGE_COMMAND_BUILD_IMAGE_STAGING_DIRECTORY \
  && cd $USER_DIRECTORY \
  || ( returnCode=$? \
       && fatal 'could not copy utility files to staging area' \
       && return $returnCode )

  return $?
}

### attempt to build the image and all of its dependencies
image_buildImageAndDependencies() {
  # source the content of the manifest file, that will initialize some useful
  # variables
  . $MANIFEST_FILE_PATH

  # build all dependencies of this project first if there are
  if [ ! -z "$REQUIRES" ]; then
    info 'fetching genuine carrier repository...'

    fetchManifestImageContent \
      $DOMAIN_IMAGE_COMMAND_BUILD_IMAGE_STAGING_DIRECTORY \
    && image_buildDependencies \
    || return $?
  fi

  # rely on some variables extracted from the manifest file that was parsed
  (
    exec \
      ${DOMAIN_IMAGE_COMMAND_BUILD_IMAGE_STAGING_DIRECTORY}/build.sh \
      $PROVIDES \
      $DOMAIN_IMAGE_COMMAND_BUILD_IMAGE_STAGING_DIRECTORY \
      "$SOURCES_FETCH_IMAGE" \
      "$SOURCES_FETCH_COMMAND" \
      "$SOURCES_TARBALL_NAME" \
      "$REQUIRES" \
      "$BUILD_EXTRA_DOCKERFILE_COMMANDS" \
      "$BASE_IMAGE" \
      "$FINAL_EXTRA_DOCKERFILE_COMMANDS"
  )

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'could not build image providing '"$PROVIDES" \
  && return 1

  return 0
}

### when the build is complete, cleanup the staging area
image_cleanupBuildStagingArea() {
  info 'cleaning up the staging area for image build command'

  rm -rf \
    "$DOMAIN_IMAGE_COMMAND_BUILD_IMAGE_STAGING_DIRECTORY" \
  || ( returnCode=$? \
       && fatal 'could not clean image build staging area' \
       && return $returnCode ) \
  || return $?

  removeDirectoryIfEmpty "$(image_getStagingRootDirectory)"

  return $?
}

### entrypoint for carrier image build... may be called recursively in case of
### dependency image building
### accept an image name or a manifest file path
image_build() {
  info 'building image'

  image_checkBootstrapImages \
  && image_checkManifestPathOrName "$1" \
  && image_initializeImageBuildStagingDirectory \
  && image_fillImageBuildStagingArea \
  && image_buildImageAndDependencies \
  && image_cleanupBuildStagingArea

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'image build failed at some point'

  return $returnCode
}
#### End of image domain specific functions

#### appliance domain specific functions

### source and validate (or invalidate) the appliance's manifest file. Ensure
### all mandatory variables are set. This is not a deep validation, this
### functions only verify the exposition of a global variable.
appliance_shallowValidateManifestFile() {
  info 'quick validating appliance manifest file'

  # first, source the manifest file
  . "$MANIFEST_FILE_PATH"

  # then, testing mandatory variables existence
  if [ -z "$COMPOSE_BUILD_CONTEXT" ]; then
    error "$(cat << EOI
The appliance's manifest file is ill formed as it lacks one mandatory variable
values.
In order to build an appliance, you must provide a value for the following
mandatory variable :

  COMPOSE_BUILD_CONTEXT

This variable maps a service's image name (in your docker-compose.yml file)
and a function name (defined in the manifest file). With these elements, the
appliance management system will be able to generate a Dockerfile for each
service of your appliance and build this image.

Taking into account this remark should help you to resolve your
problem
EOI
    )"
    return 1
  fi

  # shallow validation complete, the appliance name is gotten, assuming all is
  # OK so far
  APPLIANCE_NAME="$(basename "$(dirname "$MANIFEST_FILE_PATH")")" \
  || fatal 'could not get the appliance name'

  return $?
}

### check the argument provided by the user to this script. Ensure that
### arguments are correct before going any further
appliance_checkArgument() {
  info 'checking argument of the appliance domain invocation'

  # try to resolve the manifest file path by:
  #  - appending it to the current user directory, useful if relative path is
  #    provided
  #  - testing directly the file path, useful if absolute path is provided
  # TODO : refactor that, same mechanics for image building
  local manifest_arg="$1"
  if [ ! -f "${USER_DIRECTORY}"/"$manifest_arg" ] \
     && [ ! -f "$manifest_arg" ]; then
    # not a file path, testing the appliance name
    manifest_arg="${CARRIER_SHARE_APPLIANCES_DIR}"/"$manifest_arg"/manifest
    if [ ! -f "${manifest_arg}" ]; then
      error 'invalid manifest file path or appliance name specified'
      return 1
    fi
  fi

  # OK, valid argument, exposing the manifest file absolute path
  MANIFEST_FILE_PATH="${manifest_arg}"

  return $?
}

### put all necessary files intor the being built appliance staging directory.
appliance_fillStagingArea() {
  # TODO : take a look at filling staging area in the image build feature to see if a refacto could be done
  info 'filling appliance staging area'

  # create the intermediate appliance directory in the staging area if it does
  # not already exist
  local appliance_directory="$(dirname "$MANIFEST_FILE_PATH")" \
  && local staging_directory=${CARRIER_TMP_DIR}/appliances \
  && APPLIANCE_STAGING_DIRECTORY="${staging_directory}"/"$APPLIANCE_NAME" \
  || ( returnCode=$? \
       && error 'Could not setup appliance staging directory' \
       && return $returnCode ) \
  || return $?

  # sanitize the staging area if it does already exist
  rm -rf "$APPLIANCE_STAGING_DIRECTORY" \
  && mkdir -p "$staging_directory" \
  && cp -a "$appliance_directory" "$staging_directory" \
  || ( returnCode=$? \
       && error 'could not copy appliance files into staging area' \
       && return $returnCode )

  # copy necessary lib files in the project directory in the staging area
  cd "$CARRIER_LIB_DIR" \
  && cp \
    .dockerignore \
    exportPackageTo \
    functions.sh \
    importPackageFrom \
    "$APPLIANCE_STAGING_DIRECTORY" \
  && cd "$USER_DIRECTORY" \
  || fatal 'could not copy utility files into staging area'

  return $?
}

### fetch a copy of the master branch of the carrier directory then, copy the
### entire docker directory into the staging directory. This manifest is used
### to build various dependencies and serve as a genuine repository.
# TODO: refacto!
appliance_fetchManifest() {
  info 'fetching manifest for appliance command execution'

  # use the metabarj0/manifest docker image that MUST exist
  local manifest_image="$(
    docker image ls --format='{{.Repository}}' metabarj0/manifest)"

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'could not locate metabarj0/manifest image on the docker host' \
  && return $returnCode

  if [ -z "$manifest_image" ]; then
    error "$(cat << EOI
Error: cannot find the metabarj0/manifest docker image on your docker host. This
image is built by the bootstrap process.
Possible causes are :

  - you did not bootstrap your system. See bootstrap documentation.
  - you accidentally (or not) removed or untagged the metabarj0/bootstrap docker
    image.

Taking these remarks into account should help you to resolve your
problem
EOI
    )"
    return 1
  fi

  # call to a functions.sh's utility
  fetchManifestImageContent "$APPLIANCE_STAGING_DIRECTORY"

  return $?
}

### build an image that is required for the appliance and that was not found on
### the docker host. Relies on the image build system.
appliance_buildDependentImage() {
  info 'building appliance dependent images'

  # uses the metabarj0/manifest container to build required images. It'll result
  # in the creation of a docker directory inside the appliance staging directory
  appliance_fetchManifest \
  || return $?

  local required_image_name="$1"

  # look for the manifest file providing this image, in genuine location, the
  # fetched manifest
  # TODO : same remark in build image system : source the variable value
  #        instead of sed-ing it
  local image_manifest_path="$(
    find "$FETCHED_MANIFEST" \
      -type f \
      -name manifest \
      -exec grep -EH 'PROVIDES='"$required_image_name"'$' {} \; \
      | sed -E 's/(.+):.*$/\1/')"

  if [ -z "$image_manifest_path" ]; then
    error "$( cat << EOI
Error: cannot find a suitable project to build the "$required_image_name".
Possible causes are :

  - mis-spelled required image name
  - project does not exist in the docker/share/images directory
  - project exists in your local copy of the docker/share/images directory but
    not on the distant repository that is fetched to build your dependent image
  - project is an image provided by the bootstrap process and
    your system is not bootstrapped. Such images are metabarj0/gcc,
    metabarj0/make... See bootstrap documentation for more details
  - The project exists on the distant repository and has all the necessary to be
    built BUT the 'PROVIDES' variable in the manifest file is not defined on an
    unique line (use the '\\' character after '=' for instance).

Taking these remarks into account should help you to solve you
problem
EOI
    )"

    return 1
  fi

  # I've the absolute path of the required image's manifest file, let's build it
  # in a new sub-shell
  ( ${CARRIER_BIN_DIR}/carrier image build "$image_manifest_path" ) \
  || ( returnCode=$? \
       && error 'could not build the dependent image targeted by '\
"$image_manifest_path" \
       && return $returnCode )

  return $?
}

### enumerates all required images needed by the appliance and build them if
### they are not on the docker host
appliance_checkRequiredImages() {
  info 'Checking required images for appliance'

  # manifest file read and validated, check existing images and attempt build
  # them if necessary
  local image=
  for image in $REQUIRED_IMAGES; do
    local image_name="$(
      docker image ls --format='{{.Repository}}' $image)"

    local returnCode=$?
    [ $returnCode -ne 0 ] \
    && fatal 'could not request '"$image"' on the docker host' \
    && return $returnCode

    # image does not exist on the docker host
    if [ -z "$image_name" ]; then
      appliance_buildDependentImage "$image" \
      || return $?
    fi
  done

  return 0
}

### Generate the entire Dockerfile of an image of the appliance, relying on the
### content of the manifest file and values computed by the process of
### appliance building.
appliance_compileDockerfile() {
  info 'compiling appliance docker file'

  # TODO refactor this function by breaking it in more atomic parts
  # create a map between image used in build stages and their alias that will be
  # used later
  local names_aliases_map="$(
    mapImageNamesAndBuildStageAliases "$REQUIRED_IMAGES"
    )" \
    || return $?

  # create a Dockerfile in the appliance staging directory. Using required image
  # specified in the manifest as well as other variables :
  local dependencies_build_stages=
  local build_stage=
  local pair=
  local name=
  local alias=
  for pair in $names_aliases_map; do
    # extract image name and build stage alias
    name="$(keyOf "$pair")" \
    && alias="$(valueOf "$pair")"

    # instruction to export the dependency image package
    build_stage="$(cat << EOI
FROM $name as $alias
USER root:root
RUN exportPackageTo /tmp/package
EOI
    )"

    # group these instructions together
    dependencies_build_stages="$(
      append "$dependencies_build_stages" \
             "$build_stage" \
             $'\n'
    )" \
    || return $?
  done

  # copy tooling to extract dependencies' packages
  local appliance_build_stage="$(cat << EOI
FROM $BASE_IMAGE as final
RUN mkdir -p /usr/local/bin/
COPY importPackageFrom /usr/local/bin
EOI
  )"

  # import each dependency image package
  local appliance_image_imports=
  local dependency_import=
  for pair in $names_aliases_map; do
    # extract build stage alias
    alias="$(valueOf "$pair")"

    # create import instruction for each dependency
    dependency_import="$(cat << EOI
COPY --from=$alias /tmp/package /tmp/
RUN importPackageFrom /tmp/package
EOI
    )"

    # aggregate them
    appliance_image_imports="$(
      append "$appliance_image_imports" \
             "$dependency_import" \
             $'\n'
      )" \
      || return $?
  done

  # final step, create the Dockerfile and appending the
  # EXTRA_DOCKERFILE_COMMANDS
  cat << EOI > "${APPLIANCE_STAGING_DIRECTORY}"/Dockerfile
$dependencies_build_stages
$appliance_build_stage
$appliance_image_imports
RUN rm /usr/local/bin/importPackageFrom
$EXTRA_DOCKERFILE_COMMANDS
EOI

  return $?
}

### create the service's docker image on the docker host using the generated
### Dockerfile
appliance_buildServiceImage() {
  info 'Building appliance service image'

  # now we have a dockerfile, we just have to use it to build the appliance
  # image, go to the build context

  # build a squashed image, docker compose can't do that yet
  # then cleanup intermediate images, docker compose don't do that yet
  cd "$APPLIANCE_STAGING_DIRECTORY" \
  && docker build --squash -t "$IMAGE_NAME" . \
  && docker image prune -f \
  && cd "$USER_DIRECTORY"

  local returnCode=$?
  [ $returnCode -ne 0 ] \
  && fatal 'could not build service '"$IMAGE_NAME" \
  && return $returnCode

  return 0
}

### cleanup the appliance staging area when the build is complete
appliance_cleanupStagingArea() {
  if [ -d "$APPLIANCE_STAGING_DIRECTORY" ]; then
    rm -rf "$APPLIANCE_STAGING_DIRECTORY" \
    || ( returnCode=$? \
         && error 'could not remove appliance staging directory' \
         && return $returnCode ) \
    || return $?
  fi

  if [ -z "$(ls "${CARRIER_TMP_DIR}"/appliances)" ]; then
    rm -r "${CARRIER_TMP_DIR}"/appliances \
    || ( returnCode=$? \
         && error 'could not remove appliance staging directory' \
         && return $returnCode ) \
    || return $?
  fi

  return 0
}

### source the specified function, exposing global variables useful to build a
### service image.
### $1 : function name
appliance_callBuildContextFunction() {
  info 'calling build context function '"$1"

  # execute the function
  "$1"

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'the build context function '"$1"' returned in error' \
  && return $returnCode

  # verify the presence of a mandatory variable, that must be defined by the
  # function execution
  if [ -z "$BASE_IMAGE" ]; then
    error "$(cat << EOI
Error: the BASE_IMAGE variable is not set.
This variable is mandatory to build your service image as it is the name of the
base image.

This variable must be exposed in the body of your build context function inside
the manifest file of your appliance.

Note that this variable must be global as a local variable has no definition
outside its function scope.

Taking this remark into account should help you to resolve your
problem
EOI
    )"
    return 1
  fi

  return 0
}

### unset global variables exposed by one of the manifest's function call
appliance_unsetBuildContextVariables() {
  info 'unsetting build context'

  unset IMAGE_NAME
  unset BASE_IMAGE
  unset REQUIRED_IMAGES
  unset EXTRA_DOCKERFILE_COMMANDS

  return $?
}

### this function will build each and every image that are needed to build each
### service of the appliance. It relies on the content of the manifest file
### that has been source and roughly validated
# TODO: Refacto!
appliance_buildServiceImages() {
  info 'building appliance service image'

  # a common part of an error message
  local part_error_message="$(cat << EOI
Make sure that the COMPOSE_BUILD_CONTEXT variable is defined like following :

  COMPOSE_BUILD_CONTEXT="image_name1 function_name1
image_name2 function_name2
image_name3 function_name3" and so on...

Taking this remark into account should help you to resolve your
problem
EOI
)"

  # iterate through each pair of image name/function to build
  local pair_element=
  local function_name=
  for pair_element in $COMPOSE_BUILD_CONTEXT; do
    # extract pair's elements
    if [ -z "$IMAGE_NAME" ]; then
      # first, verify current pair_element
      if [ -z "$pair_element" ]; then
        error "$(cat << EOI
Error: Cannot read the image name in the definition of COMPOSE_BUILD_CONTEXT in
your appliance manifest file.
$part_error_message
EOI
        )"
        return 1
      fi

      # extracting the image name
      IMAGE_NAME="$pair_element"

      # loop at once to get the function name
      continue
    else
      # image name is set, assuming we are reading a function name but first,
      # make a check
      if [ -z "$pair_element" ]; then
        error "$(cat << EOI
Error: Cannot read the function name in the definition of COMPOSE_BUILD_CONTEXT
in your appliance manifest file.
$part_error_message
EOI
        )"
        return 1
      fi

      # extracting the function name
      function_name="$pair_element"
    fi

    # image already exists, nothing to do
    local repository_id="$(docker image ls -q "$IMAGE_NAME")"

    local returnCode=$?

    [ $returnCode -ne 0 ] \
    && fatal 'could not query '"$IMAGE_NAME"' on the docker host' \
    && return $returnCode

    if [ ! -z "$repository_id" ]; then
      info 'appliance service '"$IMAGE_NAME"' already exists'

      # some global variable have been set, rollback context
      IMAGE_NAME=
      function_name=
      continue
    fi

    # validate and run the function, exposing global variables to build the
    # image
    # then, check if requested docker images are built. If not, the system will
    # attempt to build them.
    # then, generate the dockerfile to build the appliance docker image
    # then, build the image
    # finally unset all global variables set by the build context function call
    appliance_callBuildContextFunction "$function_name" \
    && appliance_checkRequiredImages \
    && appliance_compileDockerfile \
    && appliance_buildServiceImage \
    && appliance_unsetBuildContextVariables

    returnCode=$?

    [ $returnCode -ne 0 ] \
    && error 'Appliance service image build failed at some point' \
    && return $returnCode

    # resetting the function name, for one more iteration
    function_name=
  done

  return 0
}

### entrypoint of the build command. In finality, create the appliance's docker
### image on the docker host.
appliance_build() {
  info 'building appliance'

  appliance_fillStagingArea \
  && appliance_buildServiceImages \
  && appliance_cleanupStagingArea

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'Appliance build failed at some point' \
  && return $returnCode

  return 0
}

### entrypoint of the start command. If the appliance requested to start has
### not been built yet, the system will attempt to build it first.
appliance_start() {
  info 'starting appliance'

  # if some image are not yet built, build them
  appliance_build \
  && appliance_fillStagingArea

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'error when preparing appliance to start' \
  && return $returnCode

  # crafting the docker-compose command, inhibiting image creation that is
  # handled by this script and forcing container recreation, containers being
  # ephemeral
  local command='docker-compose up --no-build -d'

  cd "$APPLIANCE_STAGING_DIRECTORY" \
  && eval "$command" \
  && cd "$USER_DIRECTORY"

  returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'could not start up the appliance. command was '"$command" \
  return $returnCode

  appliance_cleanupStagingArea

  return $?
}

### entrypoint for the stop command. If the appliance is running, stops it.
appliance_stop() {
  info 'stopping appliance'

  appliance_fillStagingArea \
  || return $?

  # crafting the docker-compose command, removing ephemeral containers
  local command='docker-compose rm -sf'

  # execute the docker-compose command
  cd "$APPLIANCE_STAGING_DIRECTORY" \
  && eval "$command" \
  && cd "$USER_DIRECTORY"

  [ $? -ne 0 ] \
  && fatal 'could not stop the appliance. command was '"$command" \
  && return $returnCode

  appliance_cleanupStagingArea

  return $?
}

### generic function executing the right function depending on the command
### provided. The name of the function to call is built appending the command
### name and 'Appliance'
appliance_executeRequestedCommand() {
  info 'executing appliance '"$COMMAND"' command'

  # build the function name according to the provided command
  local function_name=appliance_${COMMAND}

  # make sure the manifest file is well formed and contains mandatory stuff
  appliance_shallowValidateManifestFile \
  && $function_name

  return $?
}

### main entrypoint to manage appliances
appliance_manage() {
  info 'executing appliance command'

  appliance_checkArgument "$1" \
  && appliance_executeRequestedCommand

  return $?
}

#### End of appliance domain specific functions

### entry point
run() {
  info 'starting carrier execution'

  executeWithTraceIfRequested "$@"\
  || ( returnCode=$? \
       && error 'could not restart in trace mode' \
       && return $returnCode ) \
  || return $?

  info "building arguments referential, initializing execution context and
building the final execution context from provided arguments"

  buildArgumentsReferential \
  && initializeExecutionContext \
  && buildExecutionContextFromArguments "$@"

  [ $? -ne 0 ] \
  && error 'Failed to initialize carrier' \
  && return 1

  executeWithContext \
  || ( returnCode=$? \
       && usage \
       && return $returnCode )

  return $?
}

#### The script starts here once the standalone mode has passed
run "$@"
