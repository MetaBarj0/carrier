#!/bin/sh

#### standalone mode, external utility functions not loaded yet ################
set -e

# disable globbing. Referential contains string with '*' that behave wrongly
# when iterated by a for loop.
set -f

### initialize a path under certain circumstances
initializeCallScriptPath() {
  # get the full path of the called script if not provided by a restart in
  # trace mode
  if [ -z ${TRACE_ENABLED+0} ]; then
    cd $(dirname "$0")
    CALLED_SCRIPT="$(pwd -P)"/"$(basename "$0")"
    cd - 1>/dev/null 2>&1
  fi
}

### initialize true script path and link if relevant
initializeScriptLinkAndFilePaths() {
  # if it is a symlink, resolve it, keeping the link path
  if [ -L "$CALLED_SCRIPT" ]; then
    INSTALLED_LINK_PATH="$CALLED_SCRIPT"
    CARRIER_SCRIPT_PATH="$(readlink -f "$CALLED_SCRIPT")"
  else
    CARRIER_SCRIPT_PATH="$CALLED_SCRIPT"
  fi
}

### ensures carrier is well named and placed in its directory
checkCarrierNameAndDirectory() {
  # if the carrier script has been renammed, not supported => error
  if [ ! "$(basename "$CARRIER_SCRIPT_PATH")" = 'carrier' ]; then
    echo '`carrier` script has been renammed, not supported' 1>&2
    return 1
  fi

  # this directory exists and its path is absolute, verifying its name though
  CARRIER_BIN_DIR="$(dirname "$CARRIER_SCRIPT_PATH")"

  if [ ! "$(basename "$CARRIER_BIN_DIR")" = 'bin' ]; then
    cat << EOI 1>&2
The \`carrier\` script must reside in the \`bin/\` directory.
Not supported
EOI
  return 1
  fi
}

### self explanatory
getRelativeCarrierRootDir() {
  echo "$CARRIER_BIN_DIR"'/..'
}

### ensures the structure of carrier directory is good
checkCarrierSubdirs() {
  # set up each carrier directories and verify them
  local relative_carrier_root_dir="$(getRelativeCarrierRootDir)"
  local relative_carrier_lib_dir="$relative_carrier_root_dir"/lib
  local relative_carrier_share_dir="$relative_carrier_root_dir"/share
  local relative_carrier_share_bootstrap_dir=\
"$relative_carrier_share_dir"/bootstrap
  local relative_carrier_share_images_dir="$relative_carrier_share_dir"/images
  local relative_carrier_share_appliances_dir=\
"$relative_carrier_share_dir"/appliances
  local relative_carrier_src_dir="$relative_carrier_root_dir"/src

  if [ ! -d "$relative_carrier_lib_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_lib_dir does not exist. Your \`carrier\` package seems
broken or corrupted. Not supported.
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_dir does not exist. Your \`carrier\` package
seems broken or corrupted. Not supported.
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_bootstrap_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_bootstrap_dir does not exist. Your \`carrier\`
package seems broken or corrupted. Not supported.
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_images_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_images_dir does not exist. Your \`carrier\`
package seems broken or corrupted. Not supported.
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_share_appliances_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_share_appliances_dir does not exist. Your \`carrier\`
package seems broken or corrupted. Not supported.
EOI
  return 1
  fi

  if [ ! -d "$relative_carrier_src_dir" ]; then
    cat << EOI 1>&2
Fatal: $relative_carrier_src_dir does not exist. Your \`carrier\` package seems
broken or corrupted. Not supported.
EOI
  return 1
  fi
}

### remaining globals to initialize
### $1: relative path of the carrier root directory
initializeRemainingCarrierGlobalsFromRootDir() {
  local relative_carrier_root_dir="$1"

  cd $relative_carrier_root_dir
  CARRIER_ROOT_DIR="$(pwd -P)"
  CARRIER_LIB_DIR="$CARRIER_ROOT_DIR"/lib
  CARRIER_SHARE_DIR="$CARRIER_ROOT_DIR"/share
  CARRIER_SHARE_BOOTSTRAP_DIR="$CARRIER_SHARE_DIR"/bootstrap
  CARRIER_SHARE_IMAGES_DIR="$CARRIER_SHARE_DIR"/images
  CARRIER_SHARE_APPLIANCES_DIR="$CARRIER_SHARE_DIR"/appliances
  CARRIER_SRC_DIR="$CARRIER_ROOT_DIR"/src
  CARRIER_TMP_DIR="$CARRIER_ROOT_DIR"/tmp
  USER_DIRECTORY="$(cd -)"

  return $?
}

### set up paths after calling this script
initializePaths() {
  initializeCallScriptPath \
  && initializeScriptLinkAndFilePaths \
  && checkCarrierNameAndDirectory \
  && checkCarrierSubdirs \
  && local relative_carrier_root_dir="$(getRelativeCarrierRootDir)" \
  && initializeRemainingCarrierGlobalsFromRootDir "$relative_carrier_root_dir"

  return $?
}

### check that utility file specified exists
### $1: file to check existence
checkUtilityFileExists() {
  local file="$1"

  if [ ! -f "$file" ]; then
    cat << EOI 1>&2
Fatal: $file does not exist. Your \`carrier\` package seems broken or
corrupted. not supported...existing...
EOI
    return 1
  fi
  
  return 0
}

### load utilities located in $CARRIER_LIB_DIR/functions.sh
loadUtilities() {
  local functions_sh_path="$CARRIER_LIB_DIR"/functions.sh

  checkUtilityFileExists "$functions_sh_path" \
  || return $?

  # source stuff!
  . "$functions_sh_path"

  return $?
}

initializePaths
loadUtilities

# log function wired, fail on error is not necessary anymore
set +e
#### end of standalone mode, external utility functions loaded #################

### utility function returning true if log level is trace
isTraceLogLevel() {
  [ "$GLOBAL_OPTION_LOG_LEVEL" = 'trace' ]

  return $?
}

### utility function returning true if log level is debug
isDebugLogLevel() {
  isTraceLogLevel \
  || [ "$GLOBAL_OPTION_LOG_LEVEL" = 'debug' ]

  return $?
}

### utility function returning true if log level is info or greater
isInfoLogLevel() {
  isDebugLogLevel \
  || [ "$GLOBAL_OPTION_LOG_LEVEL" = 'info' ]

  return $?
}

### utility function returning true if log level is warning or greater
isWarningLogLevel() {
  isInfoLogLevel \
  || [ "$GLOBAL_OPTION_LOG_LEVEL" = 'warning' ]

  return $?
}

### utility function returning true if log level is error or greater
isErrorLogLevel() {
  isWarningLogLevel \
  || [ "$GLOBAL_OPTION_LOG_LEVEL" = 'error' ]

  return $?
}

### utility function returning true if log level is fatal or greater
isFatalLogLevel() {
  isErrorLogLevel \
  || [ "$GLOBAL_OPTION_LOG_LEVEL" = 'fatal' ]

  return $?
}

### logging function, designed to debug
### first and unique argument is the message
debug() {
  isDebugLogLevel && log '[debug] '"$1" "$GLOBAL_OPTION_LOG_OUTPUT"
  return 0
}

### logging function, designed to info
### first and unique argument is the message
info() {
  isInfoLogLevel && log '[info] '"$1" "$GLOBAL_OPTION_LOG_OUTPUT"
  return 0
}

### logging function, designed to warning
### first and unique argument is the message
warning() {
  isWarningLogLevel && log '[warning] '"$1" "$GLOBAL_OPTION_LOG_OUTPUT"
  return 0
}

### logging function, designed to error
### first and unique argument is the message
error() {
  isErrorLogLevel && log '[error] '"$1" "$GLOBAL_OPTION_LOG_OUTPUT"
  return 0
}

### logging function, designed to fatal
### first and unique argument is the message
fatal() {
  isFatalLogLevel && log '[fatal] '"$1" "$GLOBAL_OPTION_LOG_OUTPUT"
  return 0
}

### basic usage function, shows syntax, how to use, purpose and so on...
usage() {
  cat << EOI
Usage:
  carrier [global options] \\
          [[domain] [domain options] command [command options]] | \\
          command [command options]

Use:

  carrier help --full to get a full usage description
EOI

  return 0
}

### internal function that remove unnecessary information from global options
### referential specified in argument
removeIrrelevantDetailsFromReferentialOption() {
  local referential="$1"

  info 'removing irrelevant data from '"$referential"

  echo "$referential"\
  | sed -E '/^--$/d' \
  | sed -E '/contextSet.+/d'

  local returnCode=$?

  [ "$returnCode" -ne 0 ] \
  && fatal 'could not purify the options referential to get detailed help'

  return $returnCode
}

### Get a full help on usage
usageFull() {
  info 'printing full usage help'

  cat << EOI
$(usage)

Global options:
$(removeIrrelevantDetailsFromReferentialOption "$GLOBAL_OPTIONS_REFERENTIAL")

Global commands:
$(removeIrrelevantDetailsFromReferentialOption "$GLOBAL_COMMANDS_REFERENTIAL")

Help command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL")

Info command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL")

Install command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_INSTALL_OPTIONS_REFERENTIAL")

Pack command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_PACK_OPTIONS_REFERENTIAL")

Unpack command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_UNPACK_OPTIONS_REFERENTIAL")

Vagrant command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$GLOBAL_COMMAND_VAGRANT_OPTIONS_REFERENTIAL")

Domains:
$(removeIrrelevantDetailsFromReferentialOption "$DOMAINS_REFERENTIAL")

Bootstrap domain commands:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_BOOTSTRAP_COMMANDS_REFERENTIAL")

Bootstrap run command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTIONS_REFERENTIAL")

Bootstrap check command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS_REFERENTIAL")

Image domain commands:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMANDS_REFERENTIAL")

Image build command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_BUILD_OPTIONS_REFERENTIAL")

Image list command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_LIST_OPTIONS_REFERENTIAL")

Image check command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_CHECK_OPTIONS_REFERENTIAL")

Image info command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_INFO_OPTIONS_REFERENTIAL")

Image upgrade command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL")

Image factorize command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTIONS_REFERENTIAL")

Appliance domain commands:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMANDS_REFERENTIAL")

Appliance build command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTIONS_REFERENTIAL")

Appliance list command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_LIST_OPTIONS_REFERENTIAL")

Appliance check command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTIONS_REFERENTIAL")

Appliance info command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_INFO_OPTIONS_REFERENTIAL")

Appliance start command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_START_OPTIONS_REFERENTIAL")

Appliance stop command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_STOP_OPTIONS_REFERENTIAL")

Appliance volumes command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_VOLUME_OPTIONS_REFERENTIAL")

Appliance upgrade command options:
$(removeIrrelevantDetailsFromReferentialOption \
    "$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL")
EOI

  return $?
}

### built the argument referential, sort of description and constraints about
### each valid argument.
### each line of a variable definition define a pattern one arg can match at a
### time :
###
### line 0: optional comment lines starting with #
### line 1: pattern for argument
### line 2: pattern for argument value or --
### line 3: function name initializing execution context
buildArgumentsReferential() {
  info 'setting up the arguments referential'

  GLOBAL_OPTIONS_REFERENTIAL="$(cat << EOI
# desired log level. Defaulted to 'error'.
# i.e. carrier info --log-level=error
#      carrier info -l debug
(-l|--log-level)=?
fatal|error|warning|info|debug|trace
contextSetLogLevel

# desired output for logs. Defaulted to '&2' that is stderr
# i.e. carrier info --log-output=carrier.log
#      carrier info -o '&2'
(-o|--log-output)=?
.+
contextSetLogOutput
EOI
  )"

  GLOBAL_COMMANDS_REFERENTIAL="$(cat << EOI
# domainless commands. only valid when not any domain is specified.
#
# help: provides help about carrier usage
#       i.e. carrier help
#
# info: Provides general information about carrier
#       i.e. carrier info
#
# install: Install carrier to the specified location. Installation is a simple
#          process consisting in creating a symbolic link to the specified
#          location. If carrier is already installed somewhere or a symlink
#          exist with the specified name, the process fails by default.  Note:
#          If a file (not a symlink) exists at the specified location the
#          process will always fails even if forced.  If a symlink exists and
#          points on something existing other than a carrier installation, the
#          process will always fails to preserve system integrity.
#
# pack: Packs carrier into a single executable file, easying its transportation
#       and allowing it to be used on network-isolated systems (using specific
#       command options). By default, all the directory architecture of carrier
#       is packed, including necessary resources to bootstrap your system. Thus,
#       an internet connection is required to pack carrier.
#       Moreover, user file ~/.carrier will also be included. The resulting file
#       will be a shell script containing shell code and base64 encoded tar
#       archive. As a result, modern tar and base64 implementations are
#       necessary to use the pack command efficiently
#       i.e. carrier pack
#
# unpack: unpack a packed version of carrier, creating the original directory
#         structure of carrier. If you downloaded image sources in the packed
#         carrier, you can choose to keep them (this is not the default behavior
#         though). The .carrier file is extracted to the user directory.
#
# vagrant: manipulate the vagrant environment of carrier. Each command and
#          option you specify are directly forwarded to the vagrant program. If
#          vagrant is not found, the process fails.
help|info|install|pack|unpack|vagrant
--
contextSetGlobalCommand
EOI
  )"

  GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL="$(cat << EOI
# options for the domainless help command. Turn on exhaustive help
# i.e. carrier help -H
#      carrier help --full
-H|--full
--
contextSetHelpMode
EOI
  )"

  GLOBAL_COMMAND_INFO_OPTIONS_REFERENTIAL="$(cat << EOI
# specify the output format:
# - shell: give a a list of pairs of the form VAR=VAL
# - json: create a json object containing requested properties
(-f|--format)=?
shell|json
contextSetInfoFormat
EOI
  )"

  GLOBAL_COMMAND_INSTALL_OPTIONS_REFERENTIAL="$(cat << EOI
# Force the installation of carrier to the path specified even if a previous
# installation has been detected. If a reinstallation occurs, remove the
# previous one. Even if this flag is set, installation may fail if destination
# already exists and does not correspond to a previous carrier installation
-f|--force
--
contextSetInstallForce

# If reinstallation occurs, keep the existing one.
# i.e carrier install --force --keep-previous-installation
-k|--keep-previous-installation
--
contextSetInstallKeep
EOI
  )"

  GLOBAL_COMMAND_PACK_OPTIONS_REFERENTIAL="$(cat << EOI
# While packing, fetch all supported image sources from the internet and embbed
# them in the package. Beware as the package could grow arbitrarily large. Using
# this option is interesting if you want to use carrier on a network isolated
# system. This is not the default behavior of packing.
# i.e carrier pack --fetch-all-images-sources
-s|--fetch-all-images-sources
--
contextSetPackFetchAll

# Instead of packing carrier, only fetch sources of images. This option can be
# specified with -s and -i. This is not the default behavior of packing.
-o|--only-fetch-sources
--
contextSetPackFetchOnly

# While packing, fetch sources of specified images only. Sources of unspecified
# images will not be fetched, leading to a less heavy package but forcing one to
# grab source from the internet if an attempt to build an image that does not
# have its source stored locally is made. This is not the default behavior of
# packing.
# i.e carrier pack -i metabarj0/wget,metabarj0/llvm
(-i|--fetch-images-sources)=?
[^,]+(,[^,]+)*
contextSetPackSpecificImageFetch
EOI
  )"

  GLOBAL_COMMAND_UNPACK_OPTIONS_REFERENTIAL="$(cat << EOI
# While unpaking, do not delete fetch sources. This is not the default behavior
-k|--keep-sources-if-any
--
contextSetUnpackKeepSources
EOI
  )"

  GLOBAL_COMMAND_VAGRANT_OPTIONS_REFERENTIAL="$(cat << EOI
# Specify where to find the vagrant program. Defaulted to vagrant, therefore,
# vagrant is supposed to be found in the PATH environment variable.
(-p|--vagrant-path)=?
.+
contextSetVagrantPath

# commands/arguments/options to forward to the vagrant program. Must be enclosed
# by quotes to be parsed as a single argument in the carrier point of view.
'.+'
--
contextSetVagrantArguments
EOI
  )"

  DOMAINS_REFERENTIAL="$(cat << EOI
# specific domain of application for carrier. A domain is the highest level
# context carrier acts on.
#
# bootstrap: the bootstrap context can be used with bootstrap specific commands
#            and options. Allows one to deal with all the bootstrapping stuff.
#
# image: the image context is related to docker image manipulation and provides
#        image specific commands and options.
#
# appliance: the appliance domain deals with appliance manipulation and provides
#            appliance specific commands and options.
bootstrap|image|appliance
--
contextSetDomain
EOI
  )"

  DOMAIN_BOOTSTRAP_COMMANDS_REFERENTIAL="$(cat << EOI
# available commands in the bootstrap domain
# - check verify the current environment is correctly bootstrap
# - run bootstrap the system
check|run
--
contextSetBootstrapCommand
EOI
  )"

  DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS_REFERENTIAL="$(cat << EOI
# no options yet
EOI
  )"

  DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTIONS_REFERENTIAL="$(cat << EOI
# specifying this option for a bootstrap run command allows to keep existing
# images produced by a previous bootstrap run. Images will be tagged with the
# current data and time using the '+%Y%m%d%H%M%S' format usable with the date
# command.
-t|--retag-existing-images
--
contextSetBootstrapRunRetag
EOI
  )"

  DOMAIN_IMAGE_COMMANDS_REFERENTIAL="$(cat << EOI
# available commands for the image domain.
# - build can build one or more images
# - list can list images on the system, reporting information about the
#   availability of images
# - check verifies one or more images are healthy and up to date
# - info report about internal informations about an image
# - upgrade can upgrade one or more image regarding their dependencies status
build|list|check|info|upgrade|factorize
--
contextSetImageCommand
EOI
  )"

  DOMAIN_IMAGE_COMMAND_BUILD_OPTIONS_REFERENTIAL="$(cat << EOI
# specifying this option while building an image prevent the system to tag a
# previous version existing on the docker host. As a result, if a previous
# version of the image being built were present; it is deleted instead of being
# retagged. This is not the default behavior.
-r|--remove-existing-images
--
contextSetImageBuildRemoveExisting

# sequence (or unique) image to be built. The sequence can be made of :
# - image name (the directory name containing image files)
# - relative path of the image manifest file
# - absolute path of the image manifest file
# - a mix of all three
[^,]+(,[^,]+)*
--
contextSetImageBuildImageSequence
EOI
  )"

  DOMAIN_IMAGE_COMMAND_LIST_OPTIONS_REFERENTIAL="$(cat << EOI
# list all images, built, not built, local and remote
-a|--all
--
contextSetImageListAll

# list only built images
-b|--only-built
--
contextSetImageListOnlyBuilt

# list only not built images
-n|--only-not-built
--
contextSetImageListOnlyNotBuilt

# list only local images that are not present on remote repository (new images
# being created for instance)
-l|--only-local
--
contextSetImageListOnlyLocal

# list only supported images that are present on the remote repository.
-r|--only-remote
--
contextSetImageListOnlyRemote

# specify the output format:
# - one-line outputs the result in one line, each image name being separated by
#   a space character and formated as following:
#   image1:flags,image2:flags,...
#   flags being:
#   - b for built
#   - n for not built
#   - l for local
#   - r for remote
# Note that local and remote are not exclusive though it is unlikely to have an
# image flagged as remote that is not present on your local system (unless you
# deliberatly removed it)
# - pretty outputs a very nice table (default)
# - docker relies on the docker client to output the result. You can specify
# docker specific format information appending
# \`:'docker format args for docker images'\`
# The docker format works only for built images
(-f|--format)=?
one-line|pretty|docker(:'.*')?
contextSetImageListFormat
EOI
  )"

  DOMAIN_IMAGE_COMMAND_CHECK_OPTIONS_REFERENTIAL="$(cat << EOI
# checks all built image by checking their dependencies integrity. If an image
# name is output, it means that something is wrong with the dependency chain.
# Image name is output if:
# - a dependency is newer than the image, meaning the image may need to be
#   rebuilt
# - a dependency is missing meaning the image may not be up to date
# - the /image.dist file of the image is missing or corrupted, meaning something
#   went wrong when image has been built.
# checking all images is the default behavior
-a|--all-installed
--
contextSetImageCheckAllBuilt

# ignore the build date of dependecies when checking images
-d|--ignore-date
--
contextSetImageCheckIgnoreDate

# ignore if dependency is missing on the docker host when checking images
-m|--ignore-missing
--
contextSetImageCheckIgnoreMissing

# ignore detected defect in image checking (not recommended)
-i|--ignore-image-dist-defects
--
contextSetImageCheckIgnoreDependencyDefects

# format the output if something is found:
# - list gives a list of the form:
#   image:issue1,issue2...
# - pretty ouput a nice table (default)
(-f|--format)=?
list|pretty
contextSetImageCheckFormat

# explicit image list to cheack instead of all
(-l|--image-list)=?
[^,]+(,[^,]+)*
contextSetImageCheckImageSequence
EOI
  )"

  DOMAIN_IMAGE_COMMAND_INFO_OPTIONS_REFERENTIAL="$(cat << EOI
# report all properties of requested image (default behavior)
-a|--report-all
--
contextSetImageInfoAllProps

# only report the image.dist content
-i|--report-image-content
--
contextSetImageInfoOnlyContent

# only report the docker image name provided
-p|--report-provides
--
contextSetImageInfoOnlyProvides

# only report dependency image names
-r|--report-requires
--
contextSetImageInfoOnlyRequires

# report the name of the base image
-b|--report-base-image
--
contextSetImageInfoOnlyBaseImage

# report the name of the image used to fetch sources
-d|--report-sources-fetch-image
--
contextSetImageInfoOnlyFetchImage

# report the command used to fetch sources
-s|--report-sources-fetch-command
--
contextSetImageInfoOnlyFetchCommand

# report the name of the sources tarball
-c|--report-sources-tarball-name
--
contextSetImageInfoOnlyTarballName

# report extra dockerfile commands appended to the generated Dockerfile for the
# image building process
-x|--report-build-extra-dockerfile-commands
--
contextSetImageInfoOnlyBuildExtraDockerfileCommands

# report extra dockerfile commands used to build the final image
-z|--report-final-extra-dockerfile-commands
--
contextSetImageInfoOnlyFinalExtraDockerfileCommands

# specify the output format:
# - shell: give a a list of pairs of the form VAR=VAL
# - json: create a json object containing requested properties
(-f|--format)=?
shell|json
contextSetImageInfoFormat

# the image to observe
.+
--
contextSetImageInfoImage
EOI
  )"

  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL="$(cat << EOI
# attempt an upgrade of all built images by checking their dependencies
# integrity and status. If one or more dependencies have a problem or is newer
# than the observed image, both actions are taken:
# - dependencies is corrupted: report the issue and does nothing else
# - a dependency is newer than the image : the observed image is rebuilt
# - a dependency is missing : report and does nothing else
# this is the default behavior
-a|--all-installed
--
contextSetImageUpgradeAll

# ignore the date of dependencies of the observed image. Note that ignore date
# in using the upgrade command will always inhibit the image rebuild.
-d|--ignore-date
--
contextSetImageUpgradeIgnoreDate

# does not report missing dependency
-m|--ignore-missing
--
contextSetImageUpgradeIgnoreMissing

# does not report a defect problem in a dependency image
-i|--ignore-image-dist-defects
--
contextSetImageUpgradeIgnoreDependencyDefects

# specify an image list instead of attempting to upgrade them all. list has the
# form :
# image1,image2...
(-l|--image-list)=?
[^,]+(,[^,]+)*
contextSetImageUpgradeImageSequence
EOI
  )"

  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTIONS_REFERENTIAL="$(cat << EOI
# options available when factorizing two or more images to extract a base that
# contains all common files. Factorizing images consists in taking 2 or more
# images, extract all files that are common in all these images, create a brand
# new image with these common files, and create new images with their
# respective files without common extracted ones.

# the name to give to the extracted base image. Note that the provided name
# must be conform to the docker standard in term of naming.
(-n|--base-image-name)=?
.+
contextSetImageFactorizeBaseImageName

# this is the prefix used to name the extracted base image. As a result, a
# prefixed base image will look like : prefix/base_image_name when listing
# docker images
# if not specified, defaulted to 'base'
(-b|--base-image-prefix)=?
.+
contextSetImageFactorizeBaseImagePrefix

# prefix used on factorized images. A prefixed factorized image will look like
# prefix/factorize_image when listing docker images. If the prefix is not
# specified, the prefixed base image name is used.
(-f|--factorized-image-prefix)=?
.+
contextSetImageFactorizeFactorizedImagePrefix

# the image list to factorize. At least 2 images have to be specified but
# specifying more than 2 is perfectly valid. However, keep in mind that
# specified images having lots of files in common tend to be more factorizable.
(-l|--image-list)=?
[^,]+(,[^,]+)+
contextSetImageFactorizeImageSequence

# indicates if original images must be removed after a successful
# factorization. defaulted to 'no'
(-r|--remove-original-images)=?
--
contextSetImageFactorizeRemoveOriginalImages

# indicates if resulting image overwrite existing images with the same name on
# the docker host
(-o|--overwrite-resulting-images)
--
contextSetImageFactorizeOverwriteExistingImages
EOI
  )"

  DOMAIN_APPLIANCE_COMMANDS_REFERENTIAL="$(cat << EOI
# available commands for the appliance domain.
# - build can build one or more appliances.
# - list can list appliances on the system, reporting information about the
#   availability of appliances
# - check verifies one or more appliances are healthy and up to date
# - info report about internal informations about an appliance
# - upgrade can upgrade one or more appliances regarding their service image and
#   dependencies status
# - start can start an appliance or several
# - stop can stop one or more appliances
# - volume can help the user to manage volumes used by an appliance
build|list|check|info|upgrade|start|stop|volume
--
contextSetApplianceCommand
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTIONS_REFERENTIAL="$(cat << EOI
# When building an appliance, remove all appliance service images that already
# exist on the docker host. This is not the default behavior as by default, if
# images exist, nothing is built
-r|--remove-existing-images
--
contextSetApplianceBuildRemoveExisting

# When building an appliance, tag all existing service image using the
# '+%Y%m%d%H%M%S' format usable with the date command. This is not the default
# behavior as by default, if images exist, nothing is built
-t|--tag-existing-images
--
contextSetApplianceBuildTagExisting

# the appliance list to build. Has the form:
# appliance1,appliance2...
[^,]+(,[^,]+)*
--
contextSetApplianceBuildApplianceSequence
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_LIST_OPTIONS_REFERENTIAL="$(cat << EOI
# list all appliances, built, not built, local and remote
-a|--all
--
contextSetApplianceListAll

# list only built appliances
-b|--only-built
--
contextSetApplianceListOnlyBuilt

# list only not built appliances
-n|--only-not-built
--
contextSetApplianceListOnlyNotBuilt

# list only local appliances that are not present on remote repository (new
# appliances being created for instance)
-l|--only-local
--
contextSetApplianceListOnlyLocal

# list only supported appliances that are present on the remote repository.
-r|--only-remote
--
contextSetApplianceListOnlyRemote

# specify the output format:
# - one-line outputs the result in one line, each appliance name being separated
#   by a space character and formated as following:
#   appliance1:flags,appliance2:flags,...
#   flags being:
#   - b for built
#   - n for not built
#   - l for local
#   - r for remote
# Note that local and remote are not exclusive though it is unlikely to have an
# appliance flagged as remote that is not present on your local system (unless
# you deliberatly removed it)
# - pretty outputs a very nice table (default)
(-f|--format)=?
one-line|pretty
contextSetApplianceListFormat
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTIONS_REFERENTIAL="$(cat << EOI
# verify all built appliances by checking each of its service image. (default
# behavior)
-a|--all-installed
--
contextSetApplianceCheckAll

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are more up to date than the
# service image, it is ignored and the service image will be considered ok
-d|--ignore-date
--
contextSetApplianceCheckIgnoreDate

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are missing on the docker host
# it is ignored and the service image will be considered ok
-m|--ignore-missing
--
contextSetApplianceCheckIgnoreMissing

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies have something wrong in their
# image.dist file, it is ignored and the service image will be considered ok
# (this is not recommended)
-i|--ignore-image-dist-defects
--
contextSetApplianceCheckIgnoreDependencyDefects

# explicit list of appliance to check. The list has the form:
# appliance1,appliance2...
(-l|--appliance-list)=?
[^,]+(,[^,]+)*
contextSetApplianceCheckApplianceList
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_INFO_OPTIONS_REFERENTIAL="$(cat << EOI
# report all information properties of the appliance (default behavior)
-a|--report-all
--
contextSetApplianceInfoAllProps

# report only the base image used for the observed service image
-b|--report-base-image
--
contextSetApplianceInfoOnlyBase

# execute a docker-compose config on the appliance docker-compose.yml file
-c|--report-config
--
contextSetApplianceInfoOnlyConfig

# reports only dependent images required for the service being observed
-r|--report-requires
--
contextSetApplianceInfoOnlyRequires

# report only extra Dockerfile commands used in the observed service image
-x|--report-extra-dockerfile-commands
--
contextSetApplianceInfoOnlyExtraDockerfileCommands

# inspect all services of the appliance (default behavior)
-s|--all-services
--
contextSetApplianceInfoAllServices

# specify a list of service to observe. List has the form:
# service1,service2...
(-s|--service)=?
[^,]+(,[^,])*
contextSetApplianceInfoServiceSequence

# output format of the report
# shell is a list of pairs of the form key=value (default)
# json output the result in a json object
(-f|--format)=?
shell|json
contextSetApplianceInfoFormat

# the appliance to get info from
.+
--
contextSetApplianceInfoAppliance
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_START_OPTIONS_REFERENTIAL="$(cat << EOI
# if appliances requested to start does not exist, attempt to build it
# beforehand using default options. Default behavior
-b|--build
--
contextSetApplianceStartBuild

# do not attempt to build appliance service image if they are missing. If one
# or more service images are missing this command will fail(not default
# behavior)
-n|--dont-build
--
contextSetApplianceStartDontBuild

# list of appliance to start. List has the form:
# appliance1,appliance2...
[^,]+(,[^,]+)*
--
contextSetApplianceStartApplianceSequence
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_STOP_OPTIONS_REFERENTIAL="$(cat << EOI
# when stopping an appliance, also remove created containers. Containers are
# considered ephemeral by design so it is the default behavior
-d|--rm
--
contextSetApplianceStopRemoveContainers

# do not delete appliance container when stopping. This is not the default
# behavior
-k|--keep-containers
--
contextSetApplianceStopKeepContainers

# list of appliance to stop. List has the form:
# appliance1,appliance2...
[^,]+(,[^,]+)*
--
contextSetApplianceStopApplianceSequence
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_VOLUME_OPTIONS_REFERENTIAL="$(cat << EOI
# list the appliance volumes
list
--
contextSetApplianceVolumeList

# remove specified appliance volumes. Volumes are specified just after,
# separated by a comma
rm
[^,]+(,[^,]+)*
contextSetApplianceVolumesRemove

# dump specified volumes. Volumes are specified just after, separated by a
# comma
dump
[^,]+(,[^,]+)*
contextSetApplianceVolumeDump

# clone specified volumes. Volumes to be cloned are specified like this :
# <volume to clone>=<new volume name to create> repeated n times and separated
# by a comma
clone
[^= ]+=[^, ]+(,[^= ]+=[^, ]+)*
contextSetApplianceVolumeClone

# specify the dump output directory path (defaulted to current directory, using
# the volume name)
(-p|--dump-output-directory-path)=?
.+
contextSetApplianceVolumeDumpDirectoryPath

# targeted appliance
(-a|--appliance)=?
.+
contextSetApplianceVolumesAppliance
EOI
  )"

  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL="$(cat << EOI
# scan all built appliances
-a|--all-installed
--
contextSetApplianceUpgradeAll

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are more up to date than the
# service image, it is ignored and the service image will be considered up to
# date
-d|--ignore-date
--
contextSetApplianceUpgradeIgnoreDate

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies are missing on the docker host
# it is ignored and the service image will be considered up to date
-m|--ignore-missing
--
contextSetApplianceUpgradeIgnoreMissing

# when checking an appliance service image, a dependency collection is done for
# each service image. If one or more dependencies have something wrong in their
# image.dist file, it is ignored and the service image will be considered up to
# date (this is not recommended)
-i|--ignore-image-dist-defects
--
contextSetApplianceUpgradeIgnoreDependencyDefects

# explicit list of appliance to check. The list has the form:
# appliance1,appliance2...
(-l|--appliance-list)=?
[^,]+(,[^,]+)*
contextSetApplianceUpgradeApplianceSequence
EOI
  )"

  return $?
}

### initialize the execution context of carrier, dictating what to do with
### provided arguments
initializeExecutionContext() {
  info 'Initializing the execution context with default values'

  # user can set up this variable value before executing this script. It allows
  # to take benefit of the log level before having to parse arguments passed to
  # the script, allowing to log level higher than error before the execution
  # begins
  # carrier --log-level=error ...
  [ -z "$GLOBAL_OPTION_LOG_LEVEL" ] \
  && GLOBAL_OPTION_LOG_LEVEL=error

  GLOBAL_OPTION_LOG_OUTPUT='&2'

  # carrier help, carrier appliance run ...
  COMMAND=

  # carrier help -H
  GLOBAL_COMMAND_HELP_OPTION_MODE=

  # carrier info --format=shell
  GLOBAL_COMMAND_INFO_OPTION_FORMAT='shell'

  # carrier install --force -k
  GLOBAL_COMMAND_INSTALL_OPTION_FORCE='no'
  GLOBAL_COMMAND_INSTALL_OPTION_KEEP='no'

  # carrier pack -s
  GLOBAL_COMMAND_PACK_OPTION_FETCH_ALL_SOURCES='no'
  GLOBAL_COMMAND_PACK_OPTION_ONLY_FETCH_SOURCES='no'
  GLOBAL_COMMAND_PACK_OPTION_FETCH_SPECIFIC_IMAGE_SOURCES=

  # carrier unpack -k
  GLOBAL_COMMAND_UNPACK_OPTION_KEEP_SOURCES='no'

  # carrier vagrant -p '/usr/local/bin/vagrant' up
  GLOBAL_COMMAND_VAGRANT_OPTION_PATH='vagrant'
  GLOBAL_COMMAND_VAGRANT_OPTION_ARGUMENTS=

  # bootstrap or image or appliance
  DOMAIN=

  # not used yet
  DOMAIN_OPTIONS=

  # not used yet
  DOMAIN_BOOTSTRAP_OPTIONS=
  DOMAIN_IMAGE_OPTIONS=
  DOMAIN_APPLIANCE_OPTIONS=

  # carrier bootstrap check
  DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS=

  # carrier bootstrap run --retag-existing-images
  DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTION_RETAG_EXISTING='no'

  # carrier image build -r metabarj0/wget
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_REMOVE_EXISTING='no'
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE=

  # carrier image list -b --format json
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ALL='yes'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_BUILT='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_NOT_BUILT='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_LOCAL='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_REMOTE='no'
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_FORMAT='pretty'

  # carrier image check --all --ignore-missing
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_ALL_IMAGES='yes'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DATE='no'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_MISSING='no'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_FORMAT='pretty'
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IMAGE_SEQUENCE=

  # carrier image info --report-base-image -f shell
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ALL='yes'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_CONTENT='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_PROVIDES='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_REQUIRES='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_BASE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_IMAGE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_COMMAND='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_TARBALL_NAME='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_BUILD_DOCKERFILE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_FINAL_DOCKERFILE='no'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_FORMAT='shell'
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_IMAGE=

  # carrier image upgrade metabarj0/git,metabarj0/gdb
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_ALL='yes'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DATE='no'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING='no'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IMAGE_SEQUENCE=

  # carrier image factorize \
  #   -n dev_toolchains \
  #   -l metabarj0/llvm,metabarj0/gcc
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME=
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_PREFIX='base'
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_FACTORIZED_IMAGE_PREFIX=
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE=
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_REMOVE_ORIGINAL_IMAGES='no'
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_OVERWRITE_EXISTING='no'

  # carrier appliance build devenv_cpp -r
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_REMOVE_EXISTING='no'
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_TAG_EXISTING='no'
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE=

  # carrier appliance list --only-remote -f one-line
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_BUILT='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_NOT_BUILT='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_LOCAL='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_REMOTE='no'
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_FORMAT='pretty'

  # carrier appliance check devenv_cpp
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DATE='no'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_MISSING='no'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_APPLIANCE_LIST='no'

  # carrier appliance info --report-config
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_REPORT_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_BASE='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_CONFIG='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_REQUIRES='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_EXTRA_DOCKERFILE='no'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_ALL_SERVICES='yes'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_SERVICE_LIST=
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_FORMAT='shell'
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_APPLIANCE=

  # carrier appliance start devenv_cpp -n
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_BUILD='yes'
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE=

  # carrier appliance stop --keep-containers devenv_cpp
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_REMOVE_CONTAINERS='yes'
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE=

  # carrier appliance volume ...
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_LIST=
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_REMOVE=
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_DUMP=
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_CLONE=
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_CLONE_VOLUME_MAP=
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_DUMP_DIRECTORY_PATH='./'
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_DUMP_VOLUME_LIST=
  DOMAIN_APPLIANCE_COMMAND_VOLUME_OPTION_APPLIANCE=

  # carrier appliance upgrade devev_cpp
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_ALL='yes'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DATE='no'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING='no'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS='no'
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_APPLIANCE_SEQUENCE=

  return $?
}

### internal function displyaing the content of the execution context
debugOutputExecutionContext() {
  info 'outputting current execution context'

  cat << EOI
  GLOBAL_OPTION_LOG_LEVEL=\
$GLOBAL_OPTION_LOG_LEVEL
  GLOBAL_OPTION_LOG_OUTPUT=\
$GLOBAL_OPTION_LOG_OUTPUT
  COMMAND=\
$COMMAND
  GLOBAL_COMMAND_HELP_OPTION_MODE=\
$GLOBAL_COMMAND_HELP_OPTION_MODE
  GLOBAL_COMMAND_INFO_OPTION_FORMAT=\
$GLOBAL_COMMAND_INFO_OPTION_FORMAT
  GLOBAL_COMMAND_INSTALL_OPTION_FORCE=\
$GLOBAL_COMMAND_INSTALL_OPTION_FORCE
  GLOBAL_COMMAND_INSTALL_OPTION_KEEP=\
$GLOBAL_COMMAND_INSTALL_OPTION_KEEP
  GLOBAL_COMMAND_PACK_OPTION_FETCH_ALL_SOURCES=\
$GLOBAL_COMMAND_PACK_OPTION_FETCH_ALL_SOURCES
  GLOBAL_COMMAND_PACK_OPTION_ONLY_FETCH_SOURCES=\
$GLOBAL_COMMAND_PACK_OPTION_ONLY_FETCH_SOURCES
  GLOBAL_COMMAND_PACK_OPTION_FETCH_SPECIFIC_IMAGE_SOURCES=\
$GLOBAL_COMMAND_PACK_OPTION_FETCH_SPECIFIC_IMAGE_SOURCES
  GLOBAL_COMMAND_UNPACK_OPTION_KEEP_SOURCES=\
$GLOBAL_COMMAND_UNPACK_OPTION_KEEP_SOURCES
  GLOBAL_COMMAND_VAGRANT_OPTION_PATH=\
$GLOBAL_COMMAND_VAGRANT_OPTION_PATH
  GLOBAL_COMMAND_VAGRANT_OPTION_ARGUMENTS=\
$GLOBAL_COMMAND_VAGRANT_OPTION_ARGUMENTS
  DOMAIN=\
$DOMAIN
  DOMAIN_OPTIONS=\
$DOMAIN_OPTIONS
  DOMAIN_BOOTSTRAP_OPTIONS=\
$DOMAIN_BOOTSTRAP_OPTIONS
  DOMAIN_IMAGE_OPTIONS=\
$DOMAIN_IMAGE_OPTIONS
  DOMAIN_APPLIANCE_OPTIONS=\
$DOMAIN_APPLIANCE_OPTIONS
  DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS=\
$DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS
  DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTION_RETAG_EXISTING=\
$DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTION_RETAG_EXISTING
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_REMOVE_EXISTING=\
$DOMAIN_IMAGE_COMMAND_BUILD_OPTION_REMOVE_EXISTING
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ALL=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ALL
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_BUILT=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_BUILT
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_NOT_BUILT=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_NOT_BUILT
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_LOCAL=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_LOCAL
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_REMOTE=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_LIST_ONLY_REMOTE
  DOMAIN_IMAGE_COMMAND_LIST_OPTION_FORMAT=\
$DOMAIN_IMAGE_COMMAND_LIST_OPTION_FORMAT
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_ALL_IMAGES=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_ALL_IMAGES
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DATE=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DATE
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_MISSING=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_MISSING
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_FORMAT=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_FORMAT
  DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_CHECK_OPTION_IMAGE_SEQUENCE
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ALL=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ALL
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_CONTENT=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_CONTENT
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_PROVIDES=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_PROVIDES
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_REQUIRES=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_REQUIRES
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_BASE=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_BASE
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_IMAGE=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_IMAGE
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_COMMAND=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_FETCH_COMMAND
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_TARBALL_NAME=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_TARBALL_NAME
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_BUILD_DOCKERFILE=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_BUILD_DOCKERFILE
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_FINAL_DOCKERFILE=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_REPORT_ONLY_X_FINAL_DOCKERFILE
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_FORMAT=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_FORMAT
  DOMAIN_IMAGE_COMMAND_INFO_OPTION_IMAGE=\
$DOMAIN_IMAGE_COMMAND_INFO_OPTION_IMAGE
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_ALL=\
$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_ALL
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DATE=\
$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DATE
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING=\
$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS=\
$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS
  DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTION_IMAGE_SEQUENCE
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_PREFIX=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_PREFIX
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_FACTORIZED_IMAGE_PREFIX=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_FACTORIZED_IMAGE_PREFIX
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_REMOVE_ORIGINAL_IMAGES=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_REMOVE_ORIGINAL_IMAGES
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_OVERWRITE_EXISTING=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_OVERWRITE_EXISTING
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_REMOVE_EXISTING=\
$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_REMOVE_EXISTING
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_TAG_EXISTING=\
$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_TAG_EXISTING
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ALL=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ALL
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_BUILT=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_BUILT
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_NOT_BUILT=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_NOT_BUILT
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_LOCAL=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_LOCAL
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_REMOTE=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_ONLY_REMOTE
  DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_FORMAT=\
$DOMAIN_APPLIANCE_COMMAND_LIST_OPTION_FORMAT
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_ALL=\
$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_ALL
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DATE=\
$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DATE
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_MISSING=\
$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_MISSING
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS=\
$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_IGNORE_DEPENDENCY_DEFECTS
  DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_APPLIANCE_LIST=\
$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTION_APPLIANCE_LIST
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_REPORT_ALL=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_REPORT_ALL
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_BASE=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_BASE
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_CONFIG=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_CONFIG
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_REQUIRES=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_REQUIRES
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_EXTRA_DOCKERFILE=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_ONLY_EXTRA_DOCKERFILE
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_ALL_SERVICES=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_ALL_SERVICES
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_SERVICE_LIST=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_INSPECT_SERVICE_LIST
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_FORMAT=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_FORMAT
  DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_APPLIANCE=\
$DOMAIN_APPLIANCE_COMMAND_INFO_OPTION_APPLIANCE
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_BUILD=\
$DOMAIN_APPLIANCE_COMMAND_START_OPTION_BUILD
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_REMOVE_CONTAINERS=\
$DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_REMOVE_CONTAINERS
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_LIST=\
$DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_LIST
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_REMOVE=\
$DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_REMOVE
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_CLONE=\
$DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_CLONE
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_CLONE_VOLUME_MAP=\
$DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_CLONE_VOLUME_MAP
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_DUMP=\
$DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_DUMP
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_DUMP_DIRECTORY_PATH=\
$DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_DUMP_DIRECTORY_PATH
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_DUMP_VOLUME_LIST=\
$DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_DUMP_VOLUME_LIST
  DOMAIN_APPLIANCE_COMMAND_VOLUME_OPTION_APPLIANCE=\
$DOMAIN_APPLIANCE_COMMAND_VOLUME_OPTION_APPLIANCE
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_ALL=\
$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_ALL
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DATE=\
$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DATE
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING=\
$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_MISSING
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS=\
$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_IGNORE_DEPENDENCY_DEFECTS
  DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTION_APPLIANCE_SEQUENCE
EOI

  return $?
}

### utility function mutating the execution context provided with a referential
### and a pair of key value
tryMutateReferential() {
  info 'attempting to mutate the execution context'

  local referential="$1"
  local key="$2";
  local value="$3";

  debug "referential="$referential"
key="$key"
value="$value""

  # each 'entry' in a referential is made of 3 lines
  local key_pattern= ; local value_pattern= ; local mutator=

  # iterating through the referential
  while read line; do
    # iterate to initialize locals, then do the processing
    [ -z "$key_pattern" ] && key_pattern="$line" && continue
    [ -z "$value_pattern" ] && value_pattern="$line" && continue
    mutator="$line"

    debug "$(cat << EOI
key_pattern=$key_pattern
value_pattern=$value_pattern
mutator=$mutator
EOI
    )"

    # test the provided key
    exactMatchWithPattern "$key" "$key_pattern"

    if [ $? -ne 0 ]; then
      # the key do not match, test another entry in the referential
      # resetting patterns and mutator for another turn
      key_pattern= ; value_pattern= ; mutator=

      debug "$(cat << EOI
provided key: $key does not match the explored referential key
pattern: $key_pattern
EOI
      )"

      continue
    fi

    # testing value if necessary, a '--' pattern indicating that the key has not
    # value associated in the referential
    if [ ! "$value_pattern" = '--' ]; then
      exactMatchWithPattern "$value" "$value_pattern"

      if [ ! $? -eq 0 ]; then
        # the value do not match, test another entry in the referential
        # resetting patterns and mutator for another turn
        key_pattern= ; value_pattern= ; mutator=

        debug "$(cat << EOI
provided value: $value does not match the explored referential value
pattern: $value_pattern
EOI
        )"

        continue
      fi
    fi

    debug 'key is not associated with any value in the referential'

    debug 'calling '"$mutator"' '"$key"' '"$value"

    # value matched the pattern, call the mutator with both key and value,
    # though value may be empty
    "$mutator" "$key" "$value"
    local returnCode=$?

    [ "$returnCode" -ne 0 ] \
    && debug "$(cat << EOI
The mutator: $mutator failed to execute correctly with key: $key and
value: $value
EOI
          )"

    return $returnCode
  done << EOI
$referential
EOI

  # failed to modify the execution context for this referential. unless it is
  # the most specialized referential (command options) it is not fatal as more
  # specialized referential will be explored for mutation
  debug 'Could not modify the referential: '"$referential"

  return 1
}

### specialized mutator designed to mutate global options settings. Provided
### with 2 arguments with at least one that must be non empty.
tryMutateGlobalOptions() {
  info 'attempting to mutate global options'

  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referential, removing all comments
  local referential="$(deleteCommentLines "$GLOBAL_OPTIONS_REFERENTIAL")" \
  && tryMutateReferential "$referential" "$key" "$value"

  return $?
}

### specialized mutator designed to mutate the domain. Provided with
### 2 arguments with at least one that must be non empty.
tryMutateDomain() {
  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referential, removing all comments
  local referential="$(deleteCommentLines "$DOMAINS_REFERENTIAL")"

  tryMutateReferential "$referential" "$key" "$value"

  return $?
}

### specialized mutator designed to mutate domain options settings. Provided
### with 2 arguments with at least one that must be non empty.
tryMutateDomainOptions() {
  debug 'Not Implemented Yet'

  # there is not any domain option that are supported so far
  return 1
}

### specialized mutator designed to mutate global commands settings. Provided
### with 2 arguments with at least one that must be non empty.
tryMutateGlobalCommand() {
  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referential, removing all comments
  local referential="$(deleteCommentLines "$GLOBAL_COMMANDS_REFERENTIAL")"

  tryMutateReferential "$referential" "$key" "$value"

  return $?
}

### attempt to mutate a domain command. Test all domains command in chain. if
### all fail, it means the key and value are not domain commands
tryMutateDomainCommand() {
  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referentials, removing all comments
  local bootstrap_referential="$(
    deleteCommentLines "$DOMAIN_BOOTSTRAP_COMMANDS_REFERENTIAL"
  )"

  local image_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMANDS_REFERENTIAL"
  )"

  local appliance_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMANDS_REFERENTIAL"
  )"

  tryMutateReferential "$bootstrap_referential" "$key" "$value" \
  || tryMutateReferential "$image_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_referential" "$key" "$value"

  return $?
}

### attempt to modify the execution context related to options of global
### commands.
tryMutateGlobalCommandOptions() {
  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referentials, removing all comments
  local help_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_HELP_OPTIONS_REFERENTIAL"
  )"

  local info_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_INFO_OPTIONS_REFERENTIAL"
  )"

  local install_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_INSTALL_OPTIONS_REFERENTIAL"
  )"

  local pack_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_PACK_OPTIONS_REFERENTIAL"
  )"

  local unpack_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_UNPACK_OPTIONS_REFERENTIAL"
  )"

  local vagrant_referential="$(
    deleteCommentLines "$GLOBAL_COMMAND_VAGRANT_OPTIONS_REFERENTIAL"
  )"

  # chaining mutation attempt, if all fail, argument were not about global
  # command options
  tryMutateReferential "$help_referential" "$key" "$value" \
  || tryMutateReferential "$info_referential" "$key" "$value" \
  || tryMutateReferential "$install_referential" "$key" "$value" \
  || tryMutateReferential "$pack_referential" "$key" "$value" \
  || tryMutateReferential "$unpack_referential" "$key" "$value" \
  || tryMutateReferential "$vagrant_referential" "$key" "$value"

  return $?
}

tryMutateDomainCommandOptions() {
  # key MUST be set
  local key="$1";
  local value="$2";

  debug "key=$key
value=$value"

  # clean referentials, removing all comments
  local bootstrap_check_referential="$(
    deleteCommentLines "$DOMAIN_BOOTSTRAP_COMMAND_CHECK_OPTIONS_REFERENTIAL"
  )"

  local bootstrap_run_referential="$(
    deleteCommentLines "$DOMAIN_BOOTSTRAP_COMMAND_RUN_OPTIONS_REFERENTIAL"
  )"

  local image_build_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_BUILD_OPTIONS_REFERENTIAL"
  )"

  local image_list_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_LIST_OPTIONS_REFERENTIAL"
  )"

  local image_check_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_CHECK_OPTIONS_REFERENTIAL"
  )"

  local image_info_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_INFO_OPTIONS_REFERENTIAL"
  )"

  local image_upgrade_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL"
  )"

  local image_factorize_referential="$(
    deleteCommentLines "$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTIONS_REFERENTIAL"
  )"

  local appliance_build_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTIONS_REFERENTIAL"
  )"

  local appliance_list_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_LIST_OPTIONS_REFERENTIAL"
  )"

  local appliance_check_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_CHECK_OPTIONS_REFERENTIAL"
  )"

  local appliance_info_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_INFO_OPTIONS_REFERENTIAL"
  )"

  local appliance_upgrade_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_UPGRADE_OPTIONS_REFERENTIAL"
  )"

  local appliance_start_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_START_OPTIONS_REFERENTIAL"
  )"

  local appliance_stop_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_STOP_OPTIONS_REFERENTIAL"
  )"

  local appliance_volume_referential="$(
    deleteCommentLines "$DOMAIN_APPLIANCE_COMMAND_VOLUME_OPTIONS_REFERENTIAL"
  )"

  tryMutateReferential "$bootstrap_check_referential" "$key" "$value" \
  || tryMutateReferential "$bootstrap_run_referential" "$key" "$value" \
  || tryMutateReferential "$image_build_referential" "$key" "$value" \
  || tryMutateReferential "$image_list_referential" "$key" "$value" \
  || tryMutateReferential "$image_check_referential" "$key" "$value" \
  || tryMutateReferential "$image_info_referential" "$key" "$value" \
  || tryMutateReferential "$image_upgrade_referential" "$key" "$value" \
  || tryMutateReferential "$image_factorize_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_build_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_list_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_check_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_info_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_upgrade_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_start_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_stop_referential" "$key" "$value" \
  || tryMutateReferential "$appliance_volume_referential" "$key" "$value"

  return $?
}

### mutates the execution context with a key and a value as arguments
tryMutateExecutionContext() {
  local key="$1"
  local value="$2"

  debug "key=$key
value=$value"

  # contextual mutation of the execution environment
  # - modification of global option is context free
  # - modification of the domain is ok only if not already set
  # - modification of domain option ok if domain is set
  # - modification of the command ok if not already set and depends if domain is
  #   set or not => global command or domain command
  # - command options modification can only take place after a command is set
  # as a result, a pair <key value> is used to mutate in order :
  # - global options                                   | more     ^ less
  # - domain                                           | specific | specific
  # - domain options                                   |          |
  # - global command or domain command                 |          |
  # - global command options or domain command options V          |
  #
  # Moreover, mutating global command and domain command are mutually exclusive
  # based on the domain set
  # same thing about global command option and domain command option, makes
  # sense.
  # general logic is following. The deeper you go the more specific you get:
  #
  # try mutate global option
  # `-> success => return 0
  # `-> failure ->
  #     try mutate domain
  #     `-> success => return 0
  #     `-> failure ->
  #         `-> try mutate domain option
  #             `-> success => return 0
  #             `-> failure ->
  #                 try mutate global command
  #                 `-> success => return 0
  #                 `-> failure ->
  #                     `-> try mutate domain command
  #                         `-> success => return 0
  #                         `-> failure ->
  #                             `-> try mutate global command options
  #                                 `-> success => return 0
  #                                 `-> failure ->
  #                                     try mutate domain command options
  #                                     `-> success => return 0
  #                                     `-> failure => return 1

  # chaining mutators by specificity order
  tryMutateGlobalOptions "$key" "$value" \
  || tryMutateDomain "$key" "$value" \
  || tryMutateDomainOptions "$key" "$value" \
  || tryMutateGlobalCommand "$key" "$value" \
  || tryMutateDomainCommand "$key" "$value" \
  || tryMutateGlobalCommandOptions "$key" "$value" \
  || tryMutateDomainCommandOptions "$key" "$value"

  return $?
}

### internal function attempting to mutate the execution context with a provided
### argument of the form key=value
tryMutateExecutionContextWithKeyEqualsValueArg() {
  if ! isPair "$1"; then
    debug 'A pair is needed here. '"$1"' is not a pair'
    return 1
  fi

  local key="$(keyOf "$1")"
  local value="$(valueOf "$1")"

  debug "key=$key
value=$value"

  tryMutateExecutionContext "$key" "$value"

  return $?
}

### build the final execution context regarding provided arguments
buildExecutionContextFromArguments() {
  info 'attempting to mutate the execution context with provided arguments'

  # the arguments provided could take 2 different forms :
  # - simple switch
  # - key-value pair
  # The simple switch may have the dashed or double dashed form
  # The key-value pair may have the space or the '=' as separator. A space
  # character could be specified more than once. This is not the case for the
  # '=' character separator.

  # description of the algorithm:
  # As arguments may take several forms that are parsed differently, the
  # behavior of the algorithm depends of the form of the argument.
  # The most deterministic form is the key=value form.
  # Thus, the algorithm will attempt to mutate the execution context trying to
  # extract key and value from the next argument.
  # If the key/value extraction fails, the algorithm will try to mutate the
  # execution context with the next argument as if it had the dashed or double
  # dashed form. If it fails, the algorithm will attempt to extract the next
  # argument and consider it as the value of the previous one (that is the key
  # therefore)

  local result=1
  local extractedKeyFromArg=

  local arg=
  for arg in $@; do
    debug 'current parsed argument : '"$arg"

    if [ -z "$extractedKeyFromArg" ]; then
      if tryMutateExecutionContextWithKeyEqualsValueArg "$arg"; then
        debug 'key=value args successfully altered the execution context'

        result=0
        continue
      fi

      if tryMutateExecutionContext "$arg"; then
        debug 'single arg successfully altered the execution context'

        result=0
        continue
      fi

      debug 'mutation failed with arg: '"$arg"' continuing...'
      extractedKeyFromArg="$arg"

      result=1
    else
      if tryMutateExecutionContext "$extractedKeyFromArg" "$arg"; then
        debug 'key value args successfully altered the execution context'

        result=0
      else
        debug "$(cat << EOI
Failed to modify the execution context with key: $extractedKeyFromArg and
value: $arg
EOI
        )"

        result=1
      fi

      extractedKeyFromArg=
    fi
  done

  return $result
}

### helper function executing the help command with its options if required
executeHelpCommand() {
  if [ "$COMMAND" = 'help' ]; then
    info 'help command has been requested'

    local mode="$GLOBAL_COMMAND_HELP_OPTION_MODE"
    [ "$mode" = '-H' ] || [ "$mode" = '--full' ]
    local fullMode=$?

    if [ "$fullMode" -eq 0 ]; then
      info 'full mode help requested'
      usageFull 
    else
      info 'brief mode help requested'
      usage
    fi
  else
    info 'help was not the requested command'
    return 1
  fi

  return 0
}

### helper function executing the info command with its options if required
executeInfoCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### helper function executing the install command with its options if required
executeInstallCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### helper function executing the pack command with its options if required
executePackCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### helper function executing the unpack command with its options if required
executeUnpackCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### helper function executing the vagrant command with its options if required
executeVagrantCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the check command of the bootstrap domain
executeBootstrapCheckCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the check command of the bootstrap domain
executeBootstrapRunCommand() {
  # TODO handle options, draft version
  if [ "$DOMAIN" = 'bootstrap' ] \
     && [ "$COMMAND" = 'run' ]; then
    info 'bootstrap run requested'

    bootstrap_run

    return $?
  fi

  return 1
}

### execute the build command of the image domain
executeImageBuildCommand() {
  # TODO handle options, incomplete
  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'build' ] \
     || [ -z "$DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE" ]; then
    info "incomplete or incorrect execution context:
  DOMAIN=$DOMAIN
  COMMAND=$COMMAND
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE"
    return 1
  fi

  info 'splitting provided sequence using space character'
  local sequence="$(
    splitSequence \
    "$DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE" \
    ','
  )" \
  && sequence="$(makeUnique "$sequence")" \
  || return $?

  debug 'image sequence to build :'"$sequence"

  # build each image in the sequence, calling the right script in a subshell
  local image=
  for image in $sequence; do
    debug 'calling image_build '"$image"

    image_build "$image" \
    || return $?
  done

  return 0
}

### execute the list command of the image domain
executeImageListCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the check command of the image domain
executeImageCheckCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the info command of the image domain
executeImageInfoCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the upgrade command of the image domain
executeImageUpgradeCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the factorize command of the image domain
executeImageFactorizeCommand() {
  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'factorize' ] \
     || [ -z "$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME" ] \
     || [ -z "$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE" ]; then
    info "incomplete or incorrect execution context:
  DOMAIN=$DOMAIN
  COMMAND=$COMMAND
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE"
    return 1
  fi

  # call the feature
  image_factorize

  return $?
}

### execute the build command of the appliance domain
executeApplianceBuildCommand() {
  # TODO handle options, incomplete
  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'build' ] \
     || [ -z "$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE" ]; then
    info "incomplete or incorrect execution context:
  DOMAIN=$DOMAIN
  COMMAND=$COMMAND
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE"
    return 1
  fi

  # the sequence is comma separated, get it space separated
  local sequence="$(
    splitSequence \
    "$DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE" \
    ','
  )" \
  && sequence="$(makeUnique "$sequence")" \
  || return $?

  debug 'appliance sequence to build: '"$sequence"

  # build each appliance in the sequence, calling the right script in a subshell
  local appliance=
  for appliance in $sequence; do
    debug 'calling appliance_manage '"$appliance"

    ( appliance_manage "$appliance" ) \
    || return $?
  done

  return 0
}

### execute the list command of the appliance domain
executeApplianceListCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the check command of the appliance domain
executeApplianceCheckCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the info command of the appliance domain
executeApplianceInfoCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the upgrade command of the appliance domain
executeApplianceUpgradeCommand() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### execute the start command of the appliance domain
executeApplianceStartCommand() {
  # TODO handle options, incomplete
  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'start' ] \
     || [ -z "$DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE" ]; then
    info "incomplete or incorrect execution context:
  DOMAIN=$DOMAIN
  COMMAND=$COMMAND
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE"
    return 1
  fi

  # the sequence is comma separated, get it space separated
  local sequence="$(
    splitSequence \
    "$DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE" \
    ','
  )" \
  && sequence="$(makeUnique "$sequence")" \
  || return $?

  debug 'appliance sequence to start: '"$sequence"

  # build each appliance in the sequence, calling the right script in a subshell
  local appliance=
  for appliance in $sequence; do
    debug 'calling appliance_manage '"$appliance"

    ( appliance_manage "$appliance" ) \
    || return $?
  done

  return 0
}

### execute the stop command of the appliance domain
executeApplianceStopCommand() {
  # TODO handle options, incomplete
  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'stop' ] \
     || [ -z "$DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE" ]; then
    info "incomplete or incorrect execution context:
  DOMAIN=$DOMAIN
  COMMAND=$COMMAND
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE=\
$DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE"
    return 1
  fi

  # the sequence is comma separated, get it space separated
  local sequence="$(
    splitSequence \
    "$DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE" \
    ','
  )" \
  && sequence="$(makeUnique "$sequence")" \
  || return $?

  debug 'appliance sequence to stop: '"$sequence"

  # build each appliance in the sequence, calling the right script in a subshell
  local appliance=
  for appliance in $sequence; do
    debug 'calling appliance_manage '"$appliance"

    ( appliance_manage "$appliance" ) \
    || return $?
  done

  return 0
}

### execute the volume command of the appliance domain
executeApplianceVolumeCommand() {
  info 'executing appliance volume command'

  appliance_checkExecutionContextForVolumeCommand \
  && appliance_volumeExecuteSubcommand

  return $?
}

### helper function executing the specified bootstrap command
executeBootstrapCommand() {
  info 'attempting to execute one bootstrap command one after another'

  executeBootstrapCheckCommand \
  || executeBootstrapRunCommand

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && info 'failed to execute bootstrap command'

  return $returnCode
}

### helper function executing the specified image command
executeImageCommand() {
  info 'attempting to execute one image command one after another'

  executeImageBuildCommand \
  || executeImageListCommand \
  || executeImageCheckCommand \
  || executeImageInfoCommand \
  || executeImageUpgradeCommand \
  || executeImageFactorizeCommand

  local returnCode=$?

  [ $returnCode -ne 0 ] \
    && info 'failed to execute image command'

  return $returnCode
}

### helper function executing the specified apliance command
executeApplianceCommand() {
  info 'attempting to execute one appliance command one after another'

  executeApplianceBuildCommand \
  || executeApplianceListCommand \
  || executeApplianceCheckCommand \
  || executeApplianceInfoCommand \
  || executeApplianceUpgradeCommand \
  || executeApplianceStartCommand \
  || executeApplianceStopCommand \
  || executeApplianceVolumeCommand

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && info 'failed to execute appliance command'

  return $returnCode
}

### helper function executing one global command if specified
executeGlobalCommand() {
  info 'Attempting to execute one global command one after another'

  executeHelpCommand \
  || executeInfoCommand \
  || executeInstallCommand \
  || executePackCommand \
  || executeUnpackCommand \
  || executeVagrantCommand

  local returnCode=$?

  [ $returnCode -ne 0 ] \
    && info 'failed to execute global command'

  return $returnCode
}

### helper function executing one domain command if specified
executeDomainCommand() {
  info 'attempting to execute one command from all domains one after another'

  executeBootstrapCommand \
  || executeImageCommand \
  || executeApplianceCommand

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && info 'failed to execute executeDomainCommand'

  return $returnCode
}

### Helper function activating the trace mode if requested (--log-level=trace)
### and executing this script from its very start
executeWithTraceIfRequested() {
  if isTraceLogLevel \
     && [ ! ${TRACE_ENABLED+0} ]; then
    debug 'trace enabled; restarting script...'

    local carrier_code="$(
      sed '2i\
set -x' "${CARRIER_SCRIPT_PATH}"
    )"

    TRACE_ENABLED= \
    CALLED_SCRIPT="$CALLED_SCRIPT" \
      sh -c 'eval '"$carrier_code" \
      '' "$@"

    local returnCode=$?
    debug 'script execution finished, exiting with status code :'$returnCode
    exit $returnCode
  fi

  return 0
}

### Once the execution context is set, execute the script using it. As the
### execution context is verified when set, one function must succeed
executeWithContext() {
  info 'executing carrier with setup context'

  debug "Execution Context:
$(debugOutputExecutionContext)"

  executeGlobalCommand \
  || executeDomainCommand

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'Failed to execute carrier with current execution context'

  return $returnCode
}

#### Execution context mutator definition area #################################

### Mutator to set the log level. Valid call in any circumstances
contextSetLogLevel() {
  info 'setting log level global option'

  # key/value pair
  GLOBAL_OPTION_LOG_LEVEL="$2"

  return 0
}

### Mutator to set the log output. Valid call in any circumstances
contextSetLogOutput() {
  info 'setting log output global option'

  [ "$2" = '&1' ] \
    && warning "$(cat << EOI
cannot set log output to standard output, defaulting to standard error
EOI
    )" \
  && return 1

  # key/value pair
  GLOBAL_OPTION_LOG_OUTPUT="$2"

  return 0
}

### Mutator to set a global command. Valid call if:
### - no domain specified
contextSetGlobalCommand() {
  info 'setting global command'

  if [ ! -z "$DOMAIN" ]; then
    info 'A domain name must not be specified to set the '"$1"' global command'
    return 1
  fi

  # the key specified (first argument) is the command
  COMMAND="$1"

  return 0
}

### mutator to set the help mode. Valid call if:
### - command is 'help'
contextSetHelpMode() {
  info 'setting help mode'

  if [ ! "$COMMAND" = 'help' ]; then
    info "$(cat << EOI
contextSetHelpMode() can only be used when specified command is help
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  # the key (first value) is the help mode
  GLOBAL_COMMAND_HELP_OPTION_MODE="$1"

  return 0
}

# TODO: NYI
contextSetPackFetchOnly() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### mutator to set the domain. Valid call if:
### - no global command specified sooner
contextSetDomain() {
  info 'setting domain'

  # empty domain and non empty command denotes a global command specified sooner
  if [ -z "$DOMAIN" ] \
     && [ ! -z "$COMMAND" ]; then
    info "$(cat << EOI
contextSetDomain() can only be used if domain and command are unspecified
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  # the specified key (first arg) is the domain
  DOMAIN="$1"

  return 0
}

### mutator to setup the bootstrap command. Valid call if:
### - domain is bootstrap
contextSetBootstrapCommand() {
  info 'setting bootstrap command'

  if [ ! "$DOMAIN" = 'bootstrap' ]; then
    info "$(cat << EOI
contextSetBootstrapCommand() can only be called if DOMAIN is bootstrap
  current DOMAIN=$DOMAIN
EOI
    )"
    return 1
  fi

  # the specified key (first arg) is the bootstrap command
  COMMAND="$1"

  return 0
}

### mutator to setup the image command. Valid call if:
### - domain is image
contextSetImageCommand() {
  info 'setting image command'

  if [ ! "$DOMAIN" = 'image' ]; then
    info "$(cat << EOI
contextSetImageCommand() can only be called if domain is image
  current DOMAIN=$DOMAIN
EOI
    )"
    return 1
  fi

  # the specified key (first arg) is the image command
  COMMAND="$1"

  return 0
}

### mutator to setup the sequence of image to build. Valid call if:
### - domain is image
### - command is build
contextSetImageBuildImageSequence() {
  info 'setting image build image sequence'

  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'build' ]; then
  info "$(cat << EOI
contextSetImageBuildImageSequence() can only be used when the domain is image
and the command is build.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
  )"
    return 1
  fi

  # the key (first arg) is the image sequence
  DOMAIN_IMAGE_COMMAND_BUILD_OPTION_IMAGE_SEQUENCE="$1"

  return 0
}

### TODO NYI
contextSetImageListOnlyBuilt() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageBuildRemoveExisting() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageListOnlyRemote() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageInfoOnlyRequires() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageListAll() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageCheckAllBuilt() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageInfoAllProps() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageUpgradeAll() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageInfoOnlyBaseImage() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageListOnlyLocal() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageInfoImage() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageListOnlyNotBuilt() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageUpgradeImageSequence() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetImageCheckImageSequence() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### mutator to set the prefix of the base image.
### domain is image, command is factorize
### $1: is the key of the option
### $2: value of the option
contextSetImageFactorizeBaseImagePrefix() {
  info 'setting image factorize base image prefix'

  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'factorize' ]; then
  info "$(cat << EOI
contextSetImageFactorizeBaseImagePrefix() can only be used when the domain is
image and the command is factorize.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
  )"
    return 1
  fi

  # the prefix is the second argument
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_PREFIX="$2"

  return 0
}

### mutator to set the prefix of factorize images.
### domain is image, command is factorize
### $1: is the key of the option
### $2: value of the option
contextSetImageFactorizeFactorizedImagePrefix() {
  info 'setting image factorize factorized image prefix'

  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'factorize' ]; then
  info "$(cat << EOI
contextSetImageFactorizeFactorizedImagePrefix() can only be used when the
domain is image and the command is factorize.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
  )"
    return 1
  fi

  # the prefix is the second argument
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_FACTORIZED_IMAGE_PREFIX="$2"

  return 0
}

### mutator to set the resulting base image name
### domain is image, command is factorize
### $1: is the key of the option
### $2: value of the option
contextSetImageFactorizeBaseImageName() {
  info 'setting image factorize base image name'

  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'factorize' ]; then
  info "$(cat << EOI
contextSetImageFactorizeBaseImageName() can only be used when the domain is
image and the command is factorize.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
  )"
    return 1
  fi

  # the image name is the second argument
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME="$2"

  return 0
}


### mutator to set the image sequence to factorize, comma separated
### domain is image, command is factorize
### $1: is the key of the option
### $2: value of the option
contextSetImageFactorizeImageSequence() {
  info 'setting image factorize image sequence'

  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'factorize' ]; then
  info "$(cat << EOI
contextSetImageFactorizeImageSequence() can only be used when the domain is
image and the command is factorize.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
  )"
    return 1
  fi

  # the image sequence is the second argument
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE="$2"

  return 0
}


### mutator to indicate if original factorized image must be removed
### domain is image, command is factorize
### $1: is the key of the option
contextSetImageFactorizeRemoveOriginalImages() {
  info 'setting image factorize remove original images flag'

  if [ ! "$DOMAIN" = 'image' ] \
     || [ ! "$COMMAND" = 'factorize' ]; then
  info "$(cat << EOI
contextSetImageFactorizeRemoveOriginalImages() can only be used when the domain
is image and the command is factorize.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
  )"
    return 1
  fi

  # no value here
  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_REMOVE_ORIGINAL_IMAGES='yes'

  return 0
}

### mutator to indicate if resulting image must overwrite existing images
### domain is image, command is factorize
### $1: is the key of the option
contextSetImageFactorizeOverwriteExistingImages() {
  info 'setting factorize image overwrite behavior on'

  DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_OVERWRITE_EXISTING='yes'

  return $?
}

### mutator to setup the appliance command. Valid call if:
### - domain is appliance
contextSetApplianceCommand() {
  info 'setting appliance command'

  if [ ! "$DOMAIN" = 'appliance' ]; then
    info "$(cat << EOI
contextSetApplianceCommand() can only be called if domain is appliance
  current DOMAIN=$DOMAIN
EOI
    )"
    return 1
  fi

  # the specified key (first arg) is the appliance command
  COMMAND="$1"

  return 0
}

### TODO NYI
contextSetApplianceInfoAppliance() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetApplianceListOnlyLocal() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetApplianceListOnlyNotBuilt() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetApplianceListOnlyBuilt() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetApplianceInfoOnlyBase() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetApplianceStartBuild() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetApplianceStartDontBuild() {
  :

  debug 'Not Implemented Yet'
  return 1
}

contextSetApplianceCheckApplianceList() {
  :

  debug 'Not Implemented Yet'
  return 1
}

contextSetApplianceVolumeClone() {
  info 'setting appliance volume clone volume map'

  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'volume' ]; then
    info "$(cat << EOI
contextSetApplianceVolumeClone() can only be called when domain is
appliance and command is volume.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_CLONE=0
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_CLONE_VOLUME_MAP="$(
    splitSequence "$2" ',')"

  return 0
}

contextSetApplianceVolumesAppliance() {
  info 'setting appliance name for appliance volume command execution'

  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'volume' ]; then
    info "$(cat << EOI
contextSetApplianceVolumesAppliance() can only be called when domain is
appliance and command is volume.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  DOMAIN_APPLIANCE_COMMAND_VOLUME_OPTION_APPLIANCE="$2"

  return 0
}

contextSetApplianceVolumeDump() {
  info 'setting appliance volume dump volume list'

  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'volume' ]; then
    info "$(cat << EOI
contextSetApplianceVolumeDump() can only be called when domain is
appliance and command is volume.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_DUMP=0
  DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_CLONE_VOLUME_MAP="$(
    splitSequence "$2" ',')"

  return 0
}

contextSetApplianceVolumeDumpDirectoryPath() {
  :
}

### TODO NYI
contextSetApplianceListAll() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetApplianceCheckAll() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetApplianceInfoAllProps() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### TODO NYI
contextSetApplianceUpgradeAll() {
  :

  debug 'Not Implemented Yet'
  return 1
}

contextSetApplianceUpgradeApplianceSequence() {
  :

  debug 'Not Implemented Yet'
  return 1
}

### mutator to setup the sequence of appliance to build. Valid call if:
### - domain is appliance
### - command is build
contextSetApplianceBuildApplianceSequence() {
  info 'setting appliance build appliance sequence'

  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'build' ]; then
    info "$(cat << EOI
contextSetApplianceBuildApplianceSequence() can only be called when domain is
appliance and command is build.
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  # the key (first arg) is the appliance sequence
  DOMAIN_APPLIANCE_COMMAND_BUILD_OPTION_APPLIANCE_SEQUENCE="$1"

  return 0
}

### mutator to setup the sequence of appliance to start. Valid call if:
### - domain is appliance
### - command is start
contextSetApplianceStartApplianceSequence() {
  info 'setting appliance start appliance sequence'

  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'start' ]; then
    info "$(cat << EOI
contextSetApplianceStartApplianceSequence() can only be used if domain is
appliance and command is start
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  # the key (first arg) is the appliance sequence
  DOMAIN_APPLIANCE_COMMAND_START_OPTION_APPLIANCE_SEQUENCE="$1"

  return 0
}

### mutator to setup the sequence of appliance to start. Valid call if:
### - domain is appliance
### - command is start
contextSetApplianceStopApplianceSequence() {
  info 'setting appliance stop appliance sequence'

  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'stop' ]; then
    info "$(cat << EOI
contextSetApplianceStopApplianceSequence() can only be used if domain is
appliance and command is stop
  current DOMAIN=$DOMAIN
  current COMMAND=$COMMAND
EOI
    )"
    return 1
  fi

  # the key (first arg) is the appliance sequence
  DOMAIN_APPLIANCE_COMMAND_STOP_OPTION_APPLIANCE_SEQUENCE="$1"

  return 0
}

#### End of execution context mutator definition area ##########################

#### bootstrap domain specific functions

### gives the root directory of staging area used for bootstrap domain commands
bootstrap_getStagingRootDirectory() {
  info 'getting root staging directory'

  echo "${CARRIER_TMP_DIR}"/bootstrap

  return $?
}

### initialize a shell variable containing a directory id for the bootstrap
### staging area
bootstrap_initializeBootstrapStagingDirectory() {
  info 'initializing bootstrap staging directory'

  if [ ! -z "$DOMAIN_BOOTSTRAP_STAGING_DIRECTORY" ]; then
    warning 'bootstrap staging already initialized'
    return 0
  fi

  DOMAIN_BOOTSTRAP_STAGING_DIRECTORY="$(
    bootstrap_getStagingRootDirectory
  )"/"$(generateRandomString)" \
  || return $?

  mkdir -p "$DOMAIN_BOOTSTRAP_STAGING_DIRECTORY" \
  || fatal 'Could not create bootstrap staging directory'
  
  return $?
}

### return the name of the staging directory for the bootstrap feature
bootstrap_getBootstrapStagingDirectory() {
  info 'getting bootstrap staging directory'

  [ -z "$DOMAIN_BOOTSTRAP_STAGING_DIRECTORY" ] \
  && error 'bootstrap staging directory has not been initialized' \
  && return 1

  echo "$DOMAIN_BOOTSTRAP_STAGING_DIRECTORY"

  return $?
}

### simply copy the bootstrap dir from share to a temporary staging area
bootstrap_fillBootstrapStagingArea() {
  info 'Copying bootstrap files in bootstrap staging area...'

  find \
    "$CARRIER_SHARE_BOOTSTRAP_DIR" \
    -type f \
    ! -name '.' \
    -exec cp -r {} "$(bootstrap_getBootstrapStagingDirectory)" \; \
  || ( returnCode=$? \
       && fatal 'Unabled to copy bootstrap files in staging area.' \
       && return $returnCode )

  bootstrap_fetchLibInBootstrapStagingArea

  return $?
}

### copy useful lib script to the temporary staging area where bootstrap file
### reside
bootstrap_fetchLibInBootstrapStagingArea() {
  info 'Fetching utility file in bootstrap staging area'

  cp "$CARRIER_LIB_DIR"/exportPackageTo \
     "$CARRIER_LIB_DIR"/importPackageFrom \
     "$CARRIER_LIB_DIR"/functions.sh \
     "$(bootstrap_getBootstrapStagingDirectory)" \
  || ( returnCode=$? \
       && fatal 'Unabled to copy utilities files in staging area.' \
       && return $returnCode )

  return $?
}

### build the bootstrap docker image responsible to bootstrap the system
bootstrap_build() {
  info 'building bootstrap docker image'

  cd "$(bootstrap_getBootstrapStagingDirectory)" \
  && docker build --squash -t metabarj0/bootstrap . \
  && docker image prune -f \
  && cd - 1>/dev/null 2>&1 \
  || ( returnCode=$? \
       && fatal 'bootstrap image build failed.' \
       && return $returnCode )

  return $?
}

### setup environment for bootstrap image run
bootstrap_setupEnvironmentForRun() {
  info 'setting up environment for bootstrap image run'

  cat << EOI
Specify the version of GCC you want to build. Note that today, only 7.2.0
and 7.3.0 are supported : [7.3.0]
EOI

  GCC_VERSION="$(readValueWithDefault '7.3.0')"

  cat << EOI
Specify the binutils version you want to build. Note that for GCC 7.3.0, 2.29
is a working version : [2.29]
EOI

  BINUTILS_VERSION="$(readValueWithDefault '2.29')"

  cat << EOI
Specify the version of Kernel headers you want to use. Note that for GCC 7.3.0
the 4.14.14 version works perfectly well. Moreover, only version 4+ is
supported : [4.14.14]
EOI

  KERNEL_VERSION="$(readValueWithDefault '4.14.14')"

  cat << EOI
Specify the make version you want to use. Note that version 4.2 is
good : [4.2]
EOI

  MAKE_VERSION="$(readValueWithDefault '4.2')"

  return $?
}

### remove the bootstrap image if asked
bootstrap_removeBootstrapImageIfAsked() {
  cat << EOI
Bootstrapping successfully done! Would you like to remove the
metabarj0/bootstrap docker image? [Y/n]
EOI

  local remove_bootstrap="$(readValueWithDefault 'Y')"

  if [ $remove_bootstrap = 'Y' ] || [ $remove_bootstrap = 'y' ]; then
    docker rmi metabarj0/bootstrap

    local returnCode=$?

    [ $returnCode -ne 0 ] \
    && fatal 'Unabled to remove the bootstrap image.' \
    && return $returnCode
  fi

  return 0
}

### ask for some configuration and run the bootstrap image to bootstrap the
### system
bootstrap_run_image() {
  info 'running the bootstrap docker image'

  # TODO : take into account some variable of the execution context (auto answer yes)

  bootstrap_setupEnvironmentForRun

  # run the bootstrap image
  docker run --rm -it \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -e GCC_VERSION="$GCC_VERSION" \
    -e BINUTILS_VERSION="$BINUTILS_VERSION" \
    -e KERNEL_VERSION="$KERNEL_VERSION" \
    -e MAKE_VERSION="$MAKE_VERSION" \
    metabarj0/bootstrap

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'bootstrap image failed to run correctly.' \
  && return $returnCode

  bootstrap_removeBootstrapImageIfAsked

  return $?
}

### once the system is bootstrapped, clean the staging area
bootstrap_cleanupStagingArea() {
  info 'cleaning up the bootstrap staging area'

  rm -rf \
    "$(bootstrap_getBootstrapStagingDirectory)" \
  || ( returnCode=$? \
       && fatal 'could not clean bootstrap staging area' \
       && return $returnCode ) \
  || return $?

  removeDirectoryIfEmpty "$(bootstrap_getStagingRootDirectory)"

  return $?
}

### run the full bootstrap procedure
bootstrap_run() {
  info 'Running the bootstrap procedure'

  bootstrap_initializeBootstrapStagingDirectory \
  && bootstrap_fillBootstrapStagingArea \
  && bootstrap_build \
  && bootstrap_run_image \
  && bootstrap_cleanupStagingArea

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'bootstrap procedure failed at some point'

  return $returnCode
}
#### End of bootstrap domain specific functions

#### image domain specific functions

### prepare a joined sequence of image to be factorized. The input is a
### sequence joined with ','. The output will be a sequence of images space
### separated.
image_prepareImageSequenceForFactorization() {
  info 'Preparing image sequence value argument'

  local sequence="$(
    splitSequence \
      "$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_IMAGE_SEQUENCE" \
      ','
  )" \
  && sequence="$(makeUnique "$sequence")" \
  || return $?

  echo "$sequence"

  return $?
}

### check if the mandatory specified image exists on docker host. If the image
### does not exist, trigger an error message
### $1: image name
image_mustExistsOnDockerHost() {
  info 'checking a mandatory image existence on the docker host'

  local image="$1"

  local id="$(getDockerImageIdFromName "$image")" \
  || return $?

  if [ -z $id ]; then
    error "$(cat << EOI
The specified image "$image" does not exist on the docker host
EOI
    )"
    return 1
  fi

  echo "$id"

  return $?
}

### check on the docker host if the image exists. Does not trigger an error if
### the image does not exist but return a positive value
### $1 image name
image_checkIfExistsOnDockerHost() {
  info 'checking an image existence on the docker host'

  local image="$1"

  local id=$(getDockerImageIdFromName "$image") \
  || return $?

  [ -z $id ] && return 1

  echo "$id"

  return $?
}

### extract the content of the image.dist file of the specified docker image.
### The file list is sorted and deduped
### $1 docker image name present on the docker host
image_extractImageDistFileContentFromImage() {
  info 'Extracting image.dist file content of '"$1"

  local file_sequence="$(
    docker run \
      -u root \
      --rm \
      --entrypoint '' \
      "$1" cat /image.dist \
    | sort \
    | uniq
  )" \
  || return $?

  if [ -z "$file_sequence" ]; then
    fatal "Could not extract the image.dist file from the "$1" docker
image. Is that image well formed?"
    return 1
  fi

  echo "$file_sequence"

  return 0
}

### initialize a shell variable containing a directory id for the factorize
### command staging area
image_initializeFactorizeStagingDirectory() {
  info 'Initializing image factorize staging area'

  if [ ! -z "$DOMAIN_IMAGE_COMMAND_FACTORIZE_STAGING_DIRECTORY" ]; then
    warning 'image factorize staging area is already initialized'
    return 0
  fi

  DOMAIN_IMAGE_COMMAND_FACTORIZE_STAGING_DIRECTORY="$(
    image_getStagingRootDirectory
  )"/factorize/"$(generateRandomString)" \
  || return $?

  mkdir -p "$DOMAIN_IMAGE_COMMAND_FACTORIZE_STAGING_DIRECTORY" \
  || fatal 'Could not create image factorize staging directory'
  
  return $?
}

### return the name of the staging directory for the build feature
image_getFactorizeStagingDirectory() {
  info 'getting image factorize staging area directory'

  [ -z "$DOMAIN_IMAGE_COMMAND_FACTORIZE_STAGING_DIRECTORY" ] \
    && error 'Image factorize staging directory has not been initialized' \
    && return 1

  echo "$DOMAIN_IMAGE_COMMAND_FACTORIZE_STAGING_DIRECTORY"

  return $?
}

### create or overwrite files in staging directory for factorize feature
### $1 file name to create/overwrite in staging directory
### $1 content to put in the file
image_addFileInFactorizeStagingAreaWithContent() {
  info 'adding a file in image factorize staging area'

  if [ -z "$1" ] || [ -z "$2" ]; then
    error 'Missing file informations (name and/or content)'
    return 1
  fi

  local staging_directory="$(image_getFactorizeStagingDirectory)" \
  && mkdir -p "$staging_directory" \
  && echo "$2" > "${staging_directory}"/"$1"

  local returnCode=$?

  [ $returnCode -ne 0 ] \
    && fatal 'could not add file in factorize staging area' \
    && return $returnCode

  return $returnCode
}

### remove temporary files created while factorizing images
image_cleanupFactorizeStagingDirectory() {
  info 'cleaning up the staging area for image factorize command'

  rm -rf "$(image_getFactorizeStagingDirectory)"

  local returnCode=$?

  [ $returnCode -ne 0 ] \
    && fatal 'could not clean up the fatctorize staging directory' \
    && return $returnCode

  removeDirectoryIfEmpty "$(image_getStagingRootDirectory)"

  return $?
}

### extract the very first image of the sequance of image to factorize
image_factorizeExtractFirstImageNameOfSequence() {
  info 'extracting the first image of the sequence'

  local sequence="$(image_getImageToFactorizeSequence)" \
  || return $?

  local image=
  for image in $sequence; do
    echo "$image"
    return $?
  done

  return 1
}

### extract the first two image in the image to factorize sequence
image_factorizeGetFirstTwoImages() {
  info 'making a pair with the first two images to factorize'

  local sequence="$(image_getImageToFactorizeSequence)" \
  || return $?

  local image=
  for image in $sequence; do
    [ -z "$first_image" ] \
    && local first_image="$image" && continue \
    || local second_image="$image" && break
  done

  echo "$(makePair "$first_image" "$second_image")"

  return $?
}

### initialize the image.dist file of the base image. It will contains common
### files found in the two very first image iterated
image_initializeBaseImageDistFileInStagingArea() {
  info 'Initializing the base image of factorization'

  local imagePair="$(image_factorizeGetFirstTwoImages)" \
  && local first_image="$(keyOf "$imagePair")" \
  && local second_image="$(valueOf "$imagePair")" \
  && local first_files_sequence="$(
    image_extractImageDistFileContentFromImage "$first_image"
  )" \
  && local second_files_sequence="$(
    image_extractImageDistFileContentFromImage "$second_image"
  )" \
  && image_addFileInFactorizeStagingAreaWithContent \
    'first_files_sequence.dist' \
    "$first_files_sequence" \
  && image_addFileInFactorizeStagingAreaWithContent \
    'second_files_sequence.dist' \
    "$second_files_sequence" \
  && local common_files_sequence="$(
    extractCommonLinesInTwoFiles \
      "$(image_getFactorizeStagingDirectory)"/first_files_sequence.dist \
      "$(image_getFactorizeStagingDirectory)"/second_files_sequence.dist)" \
  && image_addFileInFactorizeStagingAreaWithContent \
    'base.image.dist' \
    "$common_files_sequence"

  return $?
}

### initialize the image sequence to factorize in a shell variable
image_initializeImageToFactorizeSequence() {
  info 'initializing image to factorize sequence'

  if [ -z "$DOMAIN_IMAGE_COMMAND_FACTORIZE_IMAGE_TO_FACTORIZE_SEQUENCE" ]; then
    DOMAIN_IMAGE_COMMAND_FACTORIZE_IMAGE_TO_FACTORIZE_SEQUENCE="$(
      image_prepareImageSequenceForFactorization)"
  fi

  return $?
}

### get the image sequence to factorize. Must initialize it before
image_getImageToFactorizeSequence() {
  info 'getting image to factorize sequence'

  if [ -z "$DOMAIN_IMAGE_COMMAND_FACTORIZE_IMAGE_TO_FACTORIZE_SEQUENCE" ]; then
    image_initializeImageToFactorizeSequence \
    || return $?
  fi

  echo "$DOMAIN_IMAGE_COMMAND_FACTORIZE_IMAGE_TO_FACTORIZE_SEQUENCE"

  return $?
}

### gets the base image dist file path after it has been created. If the file
### does not exist, fatal is triggered
image_factorizeGetBaseImageDistFile() {
  info 'getting base image dist file path'

  local base_image_dist_file="$(
    image_getFactorizeStagingDirectory)"/base.image.dist \
  || return $?

  if [ ! -f "$base_image_dist_file" ]; then
    fatal 'Missing base.image.dist file in staging area'
    return 1
  fi

  echo "$base_image_dist_file"

  return $?
}

### create an image.dist file in the image factorize staging area. THis file is
### extracted from a docker image, created in the staging area. This function
### returns the image.dist file path
image_createImageDistFileFromImageInFactorizeStagingArea() {
  info 'creating a dist file for an image in staging area'

  local image_files_sequence="$(
    image_extractImageDistFileContentFromImage "$image"
  )" \
  && image_addFileInFactorizeStagingAreaWithContent \
    'image.dist' \
    "$image_files_sequence" \
  && local image_dist_file="$(
    image_getFactorizeStagingDirectory)"/'image.dist' \
  || return $?

  echo "$image_dist_file"

  return $?
}

### internal function computing both a base image dist file and an image dist
### file by comparing their content. The result is the creation of one dist
### file for the image and the possible update of the base.image.dist file
### containing common files accross images
### $1: the image name to factorize
### $2: the base image dist file full path
### $3: the resulting factorizable image.dist file, encoded in path64
image_computeBaseAndImageDistFilesInFactorizeStagingArea() {
  info 'computing image and base image dist files in staging area'

  local image="$1"
  local base_image_dist_file="$2"
  local image_dist_file="$3"

  local path64_image_dist_file_name="$(
    path64Encode "$image")".dist \
  && image_addFileInFactorizeStagingAreaWithContent \
    "$path64_image_dist_file_name" \
    "$(comm \
        -1 -3 \
        "$base_image_dist_file" \
        "$image_dist_file")" \
  && image_addFileInFactorizeStagingAreaWithContent \
    'base.image.dist' \
    "$(comm \
        -1 -2 \
        "$base_image_dist_file" \
        "$image_dist_file")"

  return $?
}

### finalize the image.dist file of the base image and all images to factorize.
### A first version of base.image.dist file must be present in the staging area
image_finalizeAllImageDistFileInStagingArea() {
  info 'finalizing image.dist files'

  local base_image_dist_file="$(
    image_factorizeGetBaseImageDistFile)" \
  || return $?

  local image=
  for image in $(image_getImageToFactorizeSequence); do
    image_mustExistsOnDockerHost "$image" 1>/dev/null \
    && local image_dist_file="$(
      image_createImageDistFileFromImageInFactorizeStagingArea "$image")" \
    && image_computeBaseAndImageDistFilesInFactorizeStagingArea \
      "$image" "$base_image_dist_file" "$image_dist_file" \
    || return $?
  done

  return $?
}

### create the image.dist file of the base image in the staging directory
image_createImagesDistFileInStagingDirectory() {
  info 'Creating image dist files in image factorize staging directory'

  image_initializeBaseImageDistFileInStagingArea \
  && image_finalizeAllImageDistFileInStagingArea

  return $?
}

### create the base image of a factorization process. Relies on the file
### base.image.dist create in the image factorize staging area
image_factorizeCreateBaseImage() {
  info 'creating factorized base image'

  local baseImageName="$(image_factorizeBuildBaseImageName)" \
  && image_factorizeInitializeMinimalisticTransfertImage "$baseImageName" \
  && image_factorizeFillBaseImage "$baseImageName"

  return $?
}

### generate a random temporary folder name used as staging directory inside
### containers
### $1: base name of the mount point
image_factorizeGenerateRandomTemporaryMountPoint() {
  info 'Generating random temporary mount point'

  local baseName="$1"

  echo '/tmp/'"$1"

  return $?
}

### Attempts to find a carrier image project directory from an existing docker
### image that exists on the docker host. It may fail if the image specified is
### not a carrier image project
### $1: image name from which deduce the project manifest file path
image_factorizeFindImageProjectManifestProviding() {
  info 'Attempting to find an image project from an image name'

  local imageName="$1"

  local manifests="$(
    find "$CARRIER_SHARE_IMAGES_DIR" -type f -name manifest)" \
  || ( returnCode=$? \
       && fatal 'Could not query image project manifest files' \
       && return $returnCode ) \
  || return $?

  local manifest=
  local provides=
  local foundManifest=
  for manifest in $manifests; do
    provides="$(sourceThenGet "$manifest" 'PROVIDES')" \
    && [ "$provides" = "$imageName" ] \
    && foundManifest="$manifest" \
    && break
  done

  echo "$foundManifest"

  [ ! -z "$foundManifest" ]
}

### Attempts to extract image to factorize final extra dockerfile commands from
### its manifest file.
### $1: the image to factorize from which extract the
###     FINAL_EXTRA_DOCKERFILE_COMMANDS from its manifest file
image_factorizeTryExtractFinalDockerfileCommandsForImage() {
  info 'Attempting to extract extra dockerfile commands from image to factorize'

  local imageName="$1"

  local projectManifest="$(
    image_factorizeFindImageProjectManifestProviding "$imageName")" \
  && local extraCommands="$(
    sourceThenGet "$projectManifest" "FINAL_EXTRA_DOCKERFILE_COMMANDS")" \
  && echo "$extraCommands"

  return $?
}

### generates Dockerfile commands for the factorized image creation using a
### specified base image for an image to factorize
### $1: image to factorize.
### $2: the base image to use in the from command, this is the transfert image
image_factorizeGenerateFactorizedImageDockerfileCommandsFrom() {
  info 'generating Dockerfile commands for a minimalistic image'

  local imageToFactorize="$1"
  local baseImage="$2"

  local fromCommand="FROM $baseImage"
  local extraCommands="$(
    image_factorizeTryExtractFinalDockerfileCommandsForImage "$imageToFactorize"
  )" \
  || return $?

  echo "$fromCommand"$'\n'"$extraCommands"

  return $?
}

### create a minimalistic image to fill later
### $1: image name to create
### $2: image to use as base, defaulted to busybox
image_factorizeInitializeMinimalisticTransfertImage() {
  info 'creating a minimalistic image'

  local imageName="$1"
  local baseImage="$(setValueWithDefault "$2" 'busybox')"

  local dockerfileCommands="FROM $baseImage"

  echo "$dockerfileCommands" | docker build -t "$imageName" - \
  || ( returnCode=$? \
       && fatal 'Could not build a minimalistic image for factorization' \
       && return $returnCode )

  return $?
}

### destroy a previsously created temporary volume in the image factorization
### process
### $1: name of the volume to destroy
image_factorizeDestroyTemporaryVolume() {
  info 'Destroying a temporary volume used to factorize images'

  local volumeName="$1"

  # volume removal can spuriously fail
  local currentAttempt=0
  local maxAttempt=3

  while [ $currentAttempt -lt $maxAttempt ]; do
    docker volume rm -f "$volumeName" 1>/dev/null 2>&1 \
    && break
  done

  local returnCode=$?
  [ $returnCode -ne 0 ] \
  && fatal 'Could not remove a temporary volume'

  return $returnCode
}

### create a temporary volume for the factorization process. This volume will
### be attached to running containers of factorized images and of base image
image_factorizeCreateTemporaryVolume() {
  info 'Creating a temporary volume for the factorization process'

  local randomPathString="$(generateRandomVolumeName 2)" \
  || return $?

  docker volume create "$randomPathString" 1>/dev/null 2>&1 \
  || ( returnCode=$? \
       && fatal 'Could not create a temporary docker volume' \
       && return $returnCode ) \
  || return $?

  echo "$randomPathString"

  return $?
}

### runs an image attached to a temporary volume
### $1: image name to run
### $2: temporary volume name to attach to the running container
image_factorizeRunImageWithVolumeAttached() {
  info 'attempting to run base image with temporary volume'

  local imageName="$1"
  local volumeName="$2"

  local mountPoint="$(
    image_factorizeGenerateRandomTemporaryMountPoint "$volumeName")" \
  || return $?

  local containerID="$(
    docker run \
      --rm -d \
      -v "$volumeName":"$mountPoint" \
      -e MOUNTPOINT="$mountPoint" \
      -u root \
      --entrypoint='' \
      "$imageName" \
      sh -c \
      'while true; do sleep 10; done'
  )" \
  || ( returnCode=$? \
       && fatal 'Could not start the image container' \
       && return $returnCode ) \
  || return $?

  echo "$containerID"

  return $?
}

### copy a file to the source container where to find common files
### $1: running container id
### $2: absolute path of file on host to copy
### $3: absolute path of file in the container
image_factorizeCopyFileToContainerAndSharedVolume() {
  info 'copying a file inside a container and a shared volume'

  local containerID="$1"
  local sourceFilePath="$2"
  local targetFilePath="$3"
  local targetFileName="$(basename "$targetFilePath")"

  docker cp \
    "$sourceFilePath" \
    "$containerID"':'"$targetFilePath" 1>/dev/null 2>&1 \
  && docker exec \
    "$containerID" \
    sh -c 'cp '"$targetFilePath"' "$MOUNTPOINT"/'"$targetFileName" \
  || ( returnCode=$? \
       && fatal 'could not copy file to source container and shared volume' \
       && return $returnCode )

  return $?
}

### copy the base.image.dist file present in the image factorize staging area
### in a running container and the shared volume
### $1: running container identifier
image_factorizeCopyBaseDistFileInContainerAndSharedVolume() {
  info 'copying dist file to container and shared volume'

  local containerId="$1"

  local targetFilePath='/image.dist'
  local sourceFilePath="$(image_factorizeGetBaseImageDistFile)" \
  && image_factorizeCopyFileToContainerAndSharedVolume \
     "$containerId" "$sourceFilePath" "$targetFilePath"

  return $?
}

### Create the base image of the factorization process using common files that
### are present in the first image to factorize sequence
### $1: source container
### $2: target container
### $3: target image name to commit to
image_factorizeCreateBaseImageFromFirstImageInSequence() {
  info 'Copying files accross containers'

  local sourceContainer="$1"
  local targetContainer="$2"
  local targetImageName="$3"

  image_factorizeCopyBaseDistFileInContainerAndSharedVolume "$sourceContainer" \
  && image_factorizeCopyUtilitiesInContainer "$sourceContainer" \
  && image_factorizeExportPackageFromOriginalImageContainerToSharedVolume \
    "$sourceContainer" \
  && image_factorizeCopyUtilitiesInContainer "$targetContainer" \
  && image_factorizeImportPackageFromSharedVolumeToTargetImageContainer \
    "$targetContainer" \
  && image_factorizeCommitContainerToImage "$targetContainer" "$targetImageName"

  return $?
}

### copy common files from one of the image to factorize to the base image.
### temporary volume is used in the process to transfer files from running
### container to running container as it is not supported by docker.
### $1: the base image container running
### $2: the base image name to commit to
### $3: temporary volume name to attach to the running container
image_factorizeCopyCommonFilesInBaseImageContainer() {
  info 'Copying common files to base image'

  local baseImageContainerID="$1"
  local baseImageName="$2"
  local temporaryVolumeName="$3"

  local firstImageToFactorizeName="$(
    image_factorizeExtractFirstImageNameOfSequence)" \
  && local firstImageContainerID="$(
    image_factorizeRunImageWithVolumeAttached \
    "$firstImageToFactorizeName" "$temporaryVolumeName")" \
  && image_factorizeCreateBaseImageFromFirstImageInSequence \
    "$firstImageContainerID" \
    "$baseImageContainerID" \
    "$baseImageName" \
  && image_factorizeKillContainer "$firstImageContainerID"

  return $?
}

### kill the base image container running in background
### $1: container id to kill
image_factorizeKillContainer() {
  info 'killing running container'

  local containerID="$1"

  docker kill "$containerID" 1>/dev/null 2>&1 \
  || ( returnCode=$? \
       && fatal 'Could not kill the container' \
       && return $returnCode )

  return $?
}

### fill the base image with common files. Common files list is the
### base.image.dist file stored on the staging area. Any factorized image
### contain these common files
### $1: base image name
image_factorizeFillBaseImage() {
  info 'Filling the base image for factorization process'

  local baseImageName="$1"

  local temporaryVolumeName="$(image_factorizeCreateTemporaryVolume)" \
  && local containerID="$(
    image_factorizeRunImageWithVolumeAttached \
    "$baseImageName" "$temporaryVolumeName")" \
  && image_factorizeCopyCommonFilesInBaseImageContainer \
    "$containerID" "$baseImageName" "$temporaryVolumeName" \
  && image_factorizeKillContainer "$containerID" \
  && image_factorizeDestroyTemporaryVolume "$temporaryVolumeName"

  return $?
}

### Copy or overwrite some utilities from the docker/lib directory in the
### specified container
### $1: container ID to copy utilities to
image_factorizeCopyUtilitiesInContainer() {
  info 'copying utilities in container'

  local containerId="$1"

  docker exec "$containerId" mkdir -p /usr/local/bin \
  && docker cp \
    "$CARRIER_LIB_DIR"/exportPackageTo \
    "$containerId":/usr/local/bin/exportPackageTo \
  && docker cp \
    "$CARRIER_LIB_DIR"/importPackageFrom \
    "$containerId":/usr/local/bin/importPackageFrom \
  && docker exec "$containerId" chmod +x /usr/local/bin/exportPackageTo \
  && docker exec "$containerId" chmod +x /usr/local/bin/importPackageFrom \
  || ( returnCode=$? \
       && fatal 'could not copy utilities in container' \
       && return $returnCode )

  return $?
}

### Obtains the absolute path of a dist file from an image name to factorize in
### the image factorize staging directory
image_factorizeGetImageDistFilePathInStagingDirectoryFromImageName() {
  info 'getting the dist file absolute path from image name'

  local distFileName="$(path64Encode "$originalImageName")"'.dist' \
  && local distFilePath="$(image_getFactorizeStagingDirectory
    )"'/'"$distFileName" \
  || return $?

  echo "$distFilePath"

  return $?
}

### create a package in a shared volume, from an original image to factorize
### $1: original image rnning container, modified (dist file and utilities)
image_factorizeExportPackageFromOriginalImageContainerToSharedVolume() {
  info 'creating a package from original image to shared volume'

  local originalImageContainerID="$1"

  docker exec \
    "$originalImageContainerID" \
    sh -c 'exportPackageTo "$MOUNTPOINT"/package' \
  || ( returnCode=$? \
       && fatal 'Could not export the package in shared volume' \
       && return $returnCode )

  return $?
}

### import done package from the shared volume into the target image
### running container.
### $1: target image running container identifier
image_factorizeImportPackageFromSharedVolumeToTargetImageContainer() {
  info 'importing package from shared volume'

  local targetContainer="$1"

  docker exec "$targetContainer" sh -c 'cp "$MOUNTPOINT"/image.dist /' \
  && docker exec \
    "$targetContainer" \
    sh -c 'importPackageFrom "$MOUNTPOINT"/package' \
  || ( returnCode=$? \
       && fatal 'could not complete target image from package' \
       && return $returnCode )

  return $?
}

### commit a running container to an image
### $1: the running container identifier
### $2: the image name to commit to
image_factorizeCommitContainerToImage() {
  info 'committing container to image'

  local targetContainer="$1"
  local targetImageName="$2"

  local onBuildCommand='ONBUILD RUN rm -rf $MOUNTPOINT && unset MOUNTPOINT' \
  local cmdCommands='CMD sh' \
  && docker commit \
    --change="$onBuildCommand" \
    --change="$cmdCommands" \
    "$targetContainer" "$targetImageName" 1>/dev/null 2>&1 \
  || ( returnCode=$? \
       && fatal 'could not complete target image from package' \
       && return $returnCode )

  return $?
}

### copy the specific dist file from the image being factorized to a running
### container and the shared volume
### $1: original image name to factorize, used to retrieve the right dist file
###     in the image factorize staging area
### $2: running container identifier
image_factorizeCopyFactorizedDistFileInContainerAndSharedVolume() {
  info 'copying factorized image dist file to container and shared volume'

  local originalImageName="$1"
  local originalImageContainerID="$2"

  local targetFilePath='/image.dist'
  local sourceFilePath="$(
    image_factorizeGetImageDistFilePathInStagingDirectoryFromImageName \
    "$originalImageName")" \
  && image_factorizeCopyFileToContainerAndSharedVolume \
     "$originalImageContainerID" "$sourceFilePath" "$targetFilePath"

  return $?
}

### Copy all that is necessary in an original image to factorize running
### container
### $1: original image to factorize name
### $2: running container of the original image to factorize
image_factorizeSetupOriginalImageRunningContainer() {
  info 'preparing original image running container'

  local originalImageName="$1"
  local originalImageContainerID="$2"

  image_factorizeCopyFactorizedDistFileInContainerAndSharedVolume \
    "$originalImageName" "$originalImageContainerID" \
  && image_factorizeCopyUtilitiesInContainer "$originalImageContainerID" \
  && image_factorizeExportPackageFromOriginalImageContainerToSharedVolume \
    "$originalImageContainerID"

  return $?
}

### Copy all that is necessary in a transfert image running container
### $1: transfert image name
### $2: running container of the transfert image
image_factorizeSetupTransfertImageRunningContainer() {
  info 'preparing transfert image running container'

  local transfertImageName="$1"
  local transfertImageContainerID="$2"

  image_factorizeCopyUtilitiesInContainer "$transfertImageContainerID" \
  && image_factorizeImportPackageFromSharedVolumeToTargetImageContainer \
    "$transfertImageContainerID" \
  && image_factorizeCommitContainerToImage \
    "$transfertImageContainerID" "$transfertImageName"

  return $?
}

### create the transfert image using the content of the original image to
### factorize and the computed image.dist file present in staging area
### $1: original image running container ID
### $2: minimalistic transfert image running container ID
### $3: transfert image name
### $4: original image to factorize name
image_factorizeCreateTransfertImageFromOriginalImage() {
  info 'creating factorized image from the original one'

  local originalImageContainerID="$1"
  local transfertImageContainerID="$2"
  local transfertImageName="$3"
  local originalImageName="$4"

  image_factorizeSetupOriginalImageRunningContainer \
    "$originalImageName" "$originalImageContainerID" \
  && image_factorizeSetupTransfertImageRunningContainer \
    "$transfertImageName" "$transfertImageContainerID"

  return $?
}

### copy specific files from an image to factorize inside the new created
### transfert image using a shared volume as intermediate staging area
### $1: original image name
### $2: transfert image running container
### $3: transfert image name (to commit to)
### $4: temporary volume name to bind with original image container
image_factorizeCopySpecificFilesInTransfertImageContainer() {
  info 'copying specific image files to factorized image'

  local originalImageName="$1"
  local transfertImageContainerID="$2"
  local transfertImageName="$3"
  local temporaryVolumeName="$4"

  local originalImageContainerID="$(
    image_factorizeRunImageWithVolumeAttached \
    "$originalImageName" "$temporaryVolumeName")" \
  && image_factorizeCreateTransfertImageFromOriginalImage \
    "$originalImageContainerID" \
    "$transfertImageContainerID" \
    "$transfertImageName" \
    "$originalImageName" \
  && image_factorizeKillContainer "$originalImageContainerID" \
  || return $?

  return $?
}

### Given a minimalistic image, this function fills it with specific files of
### a given image.
### $1: the factorized image name (which ultimately will contain only specific
###     files regarding an existing base image already created and filled)
### $2: the original image name containing specific files to extract
image_factorizeFillTransfertImage() {
  info 'filling factorized image with specific files'

  local transfertImageName="$1"
  local originalImageName="$2"

  local temporaryVolumeName="$(image_factorizeCreateTemporaryVolume)" \
  && local containerID="$(
    image_factorizeRunImageWithVolumeAttached \
    "$transfertImageName" "$temporaryVolumeName")" \
  && image_factorizeCopySpecificFilesInTransfertImageContainer \
    "$originalImageName" \
    "$containerID" \
    "$transfertImageName" \
    "$temporaryVolumeName" \
  && image_factorizeKillContainer "$containerID" \
  && image_factorizeDestroyTemporaryVolume "$temporaryVolumeName"

  return $?
}

### Finalize the factorization process for a specified image name.
### $1: image name
image_factorizeFinalizeFactorizationForImage() {
  info "Finalizing factorization process"

  local image="$1"
  local removeImage=\
$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_REMOVE_ORIGINAL_IMAGES

  if [ $removeImage = 'yes' ]; then
    docker rmi "$image" \
    || ( returnCode=$? \
        && fatal 'cannot remove the docker image '"$image" \
        && return $returnCode )
  fi
}

### Build the final factorize image. Uses the specified transfert image name
### as base as it contains all necessary files. The original image name is here
### to get extra dockerfile commands that cannot be used in a docker commit
### invocation
### $1: transfert/factorized image name
### $2: original image to factorize name
image_factorizeBuildFactorizedImage() {
  info 'Building the final factorized image'

  local destinationImageName="$1"
  local originalImageName="$2"

  local dockerfileCommands="$(
    image_factorizeGenerateFactorizedImageDockerfileCommandsFrom \
    "$originalImageName" "$destinationImageName")" \
  || return $?

  echo "$dockerfileCommands" \
  | docker build --squash -t "$destinationImageName" - \
  || ( returnCode=$? \
       && fatal 'Could not build factorized image' \
       && return $returnCode )

  return $?
}

### Creates one factorized image
### $1: the original image to factorize
image_factorizeCreateOneFactorizedImage() {
  info 'Creating one factorized image'

  local image="$1"

  local finalImageName="$(image_factorizeBuildFactorizedImageName "$image")" \
  && local baseImageName="$(image_factorizeBuildBaseImageName)" \
  && image_factorizeInitializeMinimalisticTransfertImage \
    "$finalImageName" "$baseImageName" \
  && image_factorizeFillTransfertImage "$finalImageName" "$image" \
  && image_factorizeBuildFactorizedImage "$finalImageName" "$image" \
  && image_factorizeFinalizeFactorizationForImage "$image"

  return $?
}

### Creates all factorized images that have been specified, using dist file in
### the image factorize staging area
image_factorizeCreateFactorizedImages() {
  info 'creating factorized images'

  local imageSequence="$(image_getImageToFactorizeSequence)" \
  || return $?

  local image=
  for image in $imageSequence; do
    image_factorizeCreateOneFactorizedImage "$image" \
    || return $?
  done

  return $?
}

### build the base image name of a factorization command
image_factorizeBuildBaseImageName() {
  info 'building the base image name'

  local fullBaseImageName=\
"$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_PREFIX"\
'/'\
"$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_NAME"

  echo "$fullBaseImageName"

  return $?
}

### Build a factorizable image name.
### $1: image name to factorize
image_factorizeBuildFactorizedImageName() {
  info 'building a factorized image name'

  local image="$1"

  local baseImageName="$(image_factorizeBuildBaseImageName)" \
  || return $?

  local fullImageName="$baseImageName"'/'"$image"

  echo "$fullImageName"

  return $?
}

### verify if the base image name does not conflict with an existing image on
### the docker host
image_factorizeVerifyBaseImageName() {
  info 'verifying conflicts for base image name'

  image_factorizeIssueErrorIfImageNameExistsOnDockerHost 'base'

  return $?
}

### setup the images to factorize prefix. As it cannot be empty and defaulted
### to the base image prefix and name value, cannot be determined at execution
### context construction
image_factorizeSetupImagesToFactorizePrefix() {
  info 'setting up the image to factorize prefix'

  if [ -z "$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_FACTORIZED_IMAGE_PREFIX" ];
  then
    DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_FACTORIZED_IMAGE_PREFIX=\
"$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_BASE_IMAGE_PREFIX"
  fi

  return $?
}

### obtains the name of the function able to build a base image or a factorized
### image name from an image type
### $1: image type ('base' or 'factorized')
image_factorizeGetImageNameBuildFunctionFromImageType() {
  info 'getting the image name build function from image type'

  local imageType="$1"

  local buildImageNameFunction=
  if [ "$imageType" = 'factorized' ]; then
    buildImageNameFunction='image_factorizeBuildFactorizedImageName'
  elif [ "$imageType" = 'base' ]; then
    buildImageNameFunction='image_factorizeBuildBaseImageName'
  fi

  echo "$buildImageNameFunction"

  return $?
}

### issues an error if a factorizabe image or a base image name already exists
### on the docker host
### $1: image type to verify: either base or factorized
### $2: a docker image name, not mandatory
image_factorizeIssueErrorIfImageNameExistsOnDockerHost() {
  info 'checking if factorizable image or base image exists'

  local imageType="$1"
  local image="$2"
  local buildImageNameFunction="$(
    image_factorizeGetImageNameBuildFunctionFromImageType "$imageType")" \
  && local fullImageName="$("$buildImageNameFunction" "$image")" \
  && local image_id="$(image_checkIfExistsOnDockerHost "$fullImageName")" \
  || return $?

  if [ ! -z "$image_id" ]; then
    error 'the image '"$fullImageName"' already exists on the docker host'
    return 1
  fi

  return $?
}

### verify that each image to factorize will have a name that does not conflict
### with an existing image on the docker host
image_factorizeVerifyImagesNames() {
  info 'Verifying conflicts image names'

  image_factorizeSetupImagesToFactorizePrefix \
  && local sequence="$(image_getImageToFactorizeSequence)" \
  || return $?

  local image=
  for image in $sequence; do
    image_factorizeIssueErrorIfImageNameExistsOnDockerHost \
      'factorized' "$image" \
    || return $?
  done
  
  return $?
}

### checking if resulting image names are conflicting with existing image names
### on the docker host
image_factorizeCheckResultantImageNames() {
  info 'checking resultant image full names for possible conflicts'

  [ "$DOMAIN_IMAGE_COMMAND_FACTORIZE_OPTION_OVERWRITE_EXISTING" = 'yes' ] \
  && return 0

  image_factorizeVerifyBaseImageName \
  && image_factorizeVerifyImagesNames

  return $?
}


### factorization feature of the image domain
image_factorize() {
  info 'factorizing images'

  image_factorizeCheckResultantImageNames \
  && image_initializeFactorizeStagingDirectory \
  && image_createImagesDistFileInStagingDirectory \
  && image_factorizeCreateBaseImage \
  && image_factorizeCreateFactorizedImages \
  && image_cleanupFactorizeStagingDirectory \
  && pruneOrphanDockerImages 1>/dev/null 2>&1

  return $?
}

### checking image name or image's manifest file path.
image_checkManifestPathOrName() {
  info 'checking manifest file path or name'

  MANIFEST_FILE_PATH="$(
    getManifestFileFullPath 'image' "$1")"

  return $?
}

### look for the existence of foundation images on the docker host. If this
### check fails, no build is possible.
image_checkBootstrapImages() {
  info 'checking all bootstrap built images'

  # first, verify if bootstrap has built all necessary foundation images, that
  # is metabarj0/manifest, metabarj0/gcc, metabarj0/make and
  # metabarj0/docker-cli and alpine/wget
  local required_images="$(
  cat << EOI
metabarj0/manifest
metabarj0/gcc
metabarj0/make
metabarj0/docker-cli
alpine/wget
EOI
  )"

  for i in $required_images; do
    id=$(docker image ls -q $i)
    if [ -z $id ]; then
      error "$(cat << EOI
Error: the mandatory image "$i" has not been found on your docker host. Make
sure you have properly bootstrapped your docker host before attempting any
image build
EOI
)"
      return 1
    fi
  done

  return $?
}

### check for the existence of zll dependencies of the image requested to be
### built and attempt to build them if they are not present on the docker host.
image_buildDependencies() {
  info 'image build building dependencies'

  # browse all dependencies
  for dep in $REQUIRES; do
    # first, check on the host if the image exists; if so, continue without
    # building it
    local repository=$(docker image ls -q "$dep")
    if [ ! -z "$repository" ]; then
      info 'image '"$dep"' found on the docker host...continuing...'
      continue
    fi

    # no existing image found on the host, building it, the current directory
    # being the image staging directory, there must be a docker directory to
    # look into from the global docker tmp directory
    # TODO : rethink how manifest is found : source variables instead sed-ing
    #        it. Allows user to define its PROVIDES variable using any form
    #        that is valid in shell
    local dependency_manifest=$(
      find ${FETCHED_MANIFEST} \
        -name manifest \
        -exec \
          grep -EH 'PROVIDES='$dep'$' {} \; \
          | sed -E 's/^([^:]+):.+/\1/'
    )

    # transform dependency_manifest to be just the image name
    local dependency_manifest_dir=$(dirname $dependency_manifest)
    dependency_manifest=$(basename $dependency_manifest_dir)

    local this_script_name=$(basename $0)
    local this_script_path=${DOCKER_BIN_DIRECTORY}/$this_script_name

    # calling in a sub-shell, isolating shell variables from each other
    ( image_build "$dependency_manifest" )

    local returnCode=$?

    [ $returnCode -ne 0 ] \
    && error 'Failed to build image targeted by '"$dependency_manifest" \
    && return $returnCode
  done

  return 0
}

### gives the root directory of staging area used for image domain commands
image_getStagingRootDirectory() {
  info 'getting root staging directory'

  echo "${CARRIER_TMP_DIR}"/image

  return $?
}

### initialize a shell variable containing a directory id for the build command
### staging area
image_initializeImageBuildStagingDirectory() {
  info 'initializing image build staging directory'

  if [ ! -z "$DOMAIN_IMAGE_COMMAND_BUILD_STAGING_DIRECTORY" ]; then
    warning 'image build staging already initialized'
    return 0
  fi

  DOMAIN_IMAGE_COMMAND_BUILD_STAGING_DIRECTORY="$(
    image_getStagingRootDirectory
  )"/build/"$(generateRandomString)" \
  || return $?

  mkdir -p "$DOMAIN_IMAGE_COMMAND_BUILD_STAGING_DIRECTORY" \
  || fatal 'Could not create image build staging directory'
  
  return $?
}

### return the name of the staging directory for the build feature
image_getImageBuildStagingDirectory() {
  info 'getting image build staging directory'

  [ -z "$DOMAIN_IMAGE_COMMAND_BUILD_STAGING_DIRECTORY" ] \
  && error 'Image build staging directory has not been initialized' \
  && return 1

  echo "$DOMAIN_IMAGE_COMMAND_BUILD_STAGING_DIRECTORY"

  return $?
}

### obtains the full image directory given its manifest full path
### $1: manifest file full path
image_getImageDirectoryFromManifestFilePath() {
  info 'getting image directory from manifest file path'

  local image_directory="$(dirname $MANIFEST_FILE_PATH)" \
  || ( returnCode=$? \
       && fatal 'Could not get the image directory name' \
       && return $returnCode )

  echo "$image_directory"

  return $?
}

### copy an image directory to the staging area
### $1: image directory
### $2: image build staging directory
image_copyImageDirectoryToImageBuildStagingDirectory() {
  info 'copying image directory to image build staging area'

  local image_directory="$1"
  local staging_directory="$2"

  cp -a "$image_directory" "$staging_directory" \
  || ( returnCode=$? \
       && fatal 'could not copy image files to staging area' \
       && return $returnCode )

  return $?
}

### get an image name from its directory
### $1: directory full path
image_getImageNameFromDirectoryPath() {
  info 'getting image name from its directory path'

  local image_directory="$1"

  local image_name=$(basename $image_directory) \
  || ( returnCode=$? \
       && fatal 'Could not get the image name' \
       && return $returnCode ) \
  || return $?

  echo "$image_name"

  return $?
}

### initializes a specific image build staging directory. The directory already
### exist in the staging area bacause copied beforehand. Creates a shell
### variable usable in a couple of places
### $1: image build staging directory
### $2: image name to build
image_initializeImageToBuildDirectoryInBuildStagingArea() {
  info 'initializing specific image directory in image build staging area'

  local staging_directory="$1"
  local image_name="$2"

  DOMAIN_IMAGE_COMMAND_BUILD_IMAGE_STAGING_DIRECTORY=\
"${staging_directory}"/"$image_name"
}

### copy some utility files in image directory in image build staging area
image_copyUtilityFilesInImageBuildStagingArea() {
  info 'copying utility file in image specific directory in image build '\
'staging area'

  cd $CARRIER_LIB_DIR \
  && cp \
    .dockerignore \
    build-image.sh \
    build.sh \
    Dockerfile.build-image \
    exportPackageTo \
    functions.sh \
    importPackageFrom \
    $DOMAIN_IMAGE_COMMAND_BUILD_IMAGE_STAGING_DIRECTORY \
  && cd $USER_DIRECTORY \
  || ( returnCode=$? \
       && fatal 'could not copy utility files to staging area' \
       && return $returnCode )

  return $?
}

### fill the staging area with file necessary to build the image and its
### dependencies
image_fillImageBuildStagingArea() {
  info 'filling image build staging area'

  local image_directory="$(
    image_getImageDirectoryFromManifestFilePath)" \
  && local staging_directory="$(image_getImageBuildStagingDirectory)" \
  && image_copyImageDirectoryToImageBuildStagingDirectory \
    "$image_directory" "$staging_directory" \
  && local image_name="$(
    image_getImageNameFromDirectoryPath "$image_directory")" \
  && image_initializeImageToBuildDirectoryInBuildStagingArea \
    "$staging_directory" "$image_name" \
  && image_copyUtilityFilesInImageBuildStagingArea

  return $?
}

### build current image dependent images after a genuine carrier repository
### fetch
image_fetchAndBuildDependentImages() {
  info 'building image dependencies'

  if [ ! -z "$REQUIRES" ]; then
    info 'fetching genuine carrier repository...'

    fetchManifestImageContent \
      $DOMAIN_IMAGE_COMMAND_BUILD_IMAGE_STAGING_DIRECTORY \
    && image_buildDependencies
  fi

  return $?
}

### once everything is setup, build the requested image
image_buildImage() {
  info 'building requested image'

  # rely on some variables extracted from the manifest file that was parsed
  # subshelling necessary because of exec usage
  (
    exec \
      ${DOMAIN_IMAGE_COMMAND_BUILD_IMAGE_STAGING_DIRECTORY}/build.sh \
      $PROVIDES \
      $DOMAIN_IMAGE_COMMAND_BUILD_IMAGE_STAGING_DIRECTORY \
      "$SOURCES_FETCH_IMAGE" \
      "$SOURCES_FETCH_COMMAND" \
      "$SOURCES_TARBALL_NAME" \
      "$REQUIRES" \
      "$BUILD_EXTRA_DOCKERFILE_COMMANDS" \
      "$BASE_IMAGE" \
      "$FINAL_EXTRA_DOCKERFILE_COMMANDS"
  )

  return $?
}

### attempt to build the image and all of its dependencies
image_buildImageAndDependencies() {
  info 'building image and its dependencies if any'

  # source the content of the manifest file, that will initialize some useful
  # variables
  . $MANIFEST_FILE_PATH

  image_fetchAndBuildDependentImages \
  && image_buildImage

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'could not build image providing '"$PROVIDES"

  return $returnCode
}

### when the build is complete, cleanup the staging area
image_cleanupBuildStagingArea() {
  info 'cleaning up the staging area for image build command'

  rm -rf \
    "$DOMAIN_IMAGE_COMMAND_BUILD_IMAGE_STAGING_DIRECTORY" \
  || ( returnCode=$? \
       && fatal 'could not clean image build staging area' \
       && return $returnCode ) \
  || return $?

  removeDirectoryIfEmpty "$(image_getStagingRootDirectory)"

  return $?
}

### entrypoint for carrier image build... may be called recursively in case of
### dependency image building
### accept an image name or a manifest file path
image_build() {
  info 'building image'

  image_checkBootstrapImages \
  && image_checkManifestPathOrName "$1" \
  && image_initializeImageBuildStagingDirectory \
  && image_fillImageBuildStagingArea \
  && image_buildImageAndDependencies \
  && image_cleanupBuildStagingArea

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'image build failed at some point'

  return $returnCode
}

### gets the full path of a manifest file for an image.
### $1: may be either:
###     - a full path to a manifest file
###     - a relative path to a manifest file from where carrier was invoked
###     - an image name
image_getManifestFileFullPath() {
  info 'getting the full path of an image manifest file'

  # try to resolve the manifest file path by:
  #  - appending it to the current user directory, useful if relative path is
  #    provided
  #  - testing directly the file path, useful if absolute path is provided
  local manifest_arg="$1"
  if [ ! -f "${USER_DIRECTORY}"/"$manifest_arg" ] \
     && [ ! -f "$manifest_arg" ]; then
    # not a file path, testing the image name
    manifest_arg="${CARRIER_SHARE_IMAGES_DIR}"/"$manifest_arg"/manifest
    if [ ! -f "${manifest_arg}" ]; then
      error 'invalid manifest file path or image name specified'
      return 1
    fi
  fi

  echo "$manifest_arg"

  return $?
}
#### End of image domain specific functions

#### common cross-domain functions

### get the full manifest file path if the provided argument is correct
### $1: type of manifest file path to reolve (appliance or image)
### $2: may be either:
###     - a full path to a manifest file
###     - a relative path to a manifest file from where carrier was invoked
###     - an image or an appliance name
getManifestFileFullPath() {
  info 'resolving a manifest file full path'

  ( manifestFilePath="$("$1"_getManifestFileFullPath "$2")" \
    && echo "$manifestFilePath" )

  return $?
}

### query the docker host for a specific image name. If the image exists on the
### docker host, its id is echoed. If the image does not exist on the docker
### host, an empty output is echoed. If an error occurs while querying the
### docker host, an error code is returned
getDockerImageIdIfExists() {
  info 'looking for an image on the docker host'

  [ -z "$1" ] \
  && error 'docker image name unspecified. Cannot query the docker host' \
  && return 1

  local image_name="$1"

  local repository_id="$(docker image ls -q "$image_name")"

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'could not query '"$image_name"' on the docker host' \
  && return $returnCode

  echo "$repository_id"

  return $?
}

#### End of common cross-domain functions

#### appliance domain specific functions

### gets the full path of a manifest file for an appliance.
### $1: may be either:
###     - a full path to a manifest file
###     - a relative path to a manifest file from where carrier was invoked
###     - an appliance name
appliance_getManifestFileFullPath() {
  info 'getting appliance manifest file full path'

  # try to resolve the manifest file path by:
  #  - appending it to the current user directory, useful if relative path is
  #    provided
  #  - testing directly the file path, useful if absolute path is provided
  local manifest_arg="$1"
  if [ ! -f "${USER_DIRECTORY}"/"$manifest_arg" ] \
     && [ ! -f "$manifest_arg" ]; then
    # not a file path, testing the appliance name
    manifest_arg="${CARRIER_SHARE_APPLIANCES_DIR}"/"$manifest_arg"/manifest
    if [ ! -f "${manifest_arg}" ]; then
      error 'invalid manifest file path or appliance name specified'
      return 1
    fi
  fi

  echo "$manifest_arg"

  return $?
}

### source and validate (or invalidate) the appliance's manifest file. Ensure
### all mandatory variables are set. This is not a deep validation, this
### functions only verify the exposition of a global variable.
appliance_shallowValidateManifestFile() {
  info 'quick validating appliance manifest file'

  # first, source the manifest file
  . "$MANIFEST_FILE_PATH"

  # then, testing mandatory variables existence
  if [ -z "$COMPOSE_BUILD_CONTEXT" ]; then
    error "$(cat << EOI
The appliance's manifest file is ill formed as it lacks one mandatory variable
values.
In order to build an appliance, you must provide a value for the following
mandatory variable :

  COMPOSE_BUILD_CONTEXT

This variable maps a service's image name (in your docker-compose.yml file)
and a function name (defined in the manifest file). With these elements, the
appliance management system will be able to generate a Dockerfile for each
service of your appliance and build this image.

Taking into account this remark should help you to resolve your
problem
EOI
    )"
    return 1
  fi

  # shallow validation complete, the appliance name is gotten, assuming all is
  # OK so far
  APPLIANCE_NAME="$(basename "$(dirname "$MANIFEST_FILE_PATH")")" \
  || ( returnCode=$? \
       && fatal 'could not get the appliance name' \
       && return $returnCode )

  return $?
}

### check the argument provided by the user to this script. Ensure that
### arguments are correct before going any further
appliance_checkArgument() {
  info 'checking argument of the appliance domain invocation'

  MANIFEST_FILE_PATH="$(
    getManifestFileFullPath 'appliance' "$1")"

  return $?
}

### gets the appliance directory name from the full path of its manifest file
### $1: the appliance's manifest file full path
appliance_getApplianceDirectoryFromManifestFilePath() {
  info 'Getting the appliance directory name from the manifest file path'

  local appliance_directory="$(dirname "$MANIFEST_FILE_PATH")" \
  || ( returnCode=$? \
       && fatal 'Could not deduce the appliance directory name' \
       && return $returnCode )

  echo "$appliance_directory"

  return $?
}

### get the specific appliance being managed staging directory. The directory
### must has been initialized beforehand
appliance_getApplianceStagingDirectory() {
  info 'getting appliance staging directory'

  [ -z "$APPLIANCE_STAGING_DIRECTORY" ] \
  && error 'appliance staging directory has not been initialized' \
  && return 1

  echo "$APPLIANCE_STAGING_DIRECTORY"

  return $?
}

### copy the directory of the appliance being managed into the appliance
### staging area directory
### $1: appliance directory
appliance_copyApplianceDirectoryToApplianceStagingArea() {
  info 'copying appliance files into the appliance staging directory'

  local appliance_directory="$1"

  cp -a "$appliance_directory" "$(appliance_getApplianceStagingDirectory)" \
  || ( returnCode=$? \
       && fatal 'could not copy appliance files into staging area' \
       && return $returnCode )

  return $?
}

### copy utility files in lib/directory to the appliance staging directory
appliance_copyUtilityFilesToApplianceStagingDirectory() {
  info 'copying utility files into the appliance staging directory'

  cd "$CARRIER_LIB_DIR" \
  && cp \
    .dockerignore \
    exportPackageTo \
    functions.sh \
    importPackageFrom \
    "$APPLIANCE_NAMED_STAGING_DIRECTORY" \
  && cd "$USER_DIRECTORY" \
  || ( returnCode=$? \
       && fatal 'could not copy utility files into staging area' \
       && return $returnCode )

  return $?
}

### obtains the appliance name from its directory
### $1: appliance directory absolute path
appliance_getApplianceNameFromDirectoryPath() {
  info 'getting appliance name from its directory path'

  local appliance_directory="$1"

  local appliance_name=$(basename $appliance_directory) \
  || ( returnCode=$? \
       && fatal 'Could not get the appliance name' \
       && return $returnCode ) \
  || return $?

  echo "$appliance_name"

  return $?
}

### initializes a specific appliance staging directory. The directory already
### exist in the staging area bacause copied beforehand. Creates a shell
### variable usable in a couple of places
### $1: appliance staging directory
### $2: appliance name to manage
appliance_initializeApplianceDirectoryInStagingArea() {
  info 'initializing specific appliance directory in staging area'

  local staging_directory="$1"
  local appliance_name="$2"

  APPLIANCE_NAMED_STAGING_DIRECTORY=\
"${staging_directory}"/"$appliance_name"
}

### put all necessary files into the being built appliance staging directory.
appliance_fillStagingArea() {
  info 'filling appliance staging area'

  local appliance_directory="$(
    appliance_getApplianceDirectoryFromManifestFilePath \
    "$MANIFEST_FILE_PATH")" \
  && local staging_directory="$(
    appliance_getApplianceStagingDirectory)" \
  && local appliance_name="$(
    appliance_getApplianceNameFromDirectoryPath "$appliance_directory")" \
  && appliance_copyApplianceDirectoryToApplianceStagingArea \
    "$appliance_directory" \
  && appliance_initializeApplianceDirectoryInStagingArea \
    "$staging_directory" "$appliance_name" \
  && appliance_copyUtilityFilesToApplianceStagingDirectory

  return $?
}

### fetch a copy of the master branch of the carrier directory then, copy the
### entire docker directory into the staging directory. This manifest is used
### to build various dependencies and serve as a genuine repository.
appliance_fetchManifest() {
  info 'fetching manifest for appliance command execution'

  # use the metabarj0/manifest docker image that MUST exist
  local manifest_image="$(
    docker image ls --format='{{.Repository}}' metabarj0/manifest)"

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'could not locate metabarj0/manifest image on the docker host' \
  && return $returnCode

  if [ -z "$manifest_image" ]; then
    error "$(cat << EOI
Error: cannot find the metabarj0/manifest docker image on your docker host. This
image is built by the bootstrap process.
Possible causes are :

  - you did not bootstrap your system. See bootstrap documentation.
  - you accidentally (or not) removed or untagged the metabarj0/bootstrap docker
    image.

Taking these remarks into account should help you to resolve your
problem
EOI
    )"
    return 1
  fi

  # call to a functions.sh's utility
  fetchManifestImageContent "$APPLIANCE_STAGING_DIRECTORY"

  return $?
}

### build an image that is required for the appliance and that was not found on
### the docker host. Relies on the image build system.
appliance_buildDependentImage() {
  info 'building appliance dependent images'

  # uses the metabarj0/manifest container to build required images. It'll result
  # in the creation of a docker directory inside the appliance staging directory
  appliance_fetchManifest \
  || return $?

  local required_image_name="$1"

  # look for the manifest file providing this image, in genuine location, the
  # fetched manifest
  # TODO : same remark in build image system : source the variable value
  #        instead of sed-ing it
  local image_manifest_path="$(
    find "$FETCHED_MANIFEST" \
      -type f \
      -name manifest \
      -exec grep -EH 'PROVIDES='"$required_image_name"'$' {} \; \
      | sed -E 's/(.+):.*$/\1/')"

  if [ -z "$image_manifest_path" ]; then
    error "$( cat << EOI
Error: cannot find a suitable project to build the "$required_image_name".
Possible causes are :

  - mis-spelled required image name
  - project does not exist in the docker/share/images directory
  - project exists in your local copy of the docker/share/images directory but
    not on the distant repository that is fetched to build your dependent image
  - project is an image provided by the bootstrap process and
    your system is not bootstrapped. Such images are metabarj0/gcc,
    metabarj0/make... See bootstrap documentation for more details
  - The project exists on the distant repository and has all the necessary to be
    built BUT the 'PROVIDES' variable in the manifest file is not defined on an
    unique line (use the '\\' character after '=' for instance).

Taking these remarks into account should help you to solve you
problem
EOI
    )"

    return 1
  fi

  # I've the absolute path of the required image's manifest file, let's build it
  # in a new sub-shell
  ( ${CARRIER_BIN_DIR}/carrier image build "$image_manifest_path" ) \
  || ( returnCode=$? \
       && fatal 'could not build the dependent image targeted by '\
"$image_manifest_path" \
       && return $returnCode )

  return $?
}

### enumerates all required images needed by the appliance and build them if
### they are not on the docker host
appliance_checkRequiredImages() {
  info 'Checking required images for appliance'

  # manifest file read and validated, check existing images and attempt build
  # them if necessary
  local image=
  for image in $REQUIRED_IMAGES; do
    local image_name="$(
      docker image ls --format='{{.Repository}}' $image)"

    local returnCode=$?
    [ $returnCode -ne 0 ] \
    && fatal 'could not request '"$image"' on the docker host' \
    && return $returnCode

    # image does not exist on the docker host
    if [ -z "$image_name" ]; then
      appliance_buildDependentImage "$image" \
      || return $?
    fi
  done

  return 0
}

### generate Dockerfile instruction used in an appliance service Dockerfile
### $1: a map between required images and unique build stage names
appliance_createDockerfileDependenciesBuildStages() {
  info 'creating dependent images build stages'

  local names_aliases_map="$1"

  # result of the operation
  local dependencies_build_stages=

  local pair=
  for pair in $names_aliases_map; do
    # extract image name and build stage alias
    local name="$(keyOf "$pair")" \
    && local alias="$(valueOf "$pair")" \
    && local build_stage="$(cat << EOI
FROM $name as $alias
USER root:root
RUN exportPackageTo /tmp/package
EOI
    )" \
    && dependencies_build_stages="$(
      append "$dependencies_build_stages" \
             "$build_stage" \
             $'\n'
    )" \
    || return $?
  done

  echo "$dependencies_build_stages"

  return $?
}

### create this appliance specific build stages
appliance_createDockerfileOwnBuildStages() {
  info 'creating appliance specific build stages'

  cat << EOI
FROM $BASE_IMAGE as final
RUN mkdir -p /usr/local/bin/
COPY importPackageFrom /usr/local/bin
EOI

  return $?
}

appliance_createDockerfileImportBuildStages() {
  info 'creating Dockerfile import build stage for appliance service image'

  local names_aliases_map="$1"

  # results
  local appliance_image_imports=
  for pair in $names_aliases_map; do
    # extract build stage alias
    local alias="$(valueOf "$pair")" \
    && local dependency_import="$(cat << EOI
COPY --from=$alias /tmp/package /tmp/
RUN importPackageFrom /tmp/package
EOI
    )" \
    && appliance_image_imports="$(
      append "$appliance_image_imports" \
             "$dependency_import" \
             $'\n'
      )" \
      || return $?
  done

  echo "$appliance_image_imports"

  return $?
}

### final operation of the service Dockerfile construction: write all section
### to the Dockerfile plus some stuff
### $1: build stages of all service dependencies
### $2: appliance specific build stages
### $3: service dependencies import build stages
appliance_writeToServiceDockerfile() {
  info 'writing the appliance service Dockerfile'

  local dependencies_build_stages="$1"
  local appliance_build_stage="$2"
  local appliance_image_imports="$3"

  cat << EOI > "${APPLIANCE_NAMED_STAGING_DIRECTORY}"/Dockerfile
$dependencies_build_stages
$appliance_build_stage
$appliance_image_imports
RUN rm /usr/local/bin/importPackageFrom
$EXTRA_DOCKERFILE_COMMANDS
EOI

  return $?
}

### Generate the entire Dockerfile of an image of the appliance, relying on the
### content of the manifest file and values computed by the process of
### appliance building.
appliance_compileServiceDockerfile() {
  info 'compiling appliance docker file'

  # create a map between image used in build stages and their alias that will be
  # used later
  local names_aliases_map="$(
    mapImageNamesAndBuildStageAliases "$REQUIRED_IMAGES"
    )" \
  && local dependencies_build_stages="$(
    appliance_createDockerfileDependenciesBuildStages \
      "$names_aliases_map"
    )" \
  && local appliance_build_stage="$(
    appliance_createDockerfileOwnBuildStages
    )" \
  && local appliance_image_imports="$(
    appliance_createDockerfileImportBuildStages \
      "$names_aliases_map")" \
  && appliance_writeToServiceDockerfile \
    "$dependencies_build_stages" \
    "$appliance_build_stage" \
    "$appliance_image_imports"

  return $?
}

### create the service's docker image on the docker host using the generated
### Dockerfile
appliance_buildServiceImage() {
  info 'Building appliance service image'

  local image_name="$1"

  # now we have a dockerfile, we just have to use it to build the appliance
  # image, go to the build context

  # build a squashed image, docker compose can't do that yet
  # then cleanup intermediate images, docker compose don't do that yet
  cd "$APPLIANCE_NAMED_STAGING_DIRECTORY" \
  && docker build --squash -t "$image_name" . \
  && docker image prune -f \
  && cd "$USER_DIRECTORY"

  local returnCode=$?
  [ $returnCode -ne 0 ] \
  && fatal 'could not build service '"$image_name" \
  && return $returnCode

  return 0
}

### cleanup the appliance staging area when the build is complete
appliance_cleanupStagingArea() {
  rm -rf "$(appliance_getApplianceStagingDirectory)" \
  || ( returnCode=$? \
        && fatal 'could not remove appliance staging directory' \
        && return $returnCode ) \
  || return $?

  removeDirectoryIfEmpty "$(appliance_getStagingRootDirectory)" \
  || return $?

  APPLIANCE_STAGING_DIRECTORY=

  return $?
}

### source the specified function, exposing global variables useful to build a
### service image.
### $1 : function name
appliance_callBuildContextFunction() {
  info 'calling build context function '"$1"

  # execute the function
  "$1"

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'the build context function '"$1"' returned in error' \
  && return $returnCode

  # verify the presence of a mandatory variable, that must be defined by the
  # function execution
  if [ -z "$BASE_IMAGE" ]; then
    error "$(cat << EOI
Error: the BASE_IMAGE variable is not set.
This variable is mandatory to build your service image as it is the name of the
base image.

This variable must be exposed in the body of your build context function inside
the manifest file of your appliance.

Note that this variable must be global as a local variable has no definition
outside its function scope.

Taking this remark into account should help you to resolve your
problem
EOI
    )"
    return 1
  fi

  return 0
}

### unset global variables exposed by one of the manifest's function call
appliance_unsetBuildContextVariables() {
  info 'unsetting build context'

  unset BASE_IMAGE
  unset REQUIRED_IMAGES
  unset EXTRA_DOCKERFILE_COMMANDS

  return $?
}

### this function will build each and every image that are needed to build each
### service of the appliance. It relies on the content of the manifest file
### that has been source and roughly validated
appliance_buildServiceImages() {
  info 'building appliance service image'

  local pairSequence="$(
    makePairSequence "$COMPOSE_BUILD_CONTEXT")" \
  || return $?

  local pair_element=
  for pair_element in $pairSequence; do
    local image_name="$(keyOf "$pair_element")" \
    && local repository_id="$(getDockerImageIdIfExists "$image_name")" \
    || return $?

    if [ ! -z "$repository_id" ]; then
      info 'appliance service '"$image_name"' already exists'
      continue
    fi

    local function_name="$(valueOf "$pair_element")" \
    && appliance_callBuildContextFunction "$function_name" \
    && appliance_checkRequiredImages \
    && appliance_compileServiceDockerfile \
    && appliance_buildServiceImage "$image_name" \
    && appliance_unsetBuildContextVariables

    returnCode=$?

    [ $returnCode -ne 0 ] \
    && error 'Appliance service image build failed at some point' \
    && return $returnCode
  done

  return 0
}

### gets the root directory of appliance staging area
appliance_getStagingRootDirectory() {
  info 'getting the root appliance staging area directory'

  echo "${CARRIER_TMP_DIR}"/appliance

  return $?
}

### initializes the appliance staging directory for further uses
appliance_initializeApplianceStagingDirectory() {
  info 'Initializing appliance staging directory'

  if [ ! -z "$APPLIANCE_STAGING_DIRECTORY" ]; then
    warning 'appliance staging already initialized'
    return 0
  fi

  APPLIANCE_STAGING_DIRECTORY="$(
    appliance_getStagingRootDirectory
  )"/"$(generateRandomString)" \
  || return $?

  mkdir -p "$APPLIANCE_STAGING_DIRECTORY" \
  || fatal 'Could not create appliance staging directory'
  
  return $?
}

### entrypoint of the build command. In finality, create the appliance's docker
### image on the docker host.
appliance_build() {
  info 'building appliance'

  appliance_initializeApplianceStagingDirectory \
  && appliance_fillStagingArea \
  && appliance_buildServiceImages \
  && appliance_cleanupStagingArea

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'Appliance build failed at some point' \
  && return $returnCode

  return 0
}

### entrypoint of the start command. If the appliance requested to start has
### not been built yet, the system will attempt to build it first.
appliance_start() {
  info 'starting appliance'

  # if some image are not yet built, build them
  appliance_build \
  && appliance_initializeApplianceStagingDirectory \
  && appliance_fillStagingArea

  local returnCode=$?

  [ $returnCode -ne 0 ] \
  && error 'error when preparing appliance to start' \
  && return $returnCode

  # crafting the docker-compose command, inhibiting image creation that is
  # handled by this script and forcing container recreation, containers being
  # ephemeral
  local command='docker-compose up --no-build -d'

  cd "$APPLIANCE_NAMED_STAGING_DIRECTORY" \
  && eval "$command" \
  && cd "$USER_DIRECTORY"

  returnCode=$?

  [ $returnCode -ne 0 ] \
  && fatal 'could not start up the appliance. command was '"$command" \
  return $returnCode

  appliance_cleanupStagingArea

  return $?
}

### entrypoint for the stop command. If the appliance is running, stops it.
appliance_stop() {
  info 'stopping appliance'

  appliance_initializeApplianceStagingDirectory \
  && appliance_fillStagingArea \
  || return $?

  # crafting the docker-compose command, removing ephemeral containers
  local command='docker-compose rm -sf'

  # execute the docker-compose command
  cd "$APPLIANCE_NAMED_STAGING_DIRECTORY" \
  && eval "$command" \
  && cd "$USER_DIRECTORY"

  [ $? -ne 0 ] \
  && fatal 'could not stop the appliance. command was '"$command" \
  && return $returnCode

  appliance_cleanupStagingArea

  return $?
}

### generic function executing the right function depending on the command
### provided. The name of the function to call is built appending the command
### name and 'Appliance'
appliance_executeRequestedCommand() {
  info 'executing appliance '"$COMMAND"' command'

  # build the function name according to the provided command
  local function_name=appliance_${COMMAND}

  # make sure the manifest file is well formed and contains mandatory stuff
  appliance_shallowValidateManifestFile \
  && "$function_name"

  return $?
}

### main entrypoint to manage appliances
### $1: command related to the appliance domain (assumed)
appliance_manage() {
  info 'executing appliance command'

  appliance_checkArgument "$1" \
  && appliance_executeRequestedCommand

  return $?
}

### check minimal execution context required to execute successfully the
### appliance volume command
appliance_checkExecutionContextForVolumeCommand() {
  info 'checking minimal execution context required for appliance volume'

  if [ ! "$DOMAIN" = 'appliance' ] \
     || [ ! "$COMMAND" = 'volume' ]; then
    info "$(
      cat << EOI
appliance_checkExecutionContextForVolumeCommand can only be called when domain
is appliance and command is volume.
Current domain is $DOMAIN
Current command is $COMMAND
EOI
    )"

    return 1
  fi

  return 0
}

### obtains the function name to execute regarding the selected volume
### subcommand in the execution context
appliance_volumeGetSubcommandFunctionToExecute() {
  info 'obtaining the appliance volume subcommand function name'

  local radix='appliance_volumeExecute'

  [ ! -z "$DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_CLONE" ] \
  && echo "$radix"'Clone' \
  && return 0

  error 'Not yet implemented appliance volume subcommand specified'
  return 1
}

### check the execution context specific to the appliance volume clone
### subcommand
appliance_volumeCloneCheckExecutionContext() {
  info 'checking execution context for appliance volume clone subcommand'

  if [ -z "$DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_CLONE_VOLUME_MAP" ] \
     || [ -z "$DOMAIN_APPLIANCE_COMMAND_VOLUME_OPTION_APPLIANCE" ]; then
    error "$(
      cat << EOI
Cannot execute requested command. Cloning appliance volume(s) require to
specify both an appliance name and a volume map
EOI
      )"

    return 1
  fi

  return 0
}

### check the appliance name specified for the volume command of appliance
### domain. The appliance name must exist in docker/share/appliance directory.
appliance_volumeVerifyApplianceExists() {
  info 'verifying appliance name for volume command'

  local applianceManifestAbsolutePath="$(
    appliance_getManifestFileFullPath \
      "$DOMAIN_APPLIANCE_COMMAND_VOLUME_OPTION_APPLIANCE"
    )" \
    && local applianceDirectory="$(dirname "$applianceManifestAbsolutePath")" \
    && [ -f "$applianceDirectory"/docker-compose.yml ] \
    || ( returnCode=$? \
        && error "$(
        cat << EOI
Cannot find a valid appliance project named
$DOMAIN_APPLIANCE_COMMAND_VOLUME_OPTION_APPLIANCE
EOI
          )" \
        && return $returnCode )

  return $?
}

### get the compose default project name. carrier always use the default
### project name aka the directory name somewhat modified in old versions
### $1: carrier appliance name
appliance_getComposeOldDefaultProjectName() {
  info 'getting the compose old default project name'

  local applianceName="$1"

  echo "$applianceName" | sed 's/[^A-Za-z0-9]//g'

  return $?
}

### get the compose default project name. carrier always use the default
### project name aka the directory name .
### $1: carrier appliance name
appliance_getComposeDefaultProjectName() {
  info 'getting the compose default project name'

  local applianceName="$1"

  echo "$applianceName"

  return $?
}

### obtain the absolute path of the compose file of the specified appliance
### $1: appliance name
appliance_getComposeFilePath() {
  info 'obtaining appliance compose file path'

  local applianceName="$1"

  local applianceManifestFile="$(
    appliance_getManifestFileFullPath "$applianceName")" \
  || return $?

  local composeFile="$(
    dirname "$applianceManifestFile")"'/docker-compose.yml' \
  || ( returnCode=$? \
       error 'cannot get the compose file with the specified appliance name' \
       && return $returnCode ) \
  || return $?

  echo "$composeFile"

  return $?
}

### ensures we can find a compose project volume specified as argument
### $1: volume name to find using docker-compose
appliance_volumeEnsureApplianceVolumeExists() {
  info 'looking for compose volume'

  local volumeName="$1"

  local composeFile="$(
    appliance_getComposeFilePath \
    "$DOMAIN_APPLIANCE_COMMAND_VOLUME_OPTION_APPLIANCE")" \
  || return $?

  local composeVolume="$(
    docker-compose \
      -f "$composeFile" \
      config --volumes \
    | grep -x "$volumeName")"

  [ ! -z "$composeVolume" ] \
  || ( returnCode=$? \
       && error 'Cannot find appliance volume '"$volumeName"' for appliance '\
"$DOMAIN_APPLIANCE_COMMAND_VOLUME_OPTION_APPLIANCE" \
       && return $returnCode )

  return $?
}

### Ensures that a specified volume exists on the docker host. If the volume
### is created by an appliance (not external volume) a project name and a '_'
### is prefixed to the volume name
appliance_volumeEnsureDockerVolumeExistsAndGetIt() {
  info 'Ensuring docker volume exists for an appliance volume command'

  local volumeName="$1"

  local oldComposeProjectName="$(
    appliance_getComposeOldDefaultProjectName \
      "$DOMAIN_APPLIANCE_COMMAND_VOLUME_OPTION_APPLIANCE")" \
  && local decoratedOldVolumeName="$oldComposeProjectName"'_'"$volumeName" \
  && local composeProjectName="$(
    appliance_getComposeDefaultProjectName \
      "$DOMAIN_APPLIANCE_COMMAND_VOLUME_OPTION_APPLIANCE")" \
  && local decoratedVolumeName="$composeProjectName"'_'"$volumeName" \
  || return $?

  local realVolumeName=
  realVolumeName="$(getDockerVolumeIfExists "$volumeName")" \
  || realVolumeName="$(getDockerVolumeIfExists "$decoratedOldVolumeName")" \
  || realVolumeName="$(getDockerVolumeIfExists "$decoratedVolumeName")" \
  || ( returnCode=$? \
       && error 'cannot find appliance volume '"$volumeName"\
' on the docker host for the '\
"$DOMAIN_APPLIANCE_COMMAND_VOLUME_OPTION_APPLIANCE"' appliance' \
       && return $returnCode )

  echo "$realVolumeName"

  return $?
}

### looks for the appliance source volume to clone. Echoes the real name of the
### source volume if it exists
### $1: volume name to check
appliance_volumeCloneSeekSourceVolumeAndGetItsName() {
  info 'Searching for source volume to clone'

  local volumeName="$1"

  appliance_volumeEnsureApplianceVolumeExists "$volumeName" \
  && local realVolumeName="$(
    appliance_volumeEnsureDockerVolumeExistsAndGetIt "$volumeName")" \
  && echo "$realVolumeName"

  return $?
}

### verify volume name specified is correct regarding a pattern
### $1: volume name to verify
appliance_volumeCloneVerifyTargetVolumeName() {
  info 'verifying target volume name'

  local volumeName="$1"

  echo "$volumeName" \
  | grep -Ex '^[A-Za-z0-9][A-Za-z0-9_.-]+$' 2>/dev/null 1>&2 \
  || ( returnCode=$? \
       && error 'Invalid target volume name specified' \
       && return $returnCode )

  return $?
}

### ensures the volume name specified is not already taken by an existing
### volume on the docker host
appliance_volumeCloneVerifyTargetVolumeAvailaibility ()
{
  info 'verifying target volume name'

  local volumeName="$1"

  getDockerVolumeIfExists "$volumeName" 2>/dev/null 1>&2 \
  && error 'Docker volume already exists' \
  && return 1

  return 0
}

### verifies that the volume name is well-formed and not already taken by an
### existing volume on the docker host
### $1: volume name to verify
appliance_volumeCloneVerifyTargetVolumeNameAndAvailaibility() {
  info 'verifying target volume name and availaibility'

  local volumeName="$1"

  appliance_volumeCloneVerifyTargetVolumeName "$volumeName" \
  && appliance_volumeCloneVerifyTargetVolumeAvailaibility "$volumeName"

  return $?
}

### Runs a transfert container in order to copy content of a source volume to a
### target volume in a context of appliance volume cloning
### $1: source volume to copy stuff from
### $2: target volume to copy stuff to
appliance_volumeCloneRunTransfertContainer() {
  info 'Running a transfert container'

  local sourceVolume="$1"
  local targetVolume="$2"

  local runningContainer="$(
    docker run \
      --rm -d --entrypoint='' \
      -v "$sourceVolume":/tmp/src:ro \
      -v "$targetVolume":/tmp/dst \
      busybox \
      sh -c 'while true; do sleep 10; done'
  )" \
  || ( returnCode=$? \
       && fatal 'Cannot launch the transfer container' \
       && return $returnCode ) \
  || return $?

  echo "$runningContainer"

  return $?
}

### transferts the content of the source volume to the target volume
appliance_volumeCloneTransfertSourceVolumeContentToTargetVolume() {
  info 'transfert source volume content to the target volume'

  docker exec \
    "$runningContainer" \
    cp -a /tmp/src/. /tmp/dst/ 2>/dev/null 1>&2 \
  || ( returnCode=$? \
       && fatal 'Cannot copy from source to target volume' \
       && return $returnCode )

  return $?
}

### kills the running transfert container once the source volume content has
### been transfered successfully to the target volume
### $1: container ID to kill
appliance_volumeCloneKillRunningTransfertContainer() {
  info 'killing the running transfert container'

  local containerId="$1"

  docker kill "$containerId" 2>/dev/null 1>&2 \
  || ( returnCode=$? \
       && fatal 'Cannot kill the transfer container' \
       && return $returnCode )

  return $?
}

### proceeds with volume cloning. Copy the entire source volume content into a
### target volume, preserving all attributes of each copied file and directory
### $1: source volume name
### $2: target volume name
appliance_volumeCloneProceedForOneVolume() {
  info 'Cloning source volume to target volume'

  local sourceVolume="$1"
  local targetVolume="$2"

  local runningContainer="$(
    appliance_volumeCloneRunTransfertContainer \
      "$sourceVolume" "$targetVolume")" \
  && appliance_volumeCloneTransfertSourceVolumeContentToTargetVolume \
  && appliance_volumeCloneKillRunningTransfertContainer "$runningContainer"

  return $?
}

### attempts to clone from a source appliance volume to a new target volume
### $1: source volume attached to the appliance project
### $2: target volume name. must not already exist on the docker host
appliance_volumeCloneFromSourceVolumeToTargetVolume() {
  info 'cloning appliance volume from source to target'

  local sourceVolume="$1"
  local targetVolume="$2"

  local realSourceVolumeName="$(
    appliance_volumeCloneSeekSourceVolumeAndGetItsName "$sourceVolume"
  )" \
  && appliance_volumeCloneVerifyTargetVolumeNameAndAvailaibility \
    "$targetVolume" \
  && appliance_volumeCloneProceedForOneVolume \
    "$realSourceVolumeName" "$targetVolume"

  return $?
}

### verify the volume map input before executing the appliance volume clone
### subcommand
appliance_volumeVerifyVolumeMapCorrectness() {
  info 'verifying appliance volume clone volume map correctness'

  local pair=
  for pair in $DOMAIN_APPLIANCE_COMMAND_VOLUME_SUBCOMMAND_CLONE_VOLUME_MAP; do
    local sourceVolume="$(keyOf "$pair")" \
    && local targetVolume="$(valueOf "$pair")" \
    && appliance_volumeCloneFromSourceVolumeToTargetVolume \
      "$sourceVolume" "$targetVolume" \
    || return $?
  done

  return 0
}

### execute the appliance volume clone subcommand
appliance_volumeExecuteClone() {
  info 'attempting to clone appliance volume(s)'

  appliance_volumeCloneCheckExecutionContext \
  && appliance_volumeVerifyApplianceExists \
  && appliance_volumeVerifyVolumeMapCorrectness

  return $?
}

### execute the appliance volume subcommand targeted by the execution context
appliance_volumeExecuteSubcommand() {
  info 'Executing appliance volume subcommand'

  local functionName="$(appliance_volumeGetSubcommandFunctionToExecute)" \
  && "$functionName"

  return $?
}

#### End of appliance domain specific functions

### entry point
run() {
  info 'starting carrier execution'

  buildArgumentsReferential \
  && initializeExecutionContext \
  && buildExecutionContextFromArguments "$@" \
  || return $?

  executeWithTraceIfRequested "$@"\
  || ( returnCode=$? \
       && fatal 'could not restart in trace mode' \
       && return $returnCode ) \
  || return $?

  executeWithContext \
  || ( returnCode=$? \
       && usage \
       && return $returnCode )

  return $?
}

#### The script starts here once the standalone mode has passed
run "$@"
