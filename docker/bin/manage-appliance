#!/bin/sh

# /!\ DO NOT EDIT THIS FILE
# It is part of the appliance managing sub system of carrier. If you want
# modify the behavior of your appliance, please, modify your appliance's files
# that is the manifest file, the docker-compose file, any supplementary file of
# your appliance

set -e

# setup important docker directories in global variables that will be used later
setupDockerDirectories() {
  # current directory
  USER_DIRECTORY=$(pwd -P)

  # resolving important docker directories
  DOCKER_BIN_DIRECTORY=$(dirname $0)
  cd ${DOCKER_BIN_DIRECTORY}/..

  DOCKER_ROOT_DIRECTORY=$(pwd -P)
  DOCKER_BIN_DIRECTORY=${DOCKER_ROOT_DIRECTORY}/bin
  DOCKER_LIB_DIRECTORY=${DOCKER_ROOT_DIRECTORY}/lib
  DOCKER_TMP_DIRECTORY=${DOCKER_ROOT_DIRECTORY}/tmp
  DOCKER_SHARE_DIRECTORY=${DOCKER_ROOT_DIRECTORY}/share
  DOCKER_APPLIANCES_DIRECTORY=${DOCKER_SHARE_DIRECTORY}/appliances
  DOCKER_IMAGES_DIRECTORY=${DOCKER_SHARE_DIRECTORY}/images

  # back to current directory
  cd $USER_DIRECTORY
}

# source and validate (or invalidate) the appliance's manifest file. Ensure all
# mandatory variables are set.
validateManifestFile() {
  # first, source the manifest file
  . $MANIFEST_FILE_PATH

  # then, testing mandatory variables existence
  if [ -z "$IMAGE_NAME" ] \
     || [ -z "$CONTAINER_NAME" ] \
     || [ -z "$REQUIRED_IMAGES" ] \
     || [ -z "$SERVICE" ]; then
    error "$(
    cat << EOI
The appliance's manifest file is ill formed as it lacks one or several mandatory
variable values.
In order to build an appliance, you must provide a value for the following
mandatory variables :

  IMAGE_NAME      : the built appliance docker image name
  CONTAINER_NAME  : the container name of the running appliance
  REQUIRED_IMAGES : necessary docker images used to build the appliance
  SERVICE         : name of the service to interact with the appliance when you
                    start it

You can also set these optional variables :

  EXTENDS                   : Specify that this appliance will extend aplliances
                              specified in this variable value (NYI)
  BASE_IMAGE                : the docker base image to use to create this
                              appliance. Not that specifying an image having
                              its own libc (no matter its flavor is strongly
                              discouraged and could break your appliance)
  EXTRA_DOCKERFILE_COMMANDS : A set of Dockerfile command to append to the
                              generated Dockerfile used to build your appliance.
                              Usually, ENTRYPOINT command goes here but you're
                              not limited to this specific command. For instance,
                              you can use this variable to create supplementary
                              building stage using the last generated building
                              stage aliased with your appliance image name
  ENVIRONMENT               : a set of key=value pairs that is passed to the
                              command that run a built appliance.
  EXTRA_COMPOSE_ARGUMENTS   : Supplementary argument to provide to the
                              docker-compose run command executed when starting
                              the appliance.

Taking into account these remarks should help you to resolve your
problems...exiting...
EOI
    )"
    exit 1
  fi

  APPLIANCE_NAME=$(basename $(dirname $MANIFEST_FILE_PATH))
}

# help message on how to use the appliance management system.
usage() {
  error "$(
  cat << EOI
Invalid arguments specified. Usage :

  manage-appliance <command> <appliance> where

<command> is either :

  build
  start
  stop

and <appliance> is either :
- an absolute path to a manifest file of an appliance
- a relative path of a manifest file of an appliance
- an appliance name

Example :

  manage-appliance start devenv_cpp

will attempt to start the devenv_cpp appliance.

Notes :
- If an appliance is asked for starting and is not built beforehand, the system
  will attempt to build it first automatically.
- Attempting to stop an appliance that is not started does nothing.
EOI
  )"
}

# check the argument provided by the user to this script. Ensure that arguments
# are correct before going any further
checkArgument() {
  COMMAND="$1"

  # verify the command specified, if invalid, usage then exit 1
  if [ "$COMMAND" != 'build' ] \
     && [ "$COMMAND" != 'start' ] \
     && [ "$COMMAND" != 'stop' ]; then
    usage
    exit 1
  fi

  # try to resolve the manifest file path by:
  #  - appending it to the current user directory, useful if relative path is
  #    provided
  #  - testing directly the file path, useful if absolute path is provided
  local manifest_arg="$2"
  if [ ! -f ${USER_DIRECTORY}/"$manifest_arg" ] \
     && [ ! -f "$manifest_arg" ]; then
    # not a file path, testing the appliance name
    manifest_arg=${DOCKER_APPLIANCES_DIRECTORY}/"$2"/manifest
    if [ ! -f ${manifest_arg} ]; then
      usage
      exit 1
    fi
  fi

  # OK, valid argument, exposing the manifest file absolute path
  MANIFEST_FILE_PATH=${manifest_arg}
}

# simple utility telling if the targeted appliance already exists on your docker
# host
applianceExists() {
  # at this stage, the manifest file has been sourced and the appliance image
  # name is known
  local result="$(docker image ls --format='{{.Repository}}' $IMAGE_NAME)"

  if [ ! -z "$result" ]; then
    echo 0 # image does exist
  else
    echo 1 # image does not exist
  fi
}

# put all necessary files intor the being built appliance staging directory.
fillStagingArea() {
  local appliance_directory=$(dirname $MANIFEST_FILE_PATH)

  # create the intermediate appliance directory in the staging area if it does
  # not already exist
  local staging_directory=${DOCKER_TMP_DIRECTORY}/appliances
  mkdir -p $staging_directory

  # copy the project in the staging area
  cp -a $appliance_directory $staging_directory

  local staging_directory=${DOCKER_TMP_DIRECTORY}/appliances
  APPLIANCE_STAGING_DIRECTORY=${staging_directory}/$APPLIANCE_NAME

  # copy necessary lib files in the project directory in the staging area
  cd $DOCKER_LIB_DIRECTORY

  cp \
    .dockerignore \
    exportPackageTo \
    functions.sh \
    importPackageFrom \
    $APPLIANCE_STAGING_DIRECTORY

  cd $USER_DIRECTORY
}

# fetch a copy of the master branch of the carrier directory then, copy the
# entire docker directory into the staging directory. This manifest is used to
# build various dependencies and serve as a genuine repository.
fetchManifest() {
  # use the metabarj0/manifest docker image that MUST exist
  local manifest_image=$(
    docker image ls --format='{{.Repository}}' metabarj0/manifest)

  if [ -z $manifest_image ]; then
    error "$(cat << EOI
Error: cannot find the metabarj0/manifest docker image on your docker host. This
image is built by the bootstrap process.
Possible causes are :

  - you did not bootstrap your system. See bootstrap documentation.
  - you accidentally (or not) removed or untagged the metabarj0/bootstrap docker
    image.

Taking these remarks into account should help you to resolve your
problem...exiting...
EOI
    )"
    exit 1
  fi

  fetchManifestImageContent $APPLIANCE_STAGING_DIRECTORY
}

# build an image that is required for the appliance and that was not found on
# the docker host. Relies on the image build system.
buildDependentImage() {
  # uses the metabarj0/manifest container to build required images. It'll result
  # in the creation of a docker directory inside the appliance staging directory
  fetchManifest

  local required_image_name="$1"

  # look for the manifest file providing this image, in genuine location, the
  # fetched manifest
  local image_manifest_path=$(
    find $FETCHED_MANIFEST \
      -type f \
      -name manifest \
      -exec grep -EH 'PROVIDES='"$required_image_name" {} \; \
      | sed -E 's/(.+):.*$/\1/')

  if [ -z "$image_manifest_path" ]; then
    error "$( cat << EOI
Error: cannot find a suitable project to build the "$required_image_name".
Possible causes are :

  - mis-spelled required image name
  - project does not exist in the docker/share/images directory
  - project exists in your local copy of the docker/share/images directory but
    not on the distant repository that is fetched to build your dependent image
  - project is an image provided by the bootstrap process and
    your system is not bootstrapped. Such images are metabarj0/gcc,
    metabarj0/make... See bootstrap documentation for more details
  - The project exists on the distant repository and has all the necessary to be
    built BUT the 'PROVIDES' variable in the manifest file is not defined on an
    unique line (use the '\\' character after '=' for instance).

Taking these remarks into account should help you to solve you
problem...exiting
EOI
    )"

    exit 1
  fi

  # I've the absolute path of the required image's manifest file, let's build it
  # in a new sub-shell
  (
    exec ${FETCHED_MANIFEST}/bin/build-image \
      "$image_manifest_path"
  )
}

# enumerates all required images needed by the appliance and build them if
# they are not on the docker host
checkRequiredImages() {
  # manifest file read and validated, check existing images and attempt build
  # them if necessary
  local image=
  for image in $REQUIRED_IMAGES; do
    local image_name=$(
      docker image ls --format='{{.Repository}}' $image)

    # image does not exist on the docker host
    if [ -z $image_name ]; then
      buildDependentImage "$image"
    fi
  done
}

# utility function mapping image names with a build stage alias partially
# randomly generated. used in appliance's Dockerfile generation.
mapImageNameAndBuildStages() {
  local map=
  local pair=
  local image=
  for image in $REQUIRED_IMAGES; do
    pair="$(
      makePair \
        "$image" \
        "$(basename $image)"'_'"$(generateRandomBuildStageAlias)"
    )"

    map="$(append "$map" "$pair" ' ')"
  done

  echo "$map"
}

# Generate the entire Dockerfile of the appliance, relying on the content of the
# manifest file and values computed by the process of appliance building.
compileDockerfile() {
  # create a map between image used in build stages and their alias that will be
  # used later
  local name_alias_map="$(mapImageNameAndBuildStages)"

  # create a Dockerfile in the appliance staging directory. Using required image
  # specified in the manifest as well as other variables :
  local dependencies_build_stages=
  local build_stage=
  local pair=
  local name=
  local alias=
  for pair in $name_alias_map; do
    # extract image name and build stage alias
    name="$(keyOf "$pair")"
    alias="$(valueOf "$pair")"

    # instruction to export the dependency image package
    build_stage="$(cat << EOI
FROM $name as $alias
RUN exportPackageTo /tmp/package
EOI
    )"

    # group these instructions together
    dependencies_build_stages="$(
      append "$dependencies_build_stages" \
             "$build_stage" \
             $'\n'
    )"
  done

  # now, create the image of the appliance, relying on BASE_IMAGE variable if
  # set, otherwise, default it to busybox
  if [ -z "$BASE_IMAGE" ]; then
    BASE_IMAGE=busybox
  fi

  # copy tooling to extract dependencies' packages
  local appliance_build_stage="$(cat << EOI
FROM $BASE_IMAGE as $APPLIANCE_NAME
RUN mkdir -p /usr/local/bin/
COPY importPackageFrom /usr/local/bin
EOI
  )"

  # import each dependency image package
  local appliance_image_imports=
  local dependency_import=
  for pair in $name_alias_map; do
    # extract build stage alias
    alias="$(valueOf "$pair")"

    # create import instruction for each dependency
    dependency_import="$(cat << EOI
COPY --from=$alias /tmp/package /tmp/
RUN importPackageFrom /tmp/package
EOI
    )"

    # aggregate them
    appliance_image_imports="$(
      append "$appliance_image_imports" \
             "$dependency_import" \
             $'\n'
    )"
  done

  # final step, create the Dockerfile and appending the
  # EXTRA_DOCKERFILE_COMMANDS
  cat << EOI > ${APPLIANCE_STAGING_DIRECTORY}/Dockerfile
$dependencies_build_stages
$appliance_build_stage
$appliance_image_imports
RUN rm /usr/local/bin/importPackageFrom
$EXTRA_DOCKERFILE_COMMANDS
EOI
}

# create the appliance's docker image on the docker host using the generated
# Dockerfile
buildApplianceImage() {
  # now we have a dockerfile, we just have to use it to build the appliance
  # image, go to the build context
  cd $APPLIANCE_STAGING_DIRECTORY

  # build a squashed image
  docker build --squash -t $IMAGE_NAME .

  # cleanup intermediate images
  docker image prune -f

  cd $USER_DIRECTORY
}

# cleanup the appliance staging area when the build is complete
cleanupStagingArea() {
  if [ -d $APPLIANCE_STAGING_DIRECTORY ]; then
    rm -rf $APPLIANCE_STAGING_DIRECTORY
  fi

  if [ -z "$(ls ${DOCKER_TMP_DIRECTORY}/appliances)" ]; then
    rm -r ${DOCKER_TMP_DIRECTORY}/appliances
  fi
}

# entrypoint of the build command. In finality, create the appliance's docker
# image on the docker host.
buildAppliance() {
  if [ $(applianceExists) -eq 0 ]; then
    cat << EOI
Appliance '$APPLIANCE_NAME' already exists.
If you want to rebuild this appliance, consider either to retag the $IMAGE_NAME
docker repository or delete it...exiting...
EOI
    exit 0
  fi

  # prepare the staging area to build the appliance
  fillStagingArea

  # check if requested docker images are built. If not, the system will attempt
  # to build them.
  checkRequiredImages

  # then, generate the dockerfile to build the appliance docker image
  compileDockerfile

  # then, build the image
  buildApplianceImage

  # fnally, make some cleanup in the staging area
  cleanupStagingArea
}

# entrypoint of the start command. If the appliance requested to start has not
# been built yet, the system will attempt to build it first.
startAppliance() {
  if [ ! $(applianceExists) -eq 0 ]; then
    buildAppliance
  fi

  fillStagingArea
  cd $APPLIANCE_STAGING_DIRECTORY

  # manifest file has been read and validated. Creates the command to run the
  # service
  local environment=
  if [ ! -z "$ENVIRONMENT" ]; then
    local env=
    local environment_option=
    for env in $ENVIRONMENT; do
      environment_option='-e '$env
      environment="$(append "$environment" "$environment_option" ' ')"
    done
  fi

  # crafting the docker-compose run command...
  local command=$(echo \
    'CONTAINER_NAME='"$CONTAINER_NAME" \
    'IMAGE_NAME='"$IMAGE_NAME" \
    'docker-compose run --rm' \
    '--name '"$CONTAINER_NAME" \
    "$EXTRA_COMPOSE_ARGUMENTS" \
    "$environment" \
    "$SERVICE")

  # execute the docker-compose command
  eval "$command"

  cd $USER_DIRECTORY
  cleanupStagingArea
}

# utility function indicating of the appliance is running or not
applianceIsRunning() {
  # manifest file has been read and validated, we know the appliance container
  # name
  local result=$(
    docker ps --format='{{.Names}}' --filter='name='$CONTAINER_NAME)

  if [ -z "$result" ]; then
    echo 1 # is not running
  else
    echo 0 # is running
  fi
}

# entrypoint for the stop command. If the appliance is running, stops it.
stopAppliance() {
  if [ $(applianceIsRunning) -eq 0 ]; then
    fillStagingArea
    cd $APPLIANCE_STAGING_DIRECTORY

    # crafting the docker-compose run command...
    local command=$(echo \
      'docker stop '"$CONTAINER_NAME"
      )

    # execute the docker-compose command
    eval "$command"

    cd $USER_DIRECTORY
    cleanupStagingArea

    cat << EOI
Appliance '$APPLIANCE_NAME' successfully stopped.
EOI
  else
    cat << EOI
Appliance '$APPLIANCE_NAME' is not running. Nothing to do.
EOI
  fi
}

# generic function executing the right function depending on the command
# provided. The name of the function to call is built appending the command name
# and 'Appliance'
executeRequestedCommand() {
  # build the function name according to the provided command
  local function_name=${COMMAND}Appliance

  # make sure the manifest file is well formed and contains mandatory stuff
  validateManifestFile

  # simply call the function
  $function_name
}

# the execution begins right here
setupDockerDirectories

. ${DOCKER_LIB_DIRECTORY}/functions.sh

checkArgument "$1" "$2"
executeRequestedCommand
